// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class Assimp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Assimp(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Assimp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(uintptr_t)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(uintptr_t)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<uintptr_t> ___security_cookie =
      _lookup<uintptr_t>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo =
      __invalid_parameter_noinfoPtr.asFunction<void Function()>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr.asFunction<void Function()>();

  void _invoke_watson(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.UnsignedInt,
              uintptr_t)>>('_invoke_watson');
  late final __invoke_watson = __invoke_watsonPtr.asFunction<
      void Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.Int> _errno() {
    return __errno();
  }

  late final __errnoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>>('_errno');
  late final __errno = __errnoPtr.asFunction<ffi.Pointer<ffi.Int> Function()>();

  int _set_errno(
    int _Value,
  ) {
    return __set_errno(
      _Value,
    );
  }

  late final __set_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Int)>>('_set_errno');
  late final __set_errno = __set_errnoPtr.asFunction<int Function(int)>();

  int _get_errno(
    ffi.Pointer<ffi.Int> _Value,
  ) {
    return __get_errno(
      _Value,
    );
  }

  late final __get_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.Int>)>>(
          '_get_errno');
  late final __get_errno =
      __get_errnoPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int __threadid() {
    return ___threadid();
  }

  late final ___threadidPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>('__threadid');
  late final ___threadid = ___threadidPtr.asFunction<int Function()>();

  int __threadhandle() {
    return ___threadhandle();
  }

  late final ___threadhandlePtr =
      _lookup<ffi.NativeFunction<uintptr_t Function()>>('__threadhandle');
  late final ___threadhandle = ___threadhandlePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.UnsignedLong> __doserrno() {
    return ___doserrno();
  }

  late final ___doserrnoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.UnsignedLong> Function()>>(
          '__doserrno');
  late final ___doserrno =
      ___doserrnoPtr.asFunction<ffi.Pointer<ffi.UnsignedLong> Function()>();

  int _set_doserrno(
    int _Value,
  ) {
    return __set_doserrno(
      _Value,
    );
  }

  late final __set_doserrnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.UnsignedLong)>>(
          '_set_doserrno');
  late final __set_doserrno = __set_doserrnoPtr.asFunction<int Function(int)>();

  int _get_doserrno(
    ffi.Pointer<ffi.UnsignedLong> _Value,
  ) {
    return __get_doserrno(
      _Value,
    );
  }

  late final __get_doserrnoPtr = _lookup<
          ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.UnsignedLong>)>>(
      '_get_doserrno');
  late final __get_doserrno = __get_doserrnoPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedLong>)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> _Buf,
    int _Val,
    int _MaxCount,
  ) {
    return _memchr(
      _Buf,
      _Val,
      _MaxCount,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
  ) {
    return _memcmp(
      _Buf1,
      _Buf2,
      _Size,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Size,
  ) {
    return _memcpy(
      _Dst,
      _Src,
      _Size,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Size,
  ) {
    return _memmove(
      _Dst,
      _Src,
      _Size,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> _Dst,
    int _Val,
    int _Size,
  ) {
    return _memset(
      _Dst,
      _Val,
      _Size,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> _Str,
    int _Val,
  ) {
    return _strchr(
      _Str,
      _Val,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> _Str,
    int _Ch,
  ) {
    return _strrchr(
      _Str,
      _Ch,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _SubStr,
  ) {
    return _strstr(
      _Str,
      _SubStr,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> wcschr(
    ffi.Pointer<ffi.WChar> _Str,
    int _Ch,
  ) {
    return _wcschr(
      _Str,
      _Ch,
    );
  }

  late final _wcschrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('wcschr');
  late final _wcschr = _wcschrPtr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsrchr(
    ffi.Pointer<ffi.WChar> _Str,
    int _Ch,
  ) {
    return _wcsrchr(
      _Str,
      _Ch,
    );
  }

  late final _wcsrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('wcsrchr');
  late final _wcsrchr = _wcsrchrPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsstr(
    ffi.Pointer<ffi.WChar> _Str,
    ffi.Pointer<ffi.WChar> _SubStr,
  ) {
    return _wcsstr(
      _Str,
      _SubStr,
    );
  }

  late final _wcsstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsstr');
  late final _wcsstr = _wcsstrPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _memicmp(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
  ) {
    return __memicmp(
      _Buf1,
      _Buf2,
      _Size,
    );
  }

  late final __memicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('_memicmp');
  late final __memicmp = __memicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int _memicmp_l(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
    _locale_t _Locale,
  ) {
    return __memicmp_l(
      _Buf1,
      _Buf2,
      _Size,
      _Locale,
    );
  }

  late final __memicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size, _locale_t)>>('_memicmp_l');
  late final __memicmp_l = __memicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, _locale_t)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Val,
    int _Size,
  ) {
    return _memccpy1(
      _Dst,
      _Src,
      _Val,
      _Size,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy1 = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int memicmp(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
  ) {
    return _memicmp1(
      _Buf1,
      _Buf2,
      _Size,
    );
  }

  late final _memicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memicmp');
  late final _memicmp1 = _memicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int wcscat_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscat_s(
      _Destination,
      _SizeInWords,
      _Source,
    );
  }

  late final _wcscat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>)>>('wcscat_s');
  late final _wcscat_s = _wcscat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>)>();

  int wcscpy_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscpy_s(
      _Destination,
      _SizeInWords,
      _Source,
    );
  }

  late final _wcscpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>)>>('wcscpy_s');
  late final _wcscpy_s = _wcscpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>)>();

  int wcsncat_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsncat_s(
      _Destination,
      _SizeInWords,
      _Source,
      _MaxCount,
    );
  }

  late final _wcsncat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>, rsize_t)>>('wcsncat_s');
  late final _wcsncat_s = _wcsncat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>, int)>();

  int wcsncpy_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsncpy_s(
      _Destination,
      _SizeInWords,
      _Source,
      _MaxCount,
    );
  }

  late final _wcsncpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>, rsize_t)>>('wcsncpy_s');
  late final _wcsncpy_s = _wcsncpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcstok_s(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Delimiter,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _Context,
  ) {
    return _wcstok_s(
      _String,
      _Delimiter,
      _Context,
    );
  }

  late final _wcstok_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>)>>('wcstok_s');
  late final _wcstok_s = _wcstok_sPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>)>();

  ffi.Pointer<ffi.WChar> _wcsdup(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcsdup(
      _String,
    );
  }

  late final __wcsdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcsdup');
  late final __wcsdup = __wcsdupPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcscat(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscat(
      _Destination,
      _Source,
    );
  }

  late final _wcscatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscat');
  late final _wcscat = _wcscatPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcscmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcscmp(
      _String1,
      _String2,
    );
  }

  late final _wcscmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscmp');
  late final _wcscmp = _wcscmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcscpy(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscpy(
      _Destination,
      _Source,
    );
  }

  late final _wcscpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscpy');
  late final _wcscpy = _wcscpyPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcscspn(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Control,
  ) {
    return _wcscspn(
      _String,
      _Control,
    );
  }

  late final _wcscspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscspn');
  late final _wcscspn = _wcscspnPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcslen(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcslen(
      _String,
    );
  }

  late final _wcslenPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.WChar>)>>('wcslen');
  late final _wcslen =
      _wcslenPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int wcsnlen(
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsnlen(
      _Source,
      _MaxCount,
    );
  }

  late final _wcsnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>('wcsnlen');
  late final _wcsnlen =
      _wcsnlenPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsncat(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _Count,
  ) {
    return _wcsncat(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _wcsncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('wcsncat');
  late final _wcsncat = _wcsncatPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int wcsncmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return _wcsncmp(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final _wcsncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcsncmp');
  late final _wcsncmp = _wcsncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsncpy(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _Count,
  ) {
    return _wcsncpy(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _wcsncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('wcsncpy');
  late final _wcsncpy = _wcsncpyPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcspbrk(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Control,
  ) {
    return _wcspbrk(
      _String,
      _Control,
    );
  }

  late final _wcspbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcspbrk');
  late final _wcspbrk = _wcspbrkPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcsspn(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Control,
  ) {
    return _wcsspn(
      _String,
      _Control,
    );
  }

  late final _wcsspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsspn');
  late final _wcsspn = _wcsspnPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcstok(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Delimiter,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _Context,
  ) {
    return _wcstok(
      _String,
      _Delimiter,
      _Context,
    );
  }

  late final _wcstokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>)>>('wcstok');
  late final _wcstok = _wcstokPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>)>();

  ffi.Pointer<ffi.WChar> _wcserror(
    int _ErrorNumber,
  ) {
    return __wcserror1(
      _ErrorNumber,
    );
  }

  late final __wcserrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.WChar> Function(ffi.Int)>>(
          '_wcserror');
  late final __wcserror1 =
      __wcserrorPtr.asFunction<ffi.Pointer<ffi.WChar> Function(int)>();

  int _wcserror_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _SizeInWords,
    int _ErrorNumber,
  ) {
    return __wcserror_s1(
      _Buffer,
      _SizeInWords,
      _ErrorNumber,
    );
  }

  late final __wcserror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, ffi.Int)>>('_wcserror_s');
  late final __wcserror_s1 = __wcserror_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> __wcserror(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return ___wcserror(
      _String,
    );
  }

  late final ___wcserrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('__wcserror');
  late final ___wcserror = ___wcserrorPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int __wcserror_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _ErrorMessage,
  ) {
    return ___wcserror_s(
      _Buffer,
      _SizeInWords,
      _ErrorMessage,
    );
  }

  late final ___wcserror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size,
              ffi.Pointer<ffi.WChar>)>>('__wcserror_s');
  late final ___wcserror_s = ___wcserror_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>)>();

  int _wcsicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return __wcsicmp(
      _String1,
      _String2,
    );
  }

  late final __wcsicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wcsicmp');
  late final __wcsicmp = __wcsicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wcsicmp_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    _locale_t _Locale,
  ) {
    return __wcsicmp_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __wcsicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              _locale_t)>>('_wcsicmp_l');
  late final __wcsicmp_l = __wcsicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsnicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return __wcsnicmp(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __wcsnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('_wcsnicmp');
  late final __wcsnicmp = __wcsnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsnicmp_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsnicmp_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsnicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsnicmp_l');
  late final __wcsnicmp_l = __wcsnicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  int _wcsnset_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    int _Value,
    int _MaxCount,
  ) {
    return __wcsnset_s(
      _Destination,
      _SizeInWords,
      _Value,
      _MaxCount,
    );
  }

  late final __wcsnset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size, ffi.WChar,
              ffi.Size)>>('_wcsnset_s');
  late final __wcsnset_s = __wcsnset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, int, int)>();

  ffi.Pointer<ffi.WChar> _wcsnset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
    int _MaxCount,
  ) {
    return __wcsnset(
      _String,
      _Value,
      _MaxCount,
    );
  }

  late final __wcsnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar, ffi.Size)>>('_wcsnset');
  late final __wcsnset = __wcsnsetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> _wcsrev(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcsrev(
      _String,
    );
  }

  late final __wcsrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcsrev');
  late final __wcsrev = __wcsrevPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _wcsset_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    int _Value,
  ) {
    return __wcsset_s(
      _Destination,
      _SizeInWords,
      _Value,
    );
  }

  late final __wcsset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, ffi.WChar)>>('_wcsset_s');
  late final __wcsset_s = __wcsset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> _wcsset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
  ) {
    return __wcsset(
      _String,
      _Value,
    );
  }

  late final __wcssetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('_wcsset');
  late final __wcsset = __wcssetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  int _wcslwr_s(
    ffi.Pointer<ffi.WChar> _String,
    int _SizeInWords,
  ) {
    return __wcslwr_s(
      _String,
      _SizeInWords,
    );
  }

  late final __wcslwr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>('_wcslwr_s');
  late final __wcslwr_s =
      __wcslwr_sPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> _wcslwr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcslwr(
      _String,
    );
  }

  late final __wcslwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcslwr');
  late final __wcslwr = __wcslwrPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _wcslwr_s_l(
    ffi.Pointer<ffi.WChar> _String,
    int _SizeInWords,
    _locale_t _Locale,
  ) {
    return __wcslwr_s_l(
      _String,
      _SizeInWords,
      _Locale,
    );
  }

  late final __wcslwr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, _locale_t)>>('_wcslwr_s_l');
  late final __wcslwr_s_l = __wcslwr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  ffi.Pointer<ffi.WChar> _wcslwr_l(
    ffi.Pointer<ffi.WChar> _String,
    _locale_t _Locale,
  ) {
    return __wcslwr_l(
      _String,
      _Locale,
    );
  }

  late final __wcslwr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, _locale_t)>>('_wcslwr_l');
  late final __wcslwr_l = __wcslwr_lPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsupr_s(
    ffi.Pointer<ffi.WChar> _String,
    int _Size,
  ) {
    return __wcsupr_s(
      _String,
      _Size,
    );
  }

  late final __wcsupr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>('_wcsupr_s');
  late final __wcsupr_s =
      __wcsupr_sPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> _wcsupr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcsupr(
      _String,
    );
  }

  late final __wcsuprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcsupr');
  late final __wcsupr = __wcsuprPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _wcsupr_s_l(
    ffi.Pointer<ffi.WChar> _String,
    int _Size,
    _locale_t _Locale,
  ) {
    return __wcsupr_s_l(
      _String,
      _Size,
      _Locale,
    );
  }

  late final __wcsupr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, _locale_t)>>('_wcsupr_s_l');
  late final __wcsupr_s_l = __wcsupr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  ffi.Pointer<ffi.WChar> _wcsupr_l(
    ffi.Pointer<ffi.WChar> _String,
    _locale_t _Locale,
  ) {
    return __wcsupr_l(
      _String,
      _Locale,
    );
  }

  late final __wcsupr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, _locale_t)>>('_wcsupr_l');
  late final __wcsupr_l = __wcsupr_lPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, _locale_t)>();

  int wcsxfrm(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsxfrm(
      _Destination,
      _Source,
      _MaxCount,
    );
  }

  late final _wcsxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcsxfrm');
  late final _wcsxfrm = _wcsxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsxfrm_l(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsxfrm_l(
      _Destination,
      _Source,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsxfrm_l');
  late final __wcsxfrm_l = __wcsxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  int wcscoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcscoll(
      _String1,
      _String2,
    );
  }

  late final _wcscollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscoll');
  late final _wcscoll = _wcscollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wcscoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    _locale_t _Locale,
  ) {
    return __wcscoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __wcscoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              _locale_t)>>('_wcscoll_l');
  late final __wcscoll_l = __wcscoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsicoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return __wcsicoll(
      _String1,
      _String2,
    );
  }

  late final __wcsicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wcsicoll');
  late final __wcsicoll = __wcsicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wcsicoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    _locale_t _Locale,
  ) {
    return __wcsicoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __wcsicoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              _locale_t)>>('_wcsicoll_l');
  late final __wcsicoll_l = __wcsicoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsncoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return __wcsncoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __wcsncollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('_wcsncoll');
  late final __wcsncoll = __wcsncollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsncoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsncoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsncoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsncoll_l');
  late final __wcsncoll_l = __wcsncoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  int _wcsnicoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return __wcsnicoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __wcsnicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('_wcsnicoll');
  late final __wcsnicoll = __wcsnicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsnicoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsnicoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsnicoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsnicoll_l');
  late final __wcsnicoll_l = __wcsnicoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  ffi.Pointer<ffi.WChar> wcsdup(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcsdup1(
      _String,
    );
  }

  late final _wcsdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcsdup');
  late final _wcsdup1 = _wcsdupPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int wcsicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcsicmp1(
      _String1,
      _String2,
    );
  }

  late final _wcsicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsicmp');
  late final _wcsicmp1 = _wcsicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcsnicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return _wcsnicmp1(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final _wcsnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcsnicmp');
  late final _wcsnicmp1 = _wcsnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsnset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
    int _MaxCount,
  ) {
    return _wcsnset1(
      _String,
      _Value,
      _MaxCount,
    );
  }

  late final _wcsnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar, ffi.Size)>>('wcsnset');
  late final _wcsnset1 = _wcsnsetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> wcsrev(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcsrev1(
      _String,
    );
  }

  late final _wcsrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcsrev');
  late final _wcsrev1 = _wcsrevPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcsset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
  ) {
    return _wcsset1(
      _String,
      _Value,
    );
  }

  late final _wcssetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('wcsset');
  late final _wcsset1 = _wcssetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcslwr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcslwr1(
      _String,
    );
  }

  late final _wcslwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcslwr');
  late final _wcslwr1 = _wcslwrPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcsupr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcsupr1(
      _String,
    );
  }

  late final _wcsuprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcsupr');
  late final _wcsupr1 = _wcsuprPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int wcsicoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcsicoll1(
      _String1,
      _String2,
    );
  }

  late final _wcsicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsicoll');
  late final _wcsicoll1 = _wcsicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int strcpy_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcpy_s(
      _Destination,
      _SizeInBytes,
      _Source,
    );
  }

  late final _strcpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>)>>('strcpy_s');
  late final _strcpy_s = _strcpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int strcat_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcat_s(
      _Destination,
      _SizeInBytes,
      _Source,
    );
  }

  late final _strcat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>)>>('strcat_s');
  late final _strcat_s = _strcat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int strerror_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _SizeInBytes,
    int _ErrorNumber,
  ) {
    return _strerror_s1(
      _Buffer,
      _SizeInBytes,
      _ErrorNumber,
    );
  }

  late final _strerror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int)>>('strerror_s');
  late final _strerror_s1 = _strerror_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int strncat_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
  ) {
    return _strncat_s(
      _Destination,
      _SizeInBytes,
      _Source,
      _MaxCount,
    );
  }

  late final _strncat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>, rsize_t)>>('strncat_s');
  late final _strncat_s = _strncat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int strncpy_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
  ) {
    return _strncpy_s(
      _Destination,
      _SizeInBytes,
      _Source,
      _MaxCount,
    );
  }

  late final _strncpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>, rsize_t)>>('strncpy_s');
  late final _strncpy_s = _strncpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_s(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Char> _Delimiter,
    ffi.Pointer<ffi.Pointer<ffi.Char>> _Context,
  ) {
    return _strtok_s(
      _String,
      _Delimiter,
      _Context,
    );
  }

  late final _strtok_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_s');
  late final _strtok_s = _strtok_sPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Void> _memccpy(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Val,
    int _MaxCount,
  ) {
    return __memccpy(
      _Dst,
      _Src,
      _Val,
      _MaxCount,
    );
  }

  late final __memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('_memccpy');
  late final __memccpy = __memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcat(
      _Destination,
      _Source,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcmp(
    ffi.Pointer<ffi.Char> _Str1,
    ffi.Pointer<ffi.Char> _Str2,
  ) {
    return _strcmp(
      _Str1,
      _Str2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _strcmpi(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return __strcmpi(
      _String1,
      _String2,
    );
  }

  late final __strcmpiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_strcmpi');
  late final __strcmpi = __strcmpiPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return _strcoll(
      _String1,
      _String2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _strcoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    _locale_t _Locale,
  ) {
    return __strcoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __strcoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              _locale_t)>>('_strcoll_l');
  late final __strcoll_l = __strcoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, _locale_t)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcpy(
      _Destination,
      _Source,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _Control,
  ) {
    return _strcspn(
      _Str,
      _Control,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> _strdup(
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return __strdup(
      _Source,
    );
  }

  late final __strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strdup');
  late final __strdup = __strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> _strerror(
    ffi.Pointer<ffi.Char> _ErrorMessage,
  ) {
    return __strerror(
      _ErrorMessage,
    );
  }

  late final __strerrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strerror');
  late final __strerror = __strerrorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strerror_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _ErrorMessage,
  ) {
    return __strerror_s(
      _Buffer,
      _SizeInBytes,
      _ErrorMessage,
    );
  }

  late final __strerror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('_strerror_s');
  late final __strerror_s = __strerror_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int _ErrorMessage,
  ) {
    return _strerror1(
      _ErrorMessage,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror1 =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int _stricmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return __stricmp(
      _String1,
      _String2,
    );
  }

  late final __stricmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_stricmp');
  late final __stricmp = __stricmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _stricoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return __stricoll(
      _String1,
      _String2,
    );
  }

  late final __stricollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_stricoll');
  late final __stricoll = __stricollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _stricoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    _locale_t _Locale,
  ) {
    return __stricoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __stricoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              _locale_t)>>('_stricoll_l');
  late final __stricoll_l = __stricoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, _locale_t)>();

  int _stricmp_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    _locale_t _Locale,
  ) {
    return __stricmp_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __stricmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              _locale_t)>>('_stricmp_l');
  late final __stricmp_l = __stricmp_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, _locale_t)>();

  int strlen(
    ffi.Pointer<ffi.Char> _Str,
  ) {
    return _strlen(
      _Str,
    );
  }

  late final _strlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>)>>('strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int _strlwr_s(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
  ) {
    return __strlwr_s(
      _String,
      _Size,
    );
  }

  late final __strlwr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('_strlwr_s');
  late final __strlwr_s =
      __strlwr_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> _strlwr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return __strlwr(
      _String,
    );
  }

  late final __strlwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strlwr');
  late final __strlwr = __strlwrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strlwr_s_l(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
    _locale_t _Locale,
  ) {
    return __strlwr_s_l(
      _String,
      _Size,
      _Locale,
    );
  }

  late final __strlwr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, _locale_t)>>('_strlwr_s_l');
  late final __strlwr_s_l = __strlwr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, _locale_t)>();

  ffi.Pointer<ffi.Char> _strlwr_l(
    ffi.Pointer<ffi.Char> _String,
    _locale_t _Locale,
  ) {
    return __strlwr_l(
      _String,
      _Locale,
    );
  }

  late final __strlwr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, _locale_t)>>('_strlwr_l');
  late final __strlwr_l = __strlwr_lPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, _locale_t)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _Count,
  ) {
    return _strncat(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> _Str1,
    ffi.Pointer<ffi.Char> _Str2,
    int _MaxCount,
  ) {
    return _strncmp(
      _Str1,
      _Str2,
      _MaxCount,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strnicmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return __strnicmp(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __strnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('_strnicmp');
  late final __strnicmp = __strnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strnicmp_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strnicmp_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __strnicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strnicmp_l');
  late final __strnicmp_l = __strnicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  int _strnicoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return __strnicoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __strnicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('_strnicoll');
  late final __strnicoll = __strnicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strnicoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strnicoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __strnicoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strnicoll_l');
  late final __strnicoll_l = __strnicoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  int _strncoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return __strncoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __strncollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('_strncoll');
  late final __strncoll = __strncollPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strncoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strncoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __strncoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strncoll_l');
  late final __strncoll_l = __strncoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  int __strncnt(
    ffi.Pointer<ffi.Char> _String,
    int _Count,
  ) {
    return ___strncnt(
      _String,
      _Count,
    );
  }

  late final ___strncntPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('__strncnt');
  late final ___strncnt =
      ___strncntPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _Count,
  ) {
    return _strncpy(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> _String,
    int _MaxCount,
  ) {
    return _strnlen(
      _String,
      _MaxCount,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int _strnset_s(
    ffi.Pointer<ffi.Char> _String,
    int _SizeInBytes,
    int _Value,
    int _MaxCount,
  ) {
    return __strnset_s(
      _String,
      _SizeInBytes,
      _Value,
      _MaxCount,
    );
  }

  late final __strnset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int,
              ffi.Size)>>('_strnset_s');
  late final __strnset_s = __strnset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  ffi.Pointer<ffi.Char> _strnset(
    ffi.Pointer<ffi.Char> _Destination,
    int _Value,
    int _Count,
  ) {
    return __strnset(
      _Destination,
      _Value,
      _Count,
    );
  }

  late final __strnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size)>>('_strnset');
  late final __strnset = __strnsetPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _Control,
  ) {
    return _strpbrk(
      _Str,
      _Control,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> _strrev(
    ffi.Pointer<ffi.Char> _Str,
  ) {
    return __strrev(
      _Str,
    );
  }

  late final __strrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strrev');
  late final __strrev = __strrevPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strset_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _DestinationSize,
    int _Value,
  ) {
    return __strset_s(
      _Destination,
      _DestinationSize,
      _Value,
    );
  }

  late final __strset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int)>>('_strset_s');
  late final __strset_s =
      __strset_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> _strset(
    ffi.Pointer<ffi.Char> _Destination,
    int _Value,
  ) {
    return __strset(
      _Destination,
      _Value,
    );
  }

  late final __strsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('_strset');
  late final __strset = __strsetPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _Control,
  ) {
    return _strspn(
      _Str,
      _Control,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Char> _Delimiter,
  ) {
    return _strtok(
      _String,
      _Delimiter,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _strupr_s(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
  ) {
    return __strupr_s(
      _String,
      _Size,
    );
  }

  late final __strupr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('_strupr_s');
  late final __strupr_s =
      __strupr_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> _strupr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return __strupr(
      _String,
    );
  }

  late final __struprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strupr');
  late final __strupr = __struprPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strupr_s_l(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
    _locale_t _Locale,
  ) {
    return __strupr_s_l(
      _String,
      _Size,
      _Locale,
    );
  }

  late final __strupr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, _locale_t)>>('_strupr_s_l');
  late final __strupr_s_l = __strupr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, _locale_t)>();

  ffi.Pointer<ffi.Char> _strupr_l(
    ffi.Pointer<ffi.Char> _String,
    _locale_t _Locale,
  ) {
    return __strupr_l(
      _String,
      _Locale,
    );
  }

  late final __strupr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, _locale_t)>>('_strupr_l');
  late final __strupr_l = __strupr_lPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, _locale_t)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
  ) {
    return _strxfrm(
      _Destination,
      _Source,
      _MaxCount,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strxfrm_l(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strxfrm_l(
      _Destination,
      _Source,
      _MaxCount,
      _Locale,
    );
  }

  late final __strxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strxfrm_l');
  late final __strxfrm_l = __strxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strdup1(
      _String,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup1 = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int strcmpi(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return _strcmpi1(
      _String1,
      _String2,
    );
  }

  late final _strcmpiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmpi');
  late final _strcmpi1 = _strcmpiPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int stricmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return _stricmp1(
      _String1,
      _String2,
    );
  }

  late final _stricmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stricmp');
  late final _stricmp1 = _stricmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strlwr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strlwr1(
      _String,
    );
  }

  late final _strlwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strlwr');
  late final _strlwr1 = _strlwrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int strnicmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return _strnicmp1(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final _strnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strnicmp');
  late final _strnicmp1 = _strnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strnset(
    ffi.Pointer<ffi.Char> _String,
    int _Value,
    int _MaxCount,
  ) {
    return _strnset1(
      _String,
      _Value,
      _MaxCount,
    );
  }

  late final _strnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size)>>('strnset');
  late final _strnset1 = _strnsetPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> strrev(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strrev1(
      _String,
    );
  }

  late final _strrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strrev');
  late final _strrev1 = _strrevPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strset(
    ffi.Pointer<ffi.Char> _String,
    int _Value,
  ) {
    return _strset1(
      _String,
      _Value,
    );
  }

  late final _strsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strset');
  late final _strset1 = _strsetPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strupr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strupr1(
      _String,
    );
  }

  late final _struprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strupr');
  late final _strupr1 = _struprPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<ai_real> _ai_epsilon = _lookup<ai_real>('ai_epsilon');

  double get ai_epsilon => _ai_epsilon.value;

  set ai_epsilon(double value) => _ai_epsilon.value = value;

  late final ffi.Pointer<ffi.Double> __HUGE = _lookup<ffi.Double>('_HUGE');

  double get _HUGE => __HUGE.value;

  set _HUGE(double value) => __HUGE.value = value;

  void _fperrraise(
    int _Except,
  ) {
    return __fperrraise(
      _Except,
    );
  }

  late final __fperrraisePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_fperrraise');
  late final __fperrraise = __fperrraisePtr.asFunction<void Function(int)>();

  int _dclass(
    double _X,
  ) {
    return __dclass(
      _X,
    );
  }

  late final __dclassPtr =
      _lookup<ffi.NativeFunction<ffi.Short Function(ffi.Double)>>('_dclass');
  late final __dclass = __dclassPtr.asFunction<int Function(double)>();

  int _fdclass(
    double _X,
  ) {
    return __fdclass(
      _X,
    );
  }

  late final __fdclassPtr =
      _lookup<ffi.NativeFunction<ffi.Short Function(ffi.Float)>>('_fdclass');
  late final __fdclass = __fdclassPtr.asFunction<int Function(double)>();

  int _dsign(
    double _X,
  ) {
    return __dsign(
      _X,
    );
  }

  late final __dsignPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>('_dsign');
  late final __dsign = __dsignPtr.asFunction<int Function(double)>();

  int _fdsign(
    double _X,
  ) {
    return __fdsign(
      _X,
    );
  }

  late final __fdsignPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('_fdsign');
  late final __fdsign = __fdsignPtr.asFunction<int Function(double)>();

  int _dpcomp(
    double _X,
    double _Y,
  ) {
    return __dpcomp(
      _X,
      _Y,
    );
  }

  late final __dpcompPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double, ffi.Double)>>(
          '_dpcomp');
  late final __dpcomp = __dpcompPtr.asFunction<int Function(double, double)>();

  int _fdpcomp(
    double _X,
    double _Y,
  ) {
    return __fdpcomp(
      _X,
      _Y,
    );
  }

  late final __fdpcompPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float, ffi.Float)>>(
          '_fdpcomp');
  late final __fdpcomp =
      __fdpcompPtr.asFunction<int Function(double, double)>();

  int _dtest(
    ffi.Pointer<ffi.Double> _Px,
  ) {
    return __dtest(
      _Px,
    );
  }

  late final __dtestPtr =
      _lookup<ffi.NativeFunction<ffi.Short Function(ffi.Pointer<ffi.Double>)>>(
          '_dtest');
  late final __dtest =
      __dtestPtr.asFunction<int Function(ffi.Pointer<ffi.Double>)>();

  int _fdtest(
    ffi.Pointer<ffi.Float> _Px,
  ) {
    return __fdtest(
      _Px,
    );
  }

  late final __fdtestPtr =
      _lookup<ffi.NativeFunction<ffi.Short Function(ffi.Pointer<ffi.Float>)>>(
          '_fdtest');
  late final __fdtest =
      __fdtestPtr.asFunction<int Function(ffi.Pointer<ffi.Float>)>();

  int _d_int(
    ffi.Pointer<ffi.Double> _Px,
    int _Xexp,
  ) {
    return __d_int(
      _Px,
      _Xexp,
    );
  }

  late final __d_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(ffi.Pointer<ffi.Double>, ffi.Short)>>('_d_int');
  late final __d_int =
      __d_intPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  int _fd_int(
    ffi.Pointer<ffi.Float> _Px,
    int _Xexp,
  ) {
    return __fd_int(
      _Px,
      _Xexp,
    );
  }

  late final __fd_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(ffi.Pointer<ffi.Float>, ffi.Short)>>('_fd_int');
  late final __fd_int =
      __fd_intPtr.asFunction<int Function(ffi.Pointer<ffi.Float>, int)>();

  int _dscale(
    ffi.Pointer<ffi.Double> _Px,
    int _Lexp,
  ) {
    return __dscale(
      _Px,
      _Lexp,
    );
  }

  late final __dscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(ffi.Pointer<ffi.Double>, ffi.Long)>>('_dscale');
  late final __dscale =
      __dscalePtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  int _fdscale(
    ffi.Pointer<ffi.Float> _Px,
    int _Lexp,
  ) {
    return __fdscale(
      _Px,
      _Lexp,
    );
  }

  late final __fdscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(ffi.Pointer<ffi.Float>, ffi.Long)>>('_fdscale');
  late final __fdscale =
      __fdscalePtr.asFunction<int Function(ffi.Pointer<ffi.Float>, int)>();

  int _dunscale(
    ffi.Pointer<ffi.Short> _Pex,
    ffi.Pointer<ffi.Double> _Px,
  ) {
    return __dunscale(
      _Pex,
      _Px,
    );
  }

  late final __dunscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(
              ffi.Pointer<ffi.Short>, ffi.Pointer<ffi.Double>)>>('_dunscale');
  late final __dunscale = __dunscalePtr.asFunction<
      int Function(ffi.Pointer<ffi.Short>, ffi.Pointer<ffi.Double>)>();

  int _fdunscale(
    ffi.Pointer<ffi.Short> _Pex,
    ffi.Pointer<ffi.Float> _Px,
  ) {
    return __fdunscale(
      _Pex,
      _Px,
    );
  }

  late final __fdunscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(
              ffi.Pointer<ffi.Short>, ffi.Pointer<ffi.Float>)>>('_fdunscale');
  late final __fdunscale = __fdunscalePtr.asFunction<
      int Function(ffi.Pointer<ffi.Short>, ffi.Pointer<ffi.Float>)>();

  int _dexp(
    ffi.Pointer<ffi.Double> _Px,
    double _Y,
    int _Eoff,
  ) {
    return __dexp(
      _Px,
      _Y,
      _Eoff,
    );
  }

  late final __dexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(
              ffi.Pointer<ffi.Double>, ffi.Double, ffi.Long)>>('_dexp');
  late final __dexp = __dexpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Double>, double, int)>();

  int _fdexp(
    ffi.Pointer<ffi.Float> _Px,
    double _Y,
    int _Eoff,
  ) {
    return __fdexp(
      _Px,
      _Y,
      _Eoff,
    );
  }

  late final __fdexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(
              ffi.Pointer<ffi.Float>, ffi.Float, ffi.Long)>>('_fdexp');
  late final __fdexp = __fdexpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Float>, double, int)>();

  int _dnorm(
    ffi.Pointer<ffi.UnsignedShort> _Ps,
  ) {
    return __dnorm(
      _Ps,
    );
  }

  late final __dnormPtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(ffi.Pointer<ffi.UnsignedShort>)>>('_dnorm');
  late final __dnorm =
      __dnormPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int _fdnorm(
    ffi.Pointer<ffi.UnsignedShort> _Ps,
  ) {
    return __fdnorm(
      _Ps,
    );
  }

  late final __fdnormPtr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(ffi.Pointer<ffi.UnsignedShort>)>>('_fdnorm');
  late final __fdnorm =
      __fdnormPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  double _dpoly(
    double _X,
    ffi.Pointer<ffi.Double> _Tab,
    int _N,
  ) {
    return __dpoly(
      _X,
      _Tab,
      _N,
    );
  }

  late final __dpolyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Pointer<ffi.Double>, ffi.Int)>>('_dpoly');
  late final __dpoly = __dpolyPtr
      .asFunction<double Function(double, ffi.Pointer<ffi.Double>, int)>();

  double _fdpoly(
    double _X,
    ffi.Pointer<ffi.Float> _Tab,
    int _N,
  ) {
    return __fdpoly(
      _X,
      _Tab,
      _N,
    );
  }

  late final __fdpolyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Pointer<ffi.Float>, ffi.Int)>>('_fdpoly');
  late final __fdpoly = __fdpolyPtr
      .asFunction<double Function(double, ffi.Pointer<ffi.Float>, int)>();

  double _dlog(
    double _X,
    int _Baseflag,
  ) {
    return __dlog(
      _X,
      _Baseflag,
    );
  }

  late final __dlogPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          '_dlog');
  late final __dlog = __dlogPtr.asFunction<double Function(double, int)>();

  double _fdlog(
    double _X,
    int _Baseflag,
  ) {
    return __fdlog(
      _X,
      _Baseflag,
    );
  }

  late final __fdlogPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          '_fdlog');
  late final __fdlog = __fdlogPtr.asFunction<double Function(double, int)>();

  double _dsin(
    double _X,
    int _Qoff,
  ) {
    return __dsin(
      _X,
      _Qoff,
    );
  }

  late final __dsinPtr = _lookup<
          ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.UnsignedInt)>>(
      '_dsin');
  late final __dsin = __dsinPtr.asFunction<double Function(double, int)>();

  double _fdsin(
    double _X,
    int _Qoff,
  ) {
    return __fdsin(
      _X,
      _Qoff,
    );
  }

  late final __fdsinPtr = _lookup<
          ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.UnsignedInt)>>(
      '_fdsin');
  late final __fdsin = __fdsinPtr.asFunction<double Function(double, int)>();

  late final ffi.Pointer<_float_const> __Denorm_C =
      _lookup<_float_const>('_Denorm_C');

  ffi.Pointer<_float_const> get _Denorm_C => __Denorm_C;

  late final ffi.Pointer<_float_const> __Inf_C =
      _lookup<_float_const>('_Inf_C');

  ffi.Pointer<_float_const> get _Inf_C => __Inf_C;

  late final ffi.Pointer<_float_const> __Nan_C =
      _lookup<_float_const>('_Nan_C');

  ffi.Pointer<_float_const> get _Nan_C => __Nan_C;

  late final ffi.Pointer<_float_const> __Snan_C =
      _lookup<_float_const>('_Snan_C');

  ffi.Pointer<_float_const> get _Snan_C => __Snan_C;

  late final ffi.Pointer<_float_const> __Hugeval_C =
      _lookup<_float_const>('_Hugeval_C');

  ffi.Pointer<_float_const> get _Hugeval_C => __Hugeval_C;

  late final ffi.Pointer<_float_const> __FDenorm_C =
      _lookup<_float_const>('_FDenorm_C');

  ffi.Pointer<_float_const> get _FDenorm_C => __FDenorm_C;

  late final ffi.Pointer<_float_const> __FInf_C =
      _lookup<_float_const>('_FInf_C');

  ffi.Pointer<_float_const> get _FInf_C => __FInf_C;

  late final ffi.Pointer<_float_const> __FNan_C =
      _lookup<_float_const>('_FNan_C');

  ffi.Pointer<_float_const> get _FNan_C => __FNan_C;

  late final ffi.Pointer<_float_const> __FSnan_C =
      _lookup<_float_const>('_FSnan_C');

  ffi.Pointer<_float_const> get _FSnan_C => __FSnan_C;

  late final ffi.Pointer<_float_const> __LDenorm_C =
      _lookup<_float_const>('_LDenorm_C');

  ffi.Pointer<_float_const> get _LDenorm_C => __LDenorm_C;

  late final ffi.Pointer<_float_const> __LInf_C =
      _lookup<_float_const>('_LInf_C');

  ffi.Pointer<_float_const> get _LInf_C => __LInf_C;

  late final ffi.Pointer<_float_const> __LNan_C =
      _lookup<_float_const>('_LNan_C');

  ffi.Pointer<_float_const> get _LNan_C => __LNan_C;

  late final ffi.Pointer<_float_const> __LSnan_C =
      _lookup<_float_const>('_LSnan_C');

  ffi.Pointer<_float_const> get _LSnan_C => __LSnan_C;

  late final ffi.Pointer<_float_const> __Eps_C =
      _lookup<_float_const>('_Eps_C');

  ffi.Pointer<_float_const> get _Eps_C => __Eps_C;

  late final ffi.Pointer<_float_const> __Rteps_C =
      _lookup<_float_const>('_Rteps_C');

  ffi.Pointer<_float_const> get _Rteps_C => __Rteps_C;

  late final ffi.Pointer<_float_const> __FEps_C =
      _lookup<_float_const>('_FEps_C');

  ffi.Pointer<_float_const> get _FEps_C => __FEps_C;

  late final ffi.Pointer<_float_const> __FRteps_C =
      _lookup<_float_const>('_FRteps_C');

  ffi.Pointer<_float_const> get _FRteps_C => __FRteps_C;

  late final ffi.Pointer<_float_const> __LEps_C =
      _lookup<_float_const>('_LEps_C');

  ffi.Pointer<_float_const> get _LEps_C => __LEps_C;

  late final ffi.Pointer<_float_const> __LRteps_C =
      _lookup<_float_const>('_LRteps_C');

  ffi.Pointer<_float_const> get _LRteps_C => __LRteps_C;

  late final ffi.Pointer<ffi.Double> __Zero_C = _lookup<ffi.Double>('_Zero_C');

  double get _Zero_C => __Zero_C.value;

  set _Zero_C(double value) => __Zero_C.value = value;

  late final ffi.Pointer<ffi.Double> __Xbig_C = _lookup<ffi.Double>('_Xbig_C');

  double get _Xbig_C => __Xbig_C.value;

  set _Xbig_C(double value) => __Xbig_C.value = value;

  late final ffi.Pointer<ffi.Float> __FZero_C = _lookup<ffi.Float>('_FZero_C');

  double get _FZero_C => __FZero_C.value;

  set _FZero_C(double value) => __FZero_C.value = value;

  late final ffi.Pointer<ffi.Float> __FXbig_C = _lookup<ffi.Float>('_FXbig_C');

  double get _FXbig_C => __FXbig_C.value;

  set _FXbig_C(double value) => __FXbig_C.value = value;

  int abs(
    int _X,
  ) {
    return _abs(
      _X,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int _X,
  ) {
    return _labs(
      _X,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int _X,
  ) {
    return _llabs(
      _X,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  double acos(
    double _X,
  ) {
    return _acos(
      _X,
    );
  }

  late final _acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acos');
  late final _acos = _acosPtr.asFunction<double Function(double)>();

  double asin(
    double _X,
  ) {
    return _asin(
      _X,
    );
  }

  late final _asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asin');
  late final _asin = _asinPtr.asFunction<double Function(double)>();

  double atan(
    double _X,
  ) {
    return _atan(
      _X,
    );
  }

  late final _atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atan');
  late final _atan = _atanPtr.asFunction<double Function(double)>();

  double atan2(
    double _Y,
    double _X,
  ) {
    return _atan2(
      _Y,
      _X,
    );
  }

  late final _atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'atan2');
  late final _atan2 = _atan2Ptr.asFunction<double Function(double, double)>();

  double cos(
    double _X,
  ) {
    return _cos(
      _X,
    );
  }

  late final _cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cos');
  late final _cos = _cosPtr.asFunction<double Function(double)>();

  double cosh(
    double _X,
  ) {
    return _cosh(
      _X,
    );
  }

  late final _coshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cosh');
  late final _cosh = _coshPtr.asFunction<double Function(double)>();

  double exp(
    double _X,
  ) {
    return _exp(
      _X,
    );
  }

  late final _expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp');
  late final _exp = _expPtr.asFunction<double Function(double)>();

  double fabs(
    double _X,
  ) {
    return _fabs(
      _X,
    );
  }

  late final _fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('fabs');
  late final _fabs = _fabsPtr.asFunction<double Function(double)>();

  double fmod(
    double _X,
    double _Y,
  ) {
    return _fmod(
      _X,
      _Y,
    );
  }

  late final _fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmod');
  late final _fmod = _fmodPtr.asFunction<double Function(double, double)>();

  double log(
    double _X,
  ) {
    return _log(
      _X,
    );
  }

  late final _logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log');
  late final _log = _logPtr.asFunction<double Function(double)>();

  double log10(
    double _X,
  ) {
    return _log10(
      _X,
    );
  }

  late final _log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log10');
  late final _log10 = _log10Ptr.asFunction<double Function(double)>();

  double pow(
    double _X,
    double _Y,
  ) {
    return _pow(
      _X,
      _Y,
    );
  }

  late final _powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'pow');
  late final _pow = _powPtr.asFunction<double Function(double, double)>();

  double sin(
    double _X,
  ) {
    return _sin(
      _X,
    );
  }

  late final _sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sin');
  late final _sin = _sinPtr.asFunction<double Function(double)>();

  double sinh(
    double _X,
  ) {
    return _sinh(
      _X,
    );
  }

  late final _sinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sinh');
  late final _sinh = _sinhPtr.asFunction<double Function(double)>();

  double sqrt(
    double _X,
  ) {
    return _sqrt(
      _X,
    );
  }

  late final _sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sqrt');
  late final _sqrt = _sqrtPtr.asFunction<double Function(double)>();

  double tan(
    double _X,
  ) {
    return _tan(
      _X,
    );
  }

  late final _tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tan');
  late final _tan = _tanPtr.asFunction<double Function(double)>();

  double tanh(
    double _X,
  ) {
    return _tanh(
      _X,
    );
  }

  late final _tanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tanh');
  late final _tanh = _tanhPtr.asFunction<double Function(double)>();

  double acosh(
    double _X,
  ) {
    return _acosh(
      _X,
    );
  }

  late final _acoshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acosh');
  late final _acosh = _acoshPtr.asFunction<double Function(double)>();

  double asinh(
    double _X,
  ) {
    return _asinh(
      _X,
    );
  }

  late final _asinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asinh');
  late final _asinh = _asinhPtr.asFunction<double Function(double)>();

  double atanh(
    double _X,
  ) {
    return _atanh(
      _X,
    );
  }

  late final _atanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atanh');
  late final _atanh = _atanhPtr.asFunction<double Function(double)>();

  double atof(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _atof(
      _String,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double _atof_l(
    ffi.Pointer<ffi.Char> _String,
    _locale_t _Locale,
  ) {
    return __atof_l(
      _String,
      _Locale,
    );
  }

  late final __atof_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>, _locale_t)>>('_atof_l');
  late final __atof_l = __atof_lPtr
      .asFunction<double Function(ffi.Pointer<ffi.Char>, _locale_t)>();

  double _cabs(
    _complex _Complex_value,
  ) {
    return __cabs(
      _Complex_value,
    );
  }

  late final __cabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(_complex)>>('_cabs');
  late final __cabs = __cabsPtr.asFunction<double Function(_complex)>();

  double cbrt(
    double _X,
  ) {
    return _cbrt(
      _X,
    );
  }

  late final _cbrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cbrt');
  late final _cbrt = _cbrtPtr.asFunction<double Function(double)>();

  double ceil(
    double _X,
  ) {
    return _ceil(
      _X,
    );
  }

  late final _ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('ceil');
  late final _ceil = _ceilPtr.asFunction<double Function(double)>();

  double _chgsign(
    double _X,
  ) {
    return __chgsign(
      _X,
    );
  }

  late final __chgsignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_chgsign');
  late final __chgsign = __chgsignPtr.asFunction<double Function(double)>();

  double copysign(
    double _Number,
    double _Sign,
  ) {
    return _copysign1(
      _Number,
      _Sign,
    );
  }

  late final _copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'copysign');
  late final _copysign1 =
      _copysignPtr.asFunction<double Function(double, double)>();

  double _copysign(
    double _Number,
    double _Sign,
  ) {
    return __copysign(
      _Number,
      _Sign,
    );
  }

  late final __copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          '_copysign');
  late final __copysign =
      __copysignPtr.asFunction<double Function(double, double)>();

  double erf(
    double _X,
  ) {
    return _erf(
      _X,
    );
  }

  late final _erfPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erf');
  late final _erf = _erfPtr.asFunction<double Function(double)>();

  double erfc(
    double _X,
  ) {
    return _erfc(
      _X,
    );
  }

  late final _erfcPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erfc');
  late final _erfc = _erfcPtr.asFunction<double Function(double)>();

  double exp2(
    double _X,
  ) {
    return _exp2(
      _X,
    );
  }

  late final _exp2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp2');
  late final _exp2 = _exp2Ptr.asFunction<double Function(double)>();

  double expm1(
    double _X,
  ) {
    return _expm1(
      _X,
    );
  }

  late final _expm1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('expm1');
  late final _expm1 = _expm1Ptr.asFunction<double Function(double)>();

  double fdim(
    double _X,
    double _Y,
  ) {
    return _fdim(
      _X,
      _Y,
    );
  }

  late final _fdimPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fdim');
  late final _fdim = _fdimPtr.asFunction<double Function(double, double)>();

  double floor(
    double _X,
  ) {
    return _floor(
      _X,
    );
  }

  late final _floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('floor');
  late final _floor = _floorPtr.asFunction<double Function(double)>();

  double fma(
    double _X,
    double _Y,
    double _Z,
  ) {
    return _fma(
      _X,
      _Y,
      _Z,
    );
  }

  late final _fmaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Double, ffi.Double)>>('fma');
  late final _fma =
      _fmaPtr.asFunction<double Function(double, double, double)>();

  double fmax(
    double _X,
    double _Y,
  ) {
    return _fmax(
      _X,
      _Y,
    );
  }

  late final _fmaxPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmax');
  late final _fmax = _fmaxPtr.asFunction<double Function(double, double)>();

  double fmin(
    double _X,
    double _Y,
  ) {
    return _fmin(
      _X,
      _Y,
    );
  }

  late final _fminPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmin');
  late final _fmin = _fminPtr.asFunction<double Function(double, double)>();

  double frexp(
    double _X,
    ffi.Pointer<ffi.Int> _Y,
  ) {
    return _frexp(
      _X,
      _Y,
    );
  }

  late final _frexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Int>)>>('frexp');
  late final _frexp =
      _frexpPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  double hypot(
    double _X,
    double _Y,
  ) {
    return _hypot1(
      _X,
      _Y,
    );
  }

  late final _hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'hypot');
  late final _hypot1 = _hypotPtr.asFunction<double Function(double, double)>();

  double _hypot(
    double _X,
    double _Y,
  ) {
    return __hypot(
      _X,
      _Y,
    );
  }

  late final __hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          '_hypot');
  late final __hypot = __hypotPtr.asFunction<double Function(double, double)>();

  int ilogb(
    double _X,
  ) {
    return _ilogb(
      _X,
    );
  }

  late final _ilogbPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>('ilogb');
  late final _ilogb = _ilogbPtr.asFunction<int Function(double)>();

  double ldexp(
    double _X,
    int _Y,
  ) {
    return _ldexp(
      _X,
      _Y,
    );
  }

  late final _ldexpPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'ldexp');
  late final _ldexp = _ldexpPtr.asFunction<double Function(double, int)>();

  double lgamma(
    double _X,
  ) {
    return _lgamma(
      _X,
    );
  }

  late final _lgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('lgamma');
  late final _lgamma = _lgammaPtr.asFunction<double Function(double)>();

  int llrint(
    double _X,
  ) {
    return _llrint(
      _X,
    );
  }

  late final _llrintPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llrint');
  late final _llrint = _llrintPtr.asFunction<int Function(double)>();

  int llround(
    double _X,
  ) {
    return _llround(
      _X,
    );
  }

  late final _llroundPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llround');
  late final _llround = _llroundPtr.asFunction<int Function(double)>();

  double log1p(
    double _X,
  ) {
    return _log1p(
      _X,
    );
  }

  late final _log1pPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log1p');
  late final _log1p = _log1pPtr.asFunction<double Function(double)>();

  double log2(
    double _X,
  ) {
    return _log2(
      _X,
    );
  }

  late final _log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log2');
  late final _log2 = _log2Ptr.asFunction<double Function(double)>();

  double logb(
    double _X,
  ) {
    return _logb(
      _X,
    );
  }

  late final _logbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('logb');
  late final _logb = _logbPtr.asFunction<double Function(double)>();

  int lrint(
    double _X,
  ) {
    return _lrint(
      _X,
    );
  }

  late final _lrintPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lrint');
  late final _lrint = _lrintPtr.asFunction<int Function(double)>();

  int lround(
    double _X,
  ) {
    return _lround(
      _X,
    );
  }

  late final _lroundPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lround');
  late final _lround = _lroundPtr.asFunction<int Function(double)>();

  int _matherr(
    ffi.Pointer<_exception> _Except,
  ) {
    return __matherr(
      _Except,
    );
  }

  late final __matherrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<_exception>)>>(
          '_matherr');
  late final __matherr =
      __matherrPtr.asFunction<int Function(ffi.Pointer<_exception>)>();

  double modf(
    double _X,
    ffi.Pointer<ffi.Double> _Y,
  ) {
    return _modf(
      _X,
      _Y,
    );
  }

  late final _modfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Double>)>>('modf');
  late final _modf =
      _modfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Double>)>();

  double nan(
    ffi.Pointer<ffi.Char> _X,
  ) {
    return _nan(
      _X,
    );
  }

  late final _nanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'nan');
  late final _nan =
      _nanPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nearbyint(
    double _X,
  ) {
    return _nearbyint(
      _X,
    );
  }

  late final _nearbyintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('nearbyint');
  late final _nearbyint = _nearbyintPtr.asFunction<double Function(double)>();

  double nextafter(
    double _X,
    double _Y,
  ) {
    return _nextafter(
      _X,
      _Y,
    );
  }

  late final _nextafterPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'nextafter');
  late final _nextafter =
      _nextafterPtr.asFunction<double Function(double, double)>();

  double remainder(
    double _X,
    double _Y,
  ) {
    return _remainder(
      _X,
      _Y,
    );
  }

  late final _remainderPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'remainder');
  late final _remainder =
      _remainderPtr.asFunction<double Function(double, double)>();

  double remquo(
    double _X,
    double _Y,
    ffi.Pointer<ffi.Int> _Z,
  ) {
    return _remquo(
      _X,
      _Y,
      _Z,
    );
  }

  late final _remquoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Double, ffi.Pointer<ffi.Int>)>>('remquo');
  late final _remquo = _remquoPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double rint(
    double _X,
  ) {
    return _rint(
      _X,
    );
  }

  late final _rintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('rint');
  late final _rint = _rintPtr.asFunction<double Function(double)>();

  double round(
    double _X,
  ) {
    return _round(
      _X,
    );
  }

  late final _roundPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('round');
  late final _round = _roundPtr.asFunction<double Function(double)>();

  double scalbln(
    double _X,
    int _Y,
  ) {
    return _scalbln(
      _X,
      _Y,
    );
  }

  late final _scalblnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Long)>>(
          'scalbln');
  late final _scalbln = _scalblnPtr.asFunction<double Function(double, int)>();

  double scalbn(
    double _X,
    int _Y,
  ) {
    return _scalbn(
      _X,
      _Y,
    );
  }

  late final _scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'scalbn');
  late final _scalbn = _scalbnPtr.asFunction<double Function(double, int)>();

  double tgamma(
    double _X,
  ) {
    return _tgamma(
      _X,
    );
  }

  late final _tgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tgamma');
  late final _tgamma = _tgammaPtr.asFunction<double Function(double)>();

  double trunc(
    double _X,
  ) {
    return _trunc(
      _X,
    );
  }

  late final _truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('trunc');
  late final _trunc = _truncPtr.asFunction<double Function(double)>();

  double _j0(
    double _X,
  ) {
    return __j0(
      _X,
    );
  }

  late final __j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_j0');
  late final __j0 = __j0Ptr.asFunction<double Function(double)>();

  double _j1(
    double _X,
  ) {
    return __j1(
      _X,
    );
  }

  late final __j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_j1');
  late final __j1 = __j1Ptr.asFunction<double Function(double)>();

  double _jn(
    int _X,
    double _Y,
  ) {
    return __jn(
      _X,
      _Y,
    );
  }

  late final __jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          '_jn');
  late final __jn = __jnPtr.asFunction<double Function(int, double)>();

  double _y0(
    double _X,
  ) {
    return __y0(
      _X,
    );
  }

  late final __y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_y0');
  late final __y0 = __y0Ptr.asFunction<double Function(double)>();

  double _y1(
    double _X,
  ) {
    return __y1(
      _X,
    );
  }

  late final __y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_y1');
  late final __y1 = __y1Ptr.asFunction<double Function(double)>();

  double _yn(
    int _X,
    double _Y,
  ) {
    return __yn(
      _X,
      _Y,
    );
  }

  late final __ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          '_yn');
  late final __yn = __ynPtr.asFunction<double Function(int, double)>();

  double acoshf(
    double _X,
  ) {
    return _acoshf(
      _X,
    );
  }

  late final _acoshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acoshf');
  late final _acoshf = _acoshfPtr.asFunction<double Function(double)>();

  double asinhf(
    double _X,
  ) {
    return _asinhf(
      _X,
    );
  }

  late final _asinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinhf');
  late final _asinhf = _asinhfPtr.asFunction<double Function(double)>();

  double atanhf(
    double _X,
  ) {
    return _atanhf(
      _X,
    );
  }

  late final _atanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanhf');
  late final _atanhf = _atanhfPtr.asFunction<double Function(double)>();

  double cbrtf(
    double _X,
  ) {
    return _cbrtf(
      _X,
    );
  }

  late final _cbrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cbrtf');
  late final _cbrtf = _cbrtfPtr.asFunction<double Function(double)>();

  double _chgsignf(
    double _X,
  ) {
    return __chgsignf(
      _X,
    );
  }

  late final __chgsignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('_chgsignf');
  late final __chgsignf = __chgsignfPtr.asFunction<double Function(double)>();

  double copysignf(
    double _Number,
    double _Sign,
  ) {
    return _copysignf1(
      _Number,
      _Sign,
    );
  }

  late final _copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'copysignf');
  late final _copysignf1 =
      _copysignfPtr.asFunction<double Function(double, double)>();

  double _copysignf(
    double _Number,
    double _Sign,
  ) {
    return __copysignf(
      _Number,
      _Sign,
    );
  }

  late final __copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          '_copysignf');
  late final __copysignf =
      __copysignfPtr.asFunction<double Function(double, double)>();

  double erff(
    double _X,
  ) {
    return _erff(
      _X,
    );
  }

  late final _erffPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erff');
  late final _erff = _erffPtr.asFunction<double Function(double)>();

  double erfcf(
    double _X,
  ) {
    return _erfcf(
      _X,
    );
  }

  late final _erfcfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erfcf');
  late final _erfcf = _erfcfPtr.asFunction<double Function(double)>();

  double expm1f(
    double _X,
  ) {
    return _expm1f(
      _X,
    );
  }

  late final _expm1fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expm1f');
  late final _expm1f = _expm1fPtr.asFunction<double Function(double)>();

  double exp2f(
    double _X,
  ) {
    return _exp2f(
      _X,
    );
  }

  late final _exp2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('exp2f');
  late final _exp2f = _exp2fPtr.asFunction<double Function(double)>();

  double fdimf(
    double _X,
    double _Y,
  ) {
    return _fdimf(
      _X,
      _Y,
    );
  }

  late final _fdimfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fdimf');
  late final _fdimf = _fdimfPtr.asFunction<double Function(double, double)>();

  double fmaf(
    double _X,
    double _Y,
    double _Z,
  ) {
    return _fmaf(
      _X,
      _Y,
      _Z,
    );
  }

  late final _fmafPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Float, ffi.Float)>>('fmaf');
  late final _fmaf =
      _fmafPtr.asFunction<double Function(double, double, double)>();

  double fmaxf(
    double _X,
    double _Y,
  ) {
    return _fmaxf(
      _X,
      _Y,
    );
  }

  late final _fmaxfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmaxf');
  late final _fmaxf = _fmaxfPtr.asFunction<double Function(double, double)>();

  double fminf(
    double _X,
    double _Y,
  ) {
    return _fminf(
      _X,
      _Y,
    );
  }

  late final _fminfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fminf');
  late final _fminf = _fminfPtr.asFunction<double Function(double, double)>();

  double _hypotf(
    double _X,
    double _Y,
  ) {
    return __hypotf(
      _X,
      _Y,
    );
  }

  late final __hypotfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          '_hypotf');
  late final __hypotf =
      __hypotfPtr.asFunction<double Function(double, double)>();

  int ilogbf(
    double _X,
  ) {
    return _ilogbf(
      _X,
    );
  }

  late final _ilogbfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('ilogbf');
  late final _ilogbf = _ilogbfPtr.asFunction<int Function(double)>();

  double lgammaf(
    double _X,
  ) {
    return _lgammaf(
      _X,
    );
  }

  late final _lgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('lgammaf');
  late final _lgammaf = _lgammafPtr.asFunction<double Function(double)>();

  int llrintf(
    double _X,
  ) {
    return _llrintf(
      _X,
    );
  }

  late final _llrintfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llrintf');
  late final _llrintf = _llrintfPtr.asFunction<int Function(double)>();

  int llroundf(
    double _X,
  ) {
    return _llroundf(
      _X,
    );
  }

  late final _llroundfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llroundf');
  late final _llroundf = _llroundfPtr.asFunction<int Function(double)>();

  double log1pf(
    double _X,
  ) {
    return _log1pf(
      _X,
    );
  }

  late final _log1pfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log1pf');
  late final _log1pf = _log1pfPtr.asFunction<double Function(double)>();

  double log2f(
    double _X,
  ) {
    return _log2f(
      _X,
    );
  }

  late final _log2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log2f');
  late final _log2f = _log2fPtr.asFunction<double Function(double)>();

  double logbf(
    double _X,
  ) {
    return _logbf1(
      _X,
    );
  }

  late final _logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logbf');
  late final _logbf1 = _logbfPtr.asFunction<double Function(double)>();

  int lrintf(
    double _X,
  ) {
    return _lrintf(
      _X,
    );
  }

  late final _lrintfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lrintf');
  late final _lrintf = _lrintfPtr.asFunction<int Function(double)>();

  int lroundf(
    double _X,
  ) {
    return _lroundf(
      _X,
    );
  }

  late final _lroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lroundf');
  late final _lroundf = _lroundfPtr.asFunction<int Function(double)>();

  double nanf(
    ffi.Pointer<ffi.Char> _X,
  ) {
    return _nanf(
      _X,
    );
  }

  late final _nanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Char>)>>(
          'nanf');
  late final _nanf =
      _nanfPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nearbyintf(
    double _X,
  ) {
    return _nearbyintf(
      _X,
    );
  }

  late final _nearbyintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('nearbyintf');
  late final _nearbyintf = _nearbyintfPtr.asFunction<double Function(double)>();

  double nextafterf(
    double _X,
    double _Y,
  ) {
    return _nextafterf1(
      _X,
      _Y,
    );
  }

  late final _nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'nextafterf');
  late final _nextafterf1 =
      _nextafterfPtr.asFunction<double Function(double, double)>();

  double remainderf(
    double _X,
    double _Y,
  ) {
    return _remainderf(
      _X,
      _Y,
    );
  }

  late final _remainderfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'remainderf');
  late final _remainderf =
      _remainderfPtr.asFunction<double Function(double, double)>();

  double remquof(
    double _X,
    double _Y,
    ffi.Pointer<ffi.Int> _Z,
  ) {
    return _remquof(
      _X,
      _Y,
      _Z,
    );
  }

  late final _remquofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Int>)>>('remquof');
  late final _remquof = _remquofPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double rintf(
    double _X,
  ) {
    return _rintf(
      _X,
    );
  }

  late final _rintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('rintf');
  late final _rintf = _rintfPtr.asFunction<double Function(double)>();

  double roundf(
    double _X,
  ) {
    return _roundf(
      _X,
    );
  }

  late final _roundfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('roundf');
  late final _roundf = _roundfPtr.asFunction<double Function(double)>();

  double scalblnf(
    double _X,
    int _Y,
  ) {
    return _scalblnf(
      _X,
      _Y,
    );
  }

  late final _scalblnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Long)>>(
          'scalblnf');
  late final _scalblnf =
      _scalblnfPtr.asFunction<double Function(double, int)>();

  double scalbnf(
    double _X,
    int _Y,
  ) {
    return _scalbnf(
      _X,
      _Y,
    );
  }

  late final _scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'scalbnf');
  late final _scalbnf = _scalbnfPtr.asFunction<double Function(double, int)>();

  double tgammaf(
    double _X,
  ) {
    return _tgammaf(
      _X,
    );
  }

  late final _tgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tgammaf');
  late final _tgammaf = _tgammafPtr.asFunction<double Function(double)>();

  double truncf(
    double _X,
  ) {
    return _truncf(
      _X,
    );
  }

  late final _truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('truncf');
  late final _truncf = _truncfPtr.asFunction<double Function(double)>();

  double _logbf(
    double _X,
  ) {
    return __logbf(
      _X,
    );
  }

  late final __logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('_logbf');
  late final __logbf = __logbfPtr.asFunction<double Function(double)>();

  double _nextafterf(
    double _X,
    double _Y,
  ) {
    return __nextafterf(
      _X,
      _Y,
    );
  }

  late final __nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          '_nextafterf');
  late final __nextafterf =
      __nextafterfPtr.asFunction<double Function(double, double)>();

  int _finitef(
    double _X,
  ) {
    return __finitef(
      _X,
    );
  }

  late final __finitefPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('_finitef');
  late final __finitef = __finitefPtr.asFunction<int Function(double)>();

  int _isnanf(
    double _X,
  ) {
    return __isnanf(
      _X,
    );
  }

  late final __isnanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('_isnanf');
  late final __isnanf = __isnanfPtr.asFunction<int Function(double)>();

  int _fpclassf(
    double _X,
  ) {
    return __fpclassf(
      _X,
    );
  }

  late final __fpclassfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('_fpclassf');
  late final __fpclassf = __fpclassfPtr.asFunction<int Function(double)>();

  int _set_FMA3_enable(
    int _Flag,
  ) {
    return __set_FMA3_enable(
      _Flag,
    );
  }

  late final __set_FMA3_enablePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          '_set_FMA3_enable');
  late final __set_FMA3_enable =
      __set_FMA3_enablePtr.asFunction<int Function(int)>();

  int _get_FMA3_enable() {
    return __get_FMA3_enable();
  }

  late final __get_FMA3_enablePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('_get_FMA3_enable');
  late final __get_FMA3_enable =
      __get_FMA3_enablePtr.asFunction<int Function()>();

  double acosf(
    double _X,
  ) {
    return _acosf(
      _X,
    );
  }

  late final _acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acosf');
  late final _acosf = _acosfPtr.asFunction<double Function(double)>();

  double asinf(
    double _X,
  ) {
    return _asinf(
      _X,
    );
  }

  late final _asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinf');
  late final _asinf = _asinfPtr.asFunction<double Function(double)>();

  double atan2f(
    double _Y,
    double _X,
  ) {
    return _atan2f(
      _Y,
      _X,
    );
  }

  late final _atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'atan2f');
  late final _atan2f = _atan2fPtr.asFunction<double Function(double, double)>();

  double atanf(
    double _X,
  ) {
    return _atanf(
      _X,
    );
  }

  late final _atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanf');
  late final _atanf = _atanfPtr.asFunction<double Function(double)>();

  double ceilf(
    double _X,
  ) {
    return _ceilf(
      _X,
    );
  }

  late final _ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('ceilf');
  late final _ceilf = _ceilfPtr.asFunction<double Function(double)>();

  double cosf(
    double _X,
  ) {
    return _cosf(
      _X,
    );
  }

  late final _cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cosf');
  late final _cosf = _cosfPtr.asFunction<double Function(double)>();

  double coshf(
    double _X,
  ) {
    return _coshf(
      _X,
    );
  }

  late final _coshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('coshf');
  late final _coshf = _coshfPtr.asFunction<double Function(double)>();

  double expf(
    double _X,
  ) {
    return _expf(
      _X,
    );
  }

  late final _expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expf');
  late final _expf = _expfPtr.asFunction<double Function(double)>();

  double floorf(
    double _X,
  ) {
    return _floorf(
      _X,
    );
  }

  late final _floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('floorf');
  late final _floorf = _floorfPtr.asFunction<double Function(double)>();

  double fmodf(
    double _X,
    double _Y,
  ) {
    return _fmodf(
      _X,
      _Y,
    );
  }

  late final _fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmodf');
  late final _fmodf = _fmodfPtr.asFunction<double Function(double, double)>();

  double log10f(
    double _X,
  ) {
    return _log10f(
      _X,
    );
  }

  late final _log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log10f');
  late final _log10f = _log10fPtr.asFunction<double Function(double)>();

  double logf(
    double _X,
  ) {
    return _logf(
      _X,
    );
  }

  late final _logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logf');
  late final _logf = _logfPtr.asFunction<double Function(double)>();

  double modff(
    double _X,
    ffi.Pointer<ffi.Float> _Y,
  ) {
    return _modff(
      _X,
      _Y,
    );
  }

  late final _modffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Float>)>>('modff');
  late final _modff =
      _modffPtr.asFunction<double Function(double, ffi.Pointer<ffi.Float>)>();

  double powf(
    double _X,
    double _Y,
  ) {
    return _powf(
      _X,
      _Y,
    );
  }

  late final _powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'powf');
  late final _powf = _powfPtr.asFunction<double Function(double, double)>();

  double sinf(
    double _X,
  ) {
    return _sinf(
      _X,
    );
  }

  late final _sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinf');
  late final _sinf = _sinfPtr.asFunction<double Function(double)>();

  double sinhf(
    double _X,
  ) {
    return _sinhf(
      _X,
    );
  }

  late final _sinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinhf');
  late final _sinhf = _sinhfPtr.asFunction<double Function(double)>();

  double sqrtf(
    double _X,
  ) {
    return _sqrtf(
      _X,
    );
  }

  late final _sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sqrtf');
  late final _sqrtf = _sqrtfPtr.asFunction<double Function(double)>();

  double tanf(
    double _X,
  ) {
    return _tanf(
      _X,
    );
  }

  late final _tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanf');
  late final _tanf = _tanfPtr.asFunction<double Function(double)>();

  double tanhf(
    double _X,
  ) {
    return _tanhf(
      _X,
    );
  }

  late final _tanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanhf');
  late final _tanhf = _tanhfPtr.asFunction<double Function(double)>();

  late final ffi.Pointer<ffi.Double> _HUGE1 = _lookup<ffi.Double>('HUGE');

  double get HUGE => _HUGE1.value;

  set HUGE(double value) => _HUGE1.value = value;

  double j0(
    double _X,
  ) {
    return _j01(
      _X,
    );
  }

  late final _j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j0');
  late final _j01 = _j0Ptr.asFunction<double Function(double)>();

  double j1(
    double _X,
  ) {
    return _j11(
      _X,
    );
  }

  late final _j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j1');
  late final _j11 = _j1Ptr.asFunction<double Function(double)>();

  double jn(
    int _X,
    double _Y,
  ) {
    return _jn1(
      _X,
      _Y,
    );
  }

  late final _jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'jn');
  late final _jn1 = _jnPtr.asFunction<double Function(int, double)>();

  double y0(
    double _X,
  ) {
    return _y01(
      _X,
    );
  }

  late final _y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y0');
  late final _y01 = _y0Ptr.asFunction<double Function(double)>();

  double y1(
    double _X,
  ) {
    return _y11(
      _X,
    );
  }

  late final _y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y1');
  late final _y11 = _y1Ptr.asFunction<double Function(double)>();

  double yn(
    int _X,
    double _Y,
  ) {
    return _yn1(
      _X,
      _Y,
    );
  }

  late final _ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'yn');
  late final _yn1 = _ynPtr.asFunction<double Function(int, double)>();

  ffi.Pointer<ffi.Char> aiTextureTypeToString(
    int in1,
  ) {
    return _aiTextureTypeToString(
      in1,
    );
  }

  late final _aiTextureTypeToStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'aiTextureTypeToString');
  late final _aiTextureTypeToString = _aiTextureTypeToStringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @brief Retrieve a material property with a specific key from the material
  ///
  /// @param pMat Pointer to the input material. May not be NULL
  /// @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
  /// @param type Specifies the type of the texture to be retrieved (
  /// e.g. diffuse, specular, height map ...)
  /// @param index Index of the texture to be retrieved.
  /// @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty
  /// structure or NULL if the key has not been found.
  int aiGetMaterialProperty(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Pointer<aiMaterialProperty>> pPropOut,
  ) {
    return _aiGetMaterialProperty(
      pMat,
      pKey,
      type,
      index,
      pPropOut,
    );
  }

  late final _aiGetMaterialPropertyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<aiMaterial>,
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedInt,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Pointer<aiMaterialProperty>>)>>(
      'aiGetMaterialProperty');
  late final _aiGetMaterialProperty = _aiGetMaterialPropertyPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<aiMaterialProperty>>)>();

  /// @brief Retrieve an array of float values with a specific key
  /// from the material
  ///
  /// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the
  /// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)
  /// @code
  /// aiUVTransform trafo;
  /// unsigned int max = sizeof(aiUVTransform);
  /// if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),
  /// (float*)&trafo, &max) || sizeof(aiUVTransform) != max)
  /// {
  /// // error handling
  /// }
  /// @endcode
  ///
  /// @param pMat Pointer to the input material. May not be NULL
  /// @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
  /// @param pOut Pointer to a buffer to receive the result.
  /// @param pMax Specifies the size of the given buffer, in float's.
  /// Receives the number of values (not bytes!) read.
  /// @param type (see the code sample above)
  /// @param index (see the code sample above)
  /// @return Specifies whether the key has been found. If not, the output
  /// arrays remains unmodified and pMax is set to 0.
  int aiGetMaterialFloatArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ai_real> pOut,
    ffi.Pointer<ffi.UnsignedInt> pMax,
  ) {
    return _aiGetMaterialFloatArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    );
  }

  late final _aiGetMaterialFloatArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ai_real>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialFloatArray');
  late final _aiGetMaterialFloatArray = _aiGetMaterialFloatArrayPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ai_real>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Retrieve an array of integer values with a specific key
  /// from a material
  ///
  /// See the sample for aiGetMaterialFloatArray for more information.
  int aiGetMaterialIntegerArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Int> pOut,
    ffi.Pointer<ffi.UnsignedInt> pMax,
  ) {
    return _aiGetMaterialIntegerArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    );
  }

  late final _aiGetMaterialIntegerArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialIntegerArray');
  late final _aiGetMaterialIntegerArray =
      _aiGetMaterialIntegerArrayPtr.asFunction<
          int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Retrieve a color value from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information
  int aiGetMaterialColor(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiColor4D> pOut,
  ) {
    return _aiGetMaterialColor(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiColor4D>)>>('aiGetMaterialColor');
  late final _aiGetMaterialColor = _aiGetMaterialColorPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<aiColor4D>)>();

  /// @brief Retrieve a aiUVTransform value from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information
  int aiGetMaterialUVTransform(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiUVTransform> pOut,
  ) {
    return _aiGetMaterialUVTransform(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialUVTransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiUVTransform>)>>('aiGetMaterialUVTransform');
  late final _aiGetMaterialUVTransform =
      _aiGetMaterialUVTransformPtr.asFunction<
          int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<aiUVTransform>)>();

  /// @brief Retrieve a string from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information.
  int aiGetMaterialString(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiString> pOut,
  ) {
    return _aiGetMaterialString(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiString>)>>('aiGetMaterialString');
  late final _aiGetMaterialString = _aiGetMaterialStringPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<aiString>)>();

  /// Get the number of textures for a particular texture type.
  /// @param[in] pMat Pointer to the input material. May not be NULL
  /// @param type Texture type to check for
  /// @return Number of textures for this type.
  /// @note A texture can be easily queried using #aiGetMaterialTexture()
  int aiGetMaterialTextureCount(
    ffi.Pointer<aiMaterial> pMat,
    int type,
  ) {
    return _aiGetMaterialTextureCount(
      pMat,
      type,
    );
  }

  late final _aiGetMaterialTextureCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<aiMaterial>,
              ffi.Int32)>>('aiGetMaterialTextureCount');
  late final _aiGetMaterialTextureCount = _aiGetMaterialTextureCountPtr
      .asFunction<int Function(ffi.Pointer<aiMaterial>, int)>();

  int aiGetMaterialTexture(
    ffi.Pointer<aiMaterial> mat,
    int type,
    int index,
    ffi.Pointer<aiString> path,
    ffi.Pointer<ffi.Int32> mapping,
    ffi.Pointer<ffi.UnsignedInt> uvindex,
    ffi.Pointer<ai_real> blend,
    ffi.Pointer<ffi.Int32> op,
    ffi.Pointer<ffi.Int32> mapmode,
    ffi.Pointer<ffi.UnsignedInt> flags,
  ) {
    return _aiGetMaterialTexture(
      mat,
      type,
      index,
      path,
      mapping,
      uvindex,
      blend,
      op,
      mapmode,
      flags,
    );
  }

  late final _aiGetMaterialTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Int32,
              ffi.UnsignedInt,
              ffi.Pointer<aiString>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ai_real>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialTexture');
  late final _aiGetMaterialTexture = _aiGetMaterialTexturePtr.asFunction<
      int Function(
          ffi.Pointer<aiMaterial>,
          int,
          int,
          ffi.Pointer<aiString>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ai_real>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Returns the number of export file formats available in the current Assimp build.
  /// Use aiGetExportFormatDescription() to retrieve infos of a specific export format.
  int aiGetExportFormatCount() {
    return _aiGetExportFormatCount();
  }

  late final _aiGetExportFormatCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'aiGetExportFormatCount');
  late final _aiGetExportFormatCount =
      _aiGetExportFormatCountPtr.asFunction<int Function()>();

  /// Returns a description of the nth export file format. Use #aiGetExportFormatCount()
  /// to learn how many export formats are supported. The description must be released by
  /// calling aiReleaseExportFormatDescription afterwards.
  /// @param pIndex Index of the export format to retrieve information for. Valid range is
  /// 0 to #aiGetExportFormatCount()
  /// @return A description of that specific export format. NULL if pIndex is out of range.
  ffi.Pointer<aiExportFormatDesc> aiGetExportFormatDescription(
    int pIndex,
  ) {
    return _aiGetExportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetExportFormatDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiExportFormatDesc> Function(
              ffi.Size)>>('aiGetExportFormatDescription');
  late final _aiGetExportFormatDescription = _aiGetExportFormatDescriptionPtr
      .asFunction<ffi.Pointer<aiExportFormatDesc> Function(int)>();

  /// Release a description of the nth export file format. Must be returned by
  /// aiGetExportFormatDescription
  /// @param desc Pointer to the description
  void aiReleaseExportFormatDescription(
    ffi.Pointer<aiExportFormatDesc> desc,
  ) {
    return _aiReleaseExportFormatDescription(
      desc,
    );
  }

  late final _aiReleaseExportFormatDescriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<aiExportFormatDesc>)>>(
      'aiReleaseExportFormatDescription');
  late final _aiReleaseExportFormatDescription =
      _aiReleaseExportFormatDescriptionPtr
          .asFunction<void Function(ffi.Pointer<aiExportFormatDesc>)>();

  /// Create a modifiable copy of a scene.
  /// This is useful to import files via Assimp, change their topology and
  /// export them again. Since the scene returned by the various importer functions
  /// is const, a modifiable copy is needed.
  /// @param pIn Valid scene to be copied
  /// @param pOut Receives a modifiable copy of the scene. Use aiFreeScene() to
  /// delete it again.
  void aiCopyScene(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<ffi.Pointer<aiScene>> pOut,
  ) {
    return _aiCopyScene(
      pIn,
      pOut,
    );
  }

  late final _aiCopyScenePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Pointer<aiScene>>)>>('aiCopyScene');
  late final _aiCopyScene = _aiCopyScenePtr.asFunction<
      void Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Pointer<aiScene>>)>();

  /// Frees a scene copy created using aiCopyScene()
  void aiFreeScene(
    ffi.Pointer<aiScene> pIn,
  ) {
    return _aiFreeScene(
      pIn,
    );
  }

  late final _aiFreeScenePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiScene>)>>(
          'aiFreeScene');
  late final _aiFreeScene =
      _aiFreeScenePtr.asFunction<void Function(ffi.Pointer<aiScene>)>();

  /// Exports the given scene to a chosen file format and writes the result file(s) to disk.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// The scene is expected to conform to Assimp's Importer output format as specified
  /// in the @link data Data Structures Page @endlink. In short, this means the model data
  /// should use a right-handed coordinate systems, face winding should be counter-clockwise
  /// and the UV coordinate origin is assumed to be in the upper left. If your input data
  /// uses different conventions, have a look at the last parameter.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated
  /// flags, but in reality only a subset of them makes sense here. Specifying
  /// 'preprocessing' flags is useful if the input scene does not conform to
  /// Assimp's default conventions as specified in the @link data Data Structures Page @endlink.
  /// In short, this means the geometry data should use a right-handed coordinate systems, face
  /// winding should be counter-clockwise and the UV coordinate origin is assumed to be in
  /// the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder flags are used in the import side to allow users
  /// to have those defaults automatically adapted to their conventions. Specifying those flags
  /// for exporting has the opposite effect, respectively. Some other of the
  /// #aiPostProcessSteps enumerated values may be useful as well, but you'll need
  /// to try out what their effect on the exported file is. Many formats impose
  /// their own restrictions on the structure of the geometry stored therein,
  /// so some preprocessing may have little or no effect at all, or may be
  /// redundant as exporters would apply them anyhow. A good example
  /// is triangulation - whilst you can enforce it by specifying
  /// the #aiProcess_Triangulate flag, most export formats support only
  /// triangulate data so they would run the step anyway.
  ///
  /// If assimp detects that the input scene was directly taken from the importer side of
  /// the library (i.e. not copied using aiCopyScene and potentially modified afterwards),
  /// any post-processing steps already applied to the scene will not be applied again, unless
  /// they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder).
  /// @return a status code indicating the result of the export
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  int aiExportScene(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    ffi.Pointer<ffi.Char> pFileName,
    int pPreprocessing,
  ) {
    return _aiExportScene(
      pScene,
      pFormatId,
      pFileName,
      pPreprocessing,
    );
  }

  late final _aiExportScenePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiExportScene');
  late final _aiExportScene = _aiExportScenePtr.asFunction<
      int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Exports the given scene to a chosen file format using custom IO logic supplied by you.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pIO custom IO implementation to be used. Use this if you use your own storage methods.
  /// If none is supplied, a default implementation using standard file IO is used. Note that
  /// #aiExportSceneToBlob is provided as convenience function to export to memory buffers.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return a status code indicating the result of the export
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  int aiExportSceneEx(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    ffi.Pointer<ffi.Char> pFileName,
    ffi.Pointer<aiFileIO> pIO,
    int pPreprocessing,
  ) {
    return _aiExportSceneEx(
      pScene,
      pFormatId,
      pFileName,
      pIO,
      pPreprocessing,
    );
  }

  late final _aiExportSceneExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiFileIO>,
              ffi.UnsignedInt)>>('aiExportSceneEx');
  late final _aiExportSceneEx = _aiExportSceneExPtr.asFunction<
      int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<aiFileIO>, int)>();

  /// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which
  /// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()
  /// to free the resources associated with the export.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return the exported data or NULL in case of error
  ffi.Pointer<aiExportDataBlob> aiExportSceneToBlob(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    int pPreprocessing,
  ) {
    return _aiExportSceneToBlob(
      pScene,
      pFormatId,
      pPreprocessing,
    );
  }

  late final _aiExportSceneToBlobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiExportDataBlob> Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiExportSceneToBlob');
  late final _aiExportSceneToBlob = _aiExportSceneToBlobPtr.asFunction<
      ffi.Pointer<aiExportDataBlob> Function(
          ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>, int)>();

  /// Releases the memory associated with the given exported data. Use this function to free a data blob
  /// returned by aiExportScene().
  /// @param pData the data blob returned by #aiExportSceneToBlob
  void aiReleaseExportBlob(
    ffi.Pointer<aiExportDataBlob> pData,
  ) {
    return _aiReleaseExportBlob(
      pData,
    );
  }

  late final _aiReleaseExportBlobPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiExportDataBlob>)>>(
      'aiReleaseExportBlob');
  late final _aiReleaseExportBlob = _aiReleaseExportBlobPtr
      .asFunction<void Function(ffi.Pointer<aiExportDataBlob>)>();

  /// \brief  Returns the Importer description for a given extension.
  ///
  /// Will return a nullptr if no assigned importer desc. was found for the given extension
  /// \param  extension   [in] The extension to look for
  /// \return A pointer showing to the ImporterDesc, \see aiImporterDesc.
  ffi.Pointer<aiImporterDesc> aiGetImporterDesc(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _aiGetImporterDesc(
      extension1,
    );
  }

  late final _aiGetImporterDescPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiImporterDesc> Function(
              ffi.Pointer<ffi.Char>)>>('aiGetImporterDesc');
  late final _aiGetImporterDesc = _aiGetImporterDescPtr.asFunction<
      ffi.Pointer<aiImporterDesc> Function(ffi.Pointer<ffi.Char>)>();

  /// Reads the given file and returns its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @return Pointer to the imported data or NULL if the import failed.
  ffi.Pointer<aiScene> aiImportFile(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
  ) {
    return _aiImportFile(
      pFile,
      pFlags,
    );
  }

  late final _aiImportFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiImportFile');
  late final _aiImportFile = _aiImportFilePtr
      .asFunction<ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Reads the given file using user-defined I/O functions and returns
  /// its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  ffi.Pointer<aiScene> aiImportFileEx(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
  ) {
    return _aiImportFileEx(
      pFile,
      pFlags,
      pFS,
    );
  }

  late final _aiImportFileExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              ffi.Pointer<aiFileIO>)>>('aiImportFileEx');
  late final _aiImportFileEx = _aiImportFileExPtr.asFunction<
      ffi.Pointer<aiScene> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<aiFileIO>)>();

  /// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.
  ///
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @see aiImportFileEx
  ffi.Pointer<aiScene> aiImportFileExWithProperties(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileExWithProperties(
      pFile,
      pFlags,
      pFS,
      pProps,
    );
  }

  late final _aiImportFileExWithPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<aiFileIO>,
              ffi.Pointer<aiPropertyStore>)>>('aiImportFileExWithProperties');
  late final _aiImportFileExWithProperties =
      _aiImportFileExWithPropertiesPtr.asFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<aiFileIO>, ffi.Pointer<aiPropertyStore>)>();

  /// Reads the given file from a given memory buffer,
  ///
  /// If the call succeeds, the contents of the file are returned as a pointer to an
  /// aiScene object. The returned data is intended to be read-only, the importer keeps
  /// ownership of the data and will destroy it upon destruction. If the import fails,
  /// NULL is returned.
  /// A human-readable error description can be retrieved by calling aiGetErrorString().
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  ffi.Pointer<aiScene> aiImportFileFromMemory(
    ffi.Pointer<ffi.Char> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Char> pHint,
  ) {
    return _aiImportFileFromMemory(
      pBuffer,
      pLength,
      pFlags,
      pHint,
    );
  }

  late final _aiImportFileFromMemoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('aiImportFileFromMemory');
  late final _aiImportFileFromMemory = _aiImportFileFromMemoryPtr.asFunction<
      ffi.Pointer<aiScene> Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>)>();

  /// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.
  ///
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  /// @see aiImportFileFromMemory
  ffi.Pointer<aiScene> aiImportFileFromMemoryWithProperties(
    ffi.Pointer<ffi.Char> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Char> pHint,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileFromMemoryWithProperties(
      pBuffer,
      pLength,
      pFlags,
      pHint,
      pProps,
    );
  }

  late final _aiImportFileFromMemoryWithPropertiesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<aiScene> Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedInt,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<aiPropertyStore>)>>(
      'aiImportFileFromMemoryWithProperties');
  late final _aiImportFileFromMemoryWithProperties =
      _aiImportFileFromMemoryWithPropertiesPtr.asFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<aiPropertyStore>)>();

  /// Apply post-processing to an already-imported scene.
  ///
  /// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the
  /// same flags. However, you can use this separate function to inspect the imported
  /// scene first to fine-tune your post-processing setup.
  /// @param pScene Scene to work on.
  /// @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.
  /// @return A pointer to the post-processed data. Post processing is done in-place,
  /// meaning this is still the same #aiScene which you passed for pScene. However,
  /// _if_ post-processing failed, the scene could now be NULL. That's quite a rare
  /// case, post processing steps are not really designed to 'fail'. To be exact,
  /// the #aiProcess_ValidateDataStructure flag is currently the only post processing step
  /// which can actually cause the scene to be reset to NULL.
  ffi.Pointer<aiScene> aiApplyPostProcessing(
    ffi.Pointer<aiScene> pScene,
    int pFlags,
  ) {
    return _aiApplyPostProcessing(
      pScene,
      pFlags,
    );
  }

  late final _aiApplyPostProcessingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<aiScene>, ffi.UnsignedInt)>>('aiApplyPostProcessing');
  late final _aiApplyPostProcessing = _aiApplyPostProcessingPtr
      .asFunction<ffi.Pointer<aiScene> Function(ffi.Pointer<aiScene>, int)>();

  /// Get one of the predefine log streams. This is the quick'n'easy solution to
  /// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's
  /// overall import performance.
  ///
  /// Usage is rather simple (this will stream the log to a file, named log.txt, and
  /// the stdout stream of the process:
  /// @code
  /// struct aiLogStream c;
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,"log.txt");
  /// aiAttachLogStream(&c);
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
  /// aiAttachLogStream(&c);
  /// @endcode
  ///
  /// @param pStreams One of the #aiDefaultLogStream enumerated values.
  /// @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.
  /// Pass NULL for all other flags.
  /// @return The log stream. callback is set to NULL if something went wrong.
  aiLogStream aiGetPredefinedLogStream(
    int pStreams,
    ffi.Pointer<ffi.Char> file,
  ) {
    return _aiGetPredefinedLogStream(
      pStreams,
      file,
    );
  }

  late final _aiGetPredefinedLogStreamPtr = _lookup<
      ffi.NativeFunction<
          aiLogStream Function(
              ffi.Int32, ffi.Pointer<ffi.Char>)>>('aiGetPredefinedLogStream');
  late final _aiGetPredefinedLogStream = _aiGetPredefinedLogStreamPtr
      .asFunction<aiLogStream Function(int, ffi.Pointer<ffi.Char>)>();

  /// Attach a custom log stream to the libraries' logging system.
  ///
  /// Attaching a log stream can slightly reduce Assimp's overall import
  /// performance. Multiple log-streams can be attached.
  /// @param stream Describes the new log stream.
  /// @note To ensure proper destruction of the logging system, you need to manually
  /// call aiDetachLogStream() on every single log stream you attach.
  /// Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.
  void aiAttachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiAttachLogStream(
      stream,
    );
  }

  late final _aiAttachLogStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiLogStream>)>>(
          'aiAttachLogStream');
  late final _aiAttachLogStream = _aiAttachLogStreamPtr
      .asFunction<void Function(ffi.Pointer<aiLogStream>)>();

  /// Enable verbose logging. Verbose logging includes debug-related stuff and
  /// detailed import statistics. This can have severe impact on import performance
  /// and memory consumption. However, it might be useful to find out why a file
  /// didn't read correctly.
  /// @param d AI_TRUE or AI_FALSE, your decision.
  void aiEnableVerboseLogging(
    int d,
  ) {
    return _aiEnableVerboseLogging(
      d,
    );
  }

  late final _aiEnableVerboseLoggingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(aiBool)>>(
          'aiEnableVerboseLogging');
  late final _aiEnableVerboseLogging =
      _aiEnableVerboseLoggingPtr.asFunction<void Function(int)>();

  /// Detach a custom log stream from the libraries' logging system.
  ///
  /// This is the counterpart of #aiAttachLogStream. If you attached a stream,
  /// don't forget to detach it again.
  /// @param stream The log stream to be detached.
  /// @return AI_SUCCESS if the log stream has been detached successfully.
  /// @see aiDetachAllLogStreams
  int aiDetachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiDetachLogStream(
      stream,
    );
  }

  late final _aiDetachLogStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<aiLogStream>)>>(
          'aiDetachLogStream');
  late final _aiDetachLogStream = _aiDetachLogStreamPtr
      .asFunction<int Function(ffi.Pointer<aiLogStream>)>();

  /// Detach all active log streams from the libraries' logging system.
  /// This ensures that the logging system is terminated properly and all
  /// resources allocated by it are actually freed. If you attached a stream,
  /// don't forget to detach it again.
  /// @see aiAttachLogStream
  /// @see aiDetachLogStream
  void aiDetachAllLogStreams() {
    return _aiDetachAllLogStreams();
  }

  late final _aiDetachAllLogStreamsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aiDetachAllLogStreams');
  late final _aiDetachAllLogStreams =
      _aiDetachAllLogStreamsPtr.asFunction<void Function()>();

  /// Releases all resources associated with the given import process.
  ///
  /// Call this function after you're done with the imported data.
  /// @param pScene The imported data to release. NULL is a valid value.
  void aiReleaseImport(
    ffi.Pointer<aiScene> pScene,
  ) {
    return _aiReleaseImport(
      pScene,
    );
  }

  late final _aiReleaseImportPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiScene>)>>(
          'aiReleaseImport');
  late final _aiReleaseImport =
      _aiReleaseImportPtr.asFunction<void Function(ffi.Pointer<aiScene>)>();

  /// Returns the error text of the last failed import process.
  ///
  /// @return A textual description of the error that occurred at the last
  /// import process. NULL if there was no error. There can't be an error if you
  /// got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.
  ffi.Pointer<ffi.Char> aiGetErrorString() {
    return _aiGetErrorString();
  }

  late final _aiGetErrorStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetErrorString');
  late final _aiGetErrorString =
      _aiGetErrorStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Returns whether a given file extension is supported by ASSIMP
  ///
  /// @param szExtension Extension for which the function queries support for.
  /// Must include a leading dot '.'. Example: ".3ds", ".md3"
  /// @return AI_TRUE if the file extension is supported.
  int aiIsExtensionSupported(
    ffi.Pointer<ffi.Char> szExtension,
  ) {
    return _aiIsExtensionSupported(
      szExtension,
    );
  }

  late final _aiIsExtensionSupportedPtr =
      _lookup<ffi.NativeFunction<aiBool Function(ffi.Pointer<ffi.Char>)>>(
          'aiIsExtensionSupported');
  late final _aiIsExtensionSupported = _aiIsExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a list of all file extensions supported by ASSIMP.
  ///
  /// If a file extension is contained in the list this does, of course, not
  /// mean that ASSIMP is able to load all files with this extension.
  /// @param szOut String to receive the extension list.
  /// Format of the list: "*.3ds;*.obj;*.dae". NULL is not a valid parameter.
  void aiGetExtensionList(
    ffi.Pointer<aiString> szOut,
  ) {
    return _aiGetExtensionList(
      szOut,
    );
  }

  late final _aiGetExtensionListPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiString>)>>(
          'aiGetExtensionList');
  late final _aiGetExtensionList =
      _aiGetExtensionListPtr.asFunction<void Function(ffi.Pointer<aiString>)>();

  /// Get the approximated storage required by an imported asset
  /// @param pIn Input asset.
  /// @param in Data structure to be filled.
  void aiGetMemoryRequirements(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<aiMemoryInfo> in1,
  ) {
    return _aiGetMemoryRequirements(
      pIn,
      in1,
    );
  }

  late final _aiGetMemoryRequirementsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiScene>,
              ffi.Pointer<aiMemoryInfo>)>>('aiGetMemoryRequirements');
  late final _aiGetMemoryRequirements = _aiGetMemoryRequirementsPtr.asFunction<
      void Function(ffi.Pointer<aiScene>, ffi.Pointer<aiMemoryInfo>)>();

  /// Create an empty property store. Property stores are used to collect import
  /// settings.
  /// @return New property store. Property stores need to be manually destroyed using
  /// the #aiReleasePropertyStore API function.
  ffi.Pointer<aiPropertyStore> aiCreatePropertyStore() {
    return _aiCreatePropertyStore();
  }

  late final _aiCreatePropertyStorePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aiPropertyStore> Function()>>(
          'aiCreatePropertyStore');
  late final _aiCreatePropertyStore = _aiCreatePropertyStorePtr
      .asFunction<ffi.Pointer<aiPropertyStore> Function()>();

  /// Delete a property store.
  /// @param p Property store to be deleted.
  void aiReleasePropertyStore(
    ffi.Pointer<aiPropertyStore> p,
  ) {
    return _aiReleasePropertyStore(
      p,
    );
  }

  late final _aiReleasePropertyStorePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiPropertyStore>)>>(
      'aiReleasePropertyStore');
  late final _aiReleasePropertyStore = _aiReleasePropertyStorePtr
      .asFunction<void Function(ffi.Pointer<aiPropertyStore>)>();

  /// Set an integer property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyInteger(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    int value,
  ) {
    return _aiSetImportPropertyInteger(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyIntegerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('aiSetImportPropertyInteger');
  late final _aiSetImportPropertyInteger =
      _aiSetImportPropertyIntegerPtr.asFunction<
          void Function(
              ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>, int)>();

  /// Set a floating-point property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyFloat(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    double value,
  ) {
    return _aiSetImportPropertyFloat(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyFloatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ai_real)>>('aiSetImportPropertyFloat');
  late final _aiSetImportPropertyFloat =
      _aiSetImportPropertyFloatPtr.asFunction<
          void Function(
              ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>, double)>();

  /// Set a string property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param st New value for the property
  void aiSetImportPropertyString(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    ffi.Pointer<aiString> st,
  ) {
    return _aiSetImportPropertyString(
      store,
      szName,
      st,
    );
  }

  late final _aiSetImportPropertyStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiString>)>>('aiSetImportPropertyString');
  late final _aiSetImportPropertyString =
      _aiSetImportPropertyStringPtr.asFunction<
          void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiString>)>();

  /// Set a matrix property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param mat New value for the property
  void aiSetImportPropertyMatrix(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiSetImportPropertyMatrix(
      store,
      szName,
      mat,
    );
  }

  late final _aiSetImportPropertyMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiMatrix4x4>)>>('aiSetImportPropertyMatrix');
  late final _aiSetImportPropertyMatrix =
      _aiSetImportPropertyMatrixPtr.asFunction<
          void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiMatrix4x4>)>();

  /// Construct a quaternion from a 3x3 rotation matrix.
  /// @param quat Receives the output quaternion.
  /// @param mat Matrix to 'quaternionize'.
  /// @see aiQuaternion(const aiMatrix3x3& pRotMatrix)
  void aiCreateQuaternionFromMatrix(
    ffi.Pointer<aiQuaternion> quat,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiCreateQuaternionFromMatrix(
      quat,
      mat,
    );
  }

  late final _aiCreateQuaternionFromMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiMatrix3x3>)>>('aiCreateQuaternionFromMatrix');
  late final _aiCreateQuaternionFromMatrix =
      _aiCreateQuaternionFromMatrixPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiMatrix3x3>)>();

  /// Decompose a transformation matrix into its rotational, translational and
  /// scaling components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the scaling component
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  /// @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;
  void aiDecomposeMatrix(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiDecomposeMatrix(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiDecomposeMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>>('aiDecomposeMatrix');
  late final _aiDecomposeMatrix = _aiDecomposeMatrixPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Transpose a 4x4 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransposeMatrix4(
      mat,
    );
  }

  late final _aiTransposeMatrix4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiTransposeMatrix4');
  late final _aiTransposeMatrix4 = _aiTransposeMatrix4Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Transpose a 3x3 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransposeMatrix3(
      mat,
    );
  }

  late final _aiTransposeMatrix3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiTransposeMatrix3');
  late final _aiTransposeMatrix3 = _aiTransposeMatrix3Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Transform a vector by a 3x3 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix3(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransformVecByMatrix3(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiMatrix3x3>)>>('aiTransformVecByMatrix3');
  late final _aiTransformVecByMatrix3 = _aiTransformVecByMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiMatrix3x3>)>();

  /// Transform a vector by a 4x4 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix4(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransformVecByMatrix4(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiMatrix4x4>)>>('aiTransformVecByMatrix4');
  late final _aiTransformVecByMatrix4 = _aiTransformVecByMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiMatrix4x4>)>();

  /// Multiply two 4x4 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix4(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMultiplyMatrix4(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMultiplyMatrix4');
  late final _aiMultiplyMatrix4 = _aiMultiplyMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Multiply two 3x3 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix3(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix3x3> src,
  ) {
    return _aiMultiplyMatrix3(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMultiplyMatrix3');
  late final _aiMultiplyMatrix3 = _aiMultiplyMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 3x3 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiIdentityMatrix3(
      mat,
    );
  }

  late final _aiIdentityMatrix3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiIdentityMatrix3');
  late final _aiIdentityMatrix3 = _aiIdentityMatrix3Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 4x4 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiIdentityMatrix4(
      mat,
    );
  }

  late final _aiIdentityMatrix4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiIdentityMatrix4');
  late final _aiIdentityMatrix4 = _aiIdentityMatrix4Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Returns the number of import file formats available in the current Assimp build.
  /// Use aiGetImportFormatDescription() to retrieve infos of a specific import format.
  int aiGetImportFormatCount() {
    return _aiGetImportFormatCount();
  }

  late final _aiGetImportFormatCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'aiGetImportFormatCount');
  late final _aiGetImportFormatCount =
      _aiGetImportFormatCountPtr.asFunction<int Function()>();

  /// Returns a description of the nth import file format. Use #aiGetImportFormatCount()
  /// to learn how many import formats are supported.
  /// @param pIndex Index of the import format to retrieve information for. Valid range is
  /// 0 to #aiGetImportFormatCount()
  /// @return A description of that specific import format. NULL if pIndex is out of range.
  ffi.Pointer<aiImporterDesc> aiGetImportFormatDescription(
    int pIndex,
  ) {
    return _aiGetImportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetImportFormatDescriptionPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<aiImporterDesc> Function(ffi.Size)>>(
      'aiGetImportFormatDescription');
  late final _aiGetImportFormatDescription = _aiGetImportFormatDescriptionPtr
      .asFunction<ffi.Pointer<aiImporterDesc> Function(int)>();

  /// Check if 2D vectors are equal.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector2AreEqual(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
  ) {
    return _aiVector2AreEqual(
      a,
      b,
    );
  }

  late final _aiVector2AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2AreEqual');
  late final _aiVector2AreEqual = _aiVector2AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Check if 2D vectors are equal using epsilon.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector2AreEqualEpsilon(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
    double epsilon,
  ) {
    return _aiVector2AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiVector2AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>,
              ffi.Float)>>('aiVector2AreEqualEpsilon');
  late final _aiVector2AreEqualEpsilon =
      _aiVector2AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>, double)>();

  /// Add 2D vectors.
  /// @param dst First addend, receives result.
  /// @param src Vector to be added to 'dst'.
  void aiVector2Add(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> src,
  ) {
    return _aiVector2Add(
      dst,
      src,
    );
  }

  late final _aiVector2AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2Add');
  late final _aiVector2Add = _aiVector2AddPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Subtract 2D vectors.
  /// @param dst Minuend, receives result.
  /// @param src Vector to be subtracted from 'dst'.
  void aiVector2Subtract(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> src,
  ) {
    return _aiVector2Subtract(
      dst,
      src,
    );
  }

  late final _aiVector2SubtractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2Subtract');
  late final _aiVector2Subtract = _aiVector2SubtractPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Multiply a 2D vector by a scalar.
  /// @param dst Vector to be scaled by \p s
  /// @param s Scale factor
  void aiVector2Scale(
    ffi.Pointer<aiVector2D> dst,
    double s,
  ) {
    return _aiVector2Scale(
      dst,
      s,
    );
  }

  late final _aiVector2ScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector2D>, ffi.Float)>>('aiVector2Scale');
  late final _aiVector2Scale = _aiVector2ScalePtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>, double)>();

  /// Multiply each component of a 2D vector with
  /// the components of another vector.
  /// @param dst First vector, receives result
  /// @param other Second vector
  void aiVector2SymMul(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> other,
  ) {
    return _aiVector2SymMul(
      dst,
      other,
    );
  }

  late final _aiVector2SymMulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2SymMul');
  late final _aiVector2SymMul = _aiVector2SymMulPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Divide a 2D vector by a scalar.
  /// @param dst Vector to be divided by \p s
  /// @param s Scalar divisor
  void aiVector2DivideByScalar(
    ffi.Pointer<aiVector2D> dst,
    double s,
  ) {
    return _aiVector2DivideByScalar(
      dst,
      s,
    );
  }

  late final _aiVector2DivideByScalarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector2D>, ffi.Float)>>('aiVector2DivideByScalar');
  late final _aiVector2DivideByScalar = _aiVector2DivideByScalarPtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>, double)>();

  /// Divide each component of a 2D vector by
  /// the components of another vector.
  /// @param dst Vector as the dividend
  /// @param v Vector as the divisor
  void aiVector2DivideByVector(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2DivideByVector(
      dst,
      v,
    );
  }

  late final _aiVector2DivideByVectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2DivideByVector');
  late final _aiVector2DivideByVector = _aiVector2DivideByVectorPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Get the length of a 2D vector.
  /// @return v Vector to evaluate
  double aiVector2Length(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2Length(
      v,
    );
  }

  late final _aiVector2LengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Length');
  late final _aiVector2Length = _aiVector2LengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector2D>)>();

  /// Get the squared length of a 2D vector.
  /// @return v Vector to evaluate
  double aiVector2SquareLength(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2SquareLength(
      v,
    );
  }

  late final _aiVector2SquareLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2SquareLength');
  late final _aiVector2SquareLength = _aiVector2SquareLengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector2D>)>();

  /// Negate a 2D vector.
  /// @param dst Vector to be negated
  void aiVector2Negate(
    ffi.Pointer<aiVector2D> dst,
  ) {
    return _aiVector2Negate(
      dst,
    );
  }

  late final _aiVector2NegatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Negate');
  late final _aiVector2Negate =
      _aiVector2NegatePtr.asFunction<void Function(ffi.Pointer<aiVector2D>)>();

  /// Get the dot product of 2D vectors.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  double aiVector2DotProduct(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
  ) {
    return _aiVector2DotProduct(
      a,
      b,
    );
  }

  late final _aiVector2DotProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2DotProduct');
  late final _aiVector2DotProduct = _aiVector2DotProductPtr.asFunction<
      double Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Normalize a 2D vector.
  /// @param v Vector to normalize
  void aiVector2Normalize(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2Normalize(
      v,
    );
  }

  late final _aiVector2NormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Normalize');
  late final _aiVector2Normalize = _aiVector2NormalizePtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>)>();

  /// Check if 3D vectors are equal.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector3AreEqual(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3AreEqual(
      a,
      b,
    );
  }

  late final _aiVector3AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3AreEqual');
  late final _aiVector3AreEqual = _aiVector3AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Check if 3D vectors are equal using epsilon.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector3AreEqualEpsilon(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
    double epsilon,
  ) {
    return _aiVector3AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiVector3AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiVector3AreEqualEpsilon');
  late final _aiVector3AreEqualEpsilon =
      _aiVector3AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>, double)>();

  /// Check if vector \p a is less than vector \p b.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if \p a is less than \p b
  /// @return 0 if \p a is equal or greater than \p b
  int aiVector3LessThan(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3LessThan(
      a,
      b,
    );
  }

  late final _aiVector3LessThanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3LessThan');
  late final _aiVector3LessThan = _aiVector3LessThanPtr.asFunction<
      int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Add 3D vectors.
  /// @param dst First addend, receives result.
  /// @param src Vector to be added to 'dst'.
  void aiVector3Add(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> src,
  ) {
    return _aiVector3Add(
      dst,
      src,
    );
  }

  late final _aiVector3AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3Add');
  late final _aiVector3Add = _aiVector3AddPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Subtract 3D vectors.
  /// @param dst Minuend, receives result.
  /// @param src Vector to be subtracted from 'dst'.
  void aiVector3Subtract(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> src,
  ) {
    return _aiVector3Subtract(
      dst,
      src,
    );
  }

  late final _aiVector3SubtractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3Subtract');
  late final _aiVector3Subtract = _aiVector3SubtractPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Multiply a 3D vector by a scalar.
  /// @param dst Vector to be scaled by \p s
  /// @param s Scale factor
  void aiVector3Scale(
    ffi.Pointer<aiVector3D> dst,
    double s,
  ) {
    return _aiVector3Scale(
      dst,
      s,
    );
  }

  late final _aiVector3ScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector3D>, ffi.Float)>>('aiVector3Scale');
  late final _aiVector3Scale = _aiVector3ScalePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>, double)>();

  /// Multiply each component of a 3D vector with
  /// the components of another vector.
  /// @param dst First vector, receives result
  /// @param other Second vector
  void aiVector3SymMul(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> other,
  ) {
    return _aiVector3SymMul(
      dst,
      other,
    );
  }

  late final _aiVector3SymMulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3SymMul');
  late final _aiVector3SymMul = _aiVector3SymMulPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Divide a 3D vector by a scalar.
  /// @param dst Vector to be divided by \p s
  /// @param s Scalar divisor
  void aiVector3DivideByScalar(
    ffi.Pointer<aiVector3D> dst,
    double s,
  ) {
    return _aiVector3DivideByScalar(
      dst,
      s,
    );
  }

  late final _aiVector3DivideByScalarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector3D>, ffi.Float)>>('aiVector3DivideByScalar');
  late final _aiVector3DivideByScalar = _aiVector3DivideByScalarPtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>, double)>();

  /// Divide each component of a 3D vector by
  /// the components of another vector.
  /// @param dst Vector as the dividend
  /// @param v Vector as the divisor
  void aiVector3DivideByVector(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3DivideByVector(
      dst,
      v,
    );
  }

  late final _aiVector3DivideByVectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3DivideByVector');
  late final _aiVector3DivideByVector = _aiVector3DivideByVectorPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Get the length of a 3D vector.
  /// @return v Vector to evaluate
  double aiVector3Length(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3Length(
      v,
    );
  }

  late final _aiVector3LengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Length');
  late final _aiVector3Length = _aiVector3LengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector3D>)>();

  /// Get the squared length of a 3D vector.
  /// @return v Vector to evaluate
  double aiVector3SquareLength(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3SquareLength(
      v,
    );
  }

  late final _aiVector3SquareLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3SquareLength');
  late final _aiVector3SquareLength = _aiVector3SquareLengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector3D>)>();

  /// Negate a 3D vector.
  /// @param dst Vector to be negated
  void aiVector3Negate(
    ffi.Pointer<aiVector3D> dst,
  ) {
    return _aiVector3Negate(
      dst,
    );
  }

  late final _aiVector3NegatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Negate');
  late final _aiVector3Negate =
      _aiVector3NegatePtr.asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Get the dot product of 3D vectors.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  double aiVector3DotProduct(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3DotProduct(
      a,
      b,
    );
  }

  late final _aiVector3DotProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3DotProduct');
  late final _aiVector3DotProduct = _aiVector3DotProductPtr.asFunction<
      double Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Get cross product of 3D vectors.
  /// @param dst Vector to receive the result.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  void aiVector3CrossProduct(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3CrossProduct(
      dst,
      a,
      b,
    );
  }

  late final _aiVector3CrossProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3CrossProduct');
  late final _aiVector3CrossProduct = _aiVector3CrossProductPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Normalize a 3D vector.
  /// @param v Vector to normalize
  void aiVector3Normalize(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3Normalize(
      v,
    );
  }

  late final _aiVector3NormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Normalize');
  late final _aiVector3Normalize = _aiVector3NormalizePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Check for division by zero and normalize a 3D vector.
  /// @param v Vector to normalize
  void aiVector3NormalizeSafe(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3NormalizeSafe(
      v,
    );
  }

  late final _aiVector3NormalizeSafePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3NormalizeSafe');
  late final _aiVector3NormalizeSafe = _aiVector3NormalizeSafePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Rotate a 3D vector by a quaternion.
  /// @param v The vector to rotate by \p q
  /// @param q Quaternion to use to rotate \p v
  void aiVector3RotateByQuaternion(
    ffi.Pointer<aiVector3D> v,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiVector3RotateByQuaternion(
      v,
      q,
    );
  }

  late final _aiVector3RotateByQuaternionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>)>>('aiVector3RotateByQuaternion');
  late final _aiVector3RotateByQuaternion =
      _aiVector3RotateByQuaternionPtr.asFunction<
          void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiQuaternion>)>();

  /// Construct a 3x3 matrix from a 4x4 matrix.
  /// @param dst Receives the output matrix
  /// @param mat The 4x4 matrix to use
  void aiMatrix3FromMatrix4(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix3FromMatrix4(
      dst,
      mat,
    );
  }

  late final _aiMatrix3FromMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix3FromMatrix4');
  late final _aiMatrix3FromMatrix4 = _aiMatrix3FromMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix4x4>)>();

  /// Construct a 3x3 matrix from a quaternion.
  /// @param mat Receives the output matrix
  /// @param q The quaternion matrix to use
  void aiMatrix3FromQuaternion(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiMatrix3FromQuaternion(
      mat,
      q,
    );
  }

  late final _aiMatrix3FromQuaternionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiQuaternion>)>>('aiMatrix3FromQuaternion');
  late final _aiMatrix3FromQuaternion = _aiMatrix3FromQuaternionPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiQuaternion>)>();

  /// Check if 3x3 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix3AreEqual(
    ffi.Pointer<aiMatrix3x3> a,
    ffi.Pointer<aiMatrix3x3> b,
  ) {
    return _aiMatrix3AreEqual(
      a,
      b,
    );
  }

  late final _aiMatrix3AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMatrix3AreEqual');
  late final _aiMatrix3AreEqual = _aiMatrix3AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>)>();

  /// Check if 3x3 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @param epsilon Epsilon
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix3AreEqualEpsilon(
    ffi.Pointer<aiMatrix3x3> a,
    ffi.Pointer<aiMatrix3x3> b,
    double epsilon,
  ) {
    return _aiMatrix3AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiMatrix3AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>,
              ffi.Float)>>('aiMatrix3AreEqualEpsilon');
  late final _aiMatrix3AreEqualEpsilon =
      _aiMatrix3AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>, double)>();

  /// Invert a 3x3 matrix.
  /// @param mat Matrix to invert
  void aiMatrix3Inverse(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix3Inverse(
      mat,
    );
  }

  late final _aiMatrix3InversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiMatrix3Inverse');
  late final _aiMatrix3Inverse = _aiMatrix3InversePtr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get the determinant of a 3x3 matrix.
  /// @param mat Matrix to get the determinant from
  double aiMatrix3Determinant(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix3Determinant(
      mat,
    );
  }

  late final _aiMatrix3DeterminantPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiMatrix3Determinant');
  late final _aiMatrix3Determinant = _aiMatrix3DeterminantPtr
      .asFunction<double Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 3x3 rotation matrix around the Z axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix3RotationZ(
    ffi.Pointer<aiMatrix3x3> mat,
    double angle,
  ) {
    return _aiMatrix3RotationZ(
      mat,
      angle,
    );
  }

  late final _aiMatrix3RotationZPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Float)>>('aiMatrix3RotationZ');
  late final _aiMatrix3RotationZ = _aiMatrix3RotationZPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>, double)>();

  /// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
  /// @param mat Receives the output matrix
  /// @param axis Rotation axis, should be a normalized vector
  /// @param angle Rotation angle, in radians
  void aiMatrix3FromRotationAroundAxis(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiMatrix3FromRotationAroundAxis(
      mat,
      axis,
      angle,
    );
  }

  late final _aiMatrix3FromRotationAroundAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiMatrix3FromRotationAroundAxis');
  late final _aiMatrix3FromRotationAroundAxis =
      _aiMatrix3FromRotationAroundAxisPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>, double)>();

  /// Get a 3x3 translation matrix.
  /// @param mat Receives the output matrix
  /// @param translation The translation vector
  void aiMatrix3Translation(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector2D> translation,
  ) {
    return _aiMatrix3Translation(
      mat,
      translation,
    );
  }

  late final _aiMatrix3TranslationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiVector2D>)>>('aiMatrix3Translation');
  late final _aiMatrix3Translation = _aiMatrix3TranslationPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector2D>)>();

  /// Create a 3x3 matrix that rotates one vector to another vector.
  /// @param mat Receives the output matrix
  /// @param from Vector to rotate from
  /// @param to Vector to rotate to
  void aiMatrix3FromTo(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector3D> from,
    ffi.Pointer<aiVector3D> to,
  ) {
    return _aiMatrix3FromTo(
      mat,
      from,
      to,
    );
  }

  late final _aiMatrix3FromToPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix3FromTo');
  late final _aiMatrix3FromTo = _aiMatrix3FromToPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Construct a 4x4 matrix from a 3x3 matrix.
  /// @param dst Receives the output matrix
  /// @param mat The 3x3 matrix to use
  void aiMatrix4FromMatrix3(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix4FromMatrix3(
      dst,
      mat,
    );
  }

  late final _aiMatrix4FromMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMatrix4FromMatrix3');
  late final _aiMatrix4FromMatrix3 = _aiMatrix4FromMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix3x3>)>();

  /// Construct a 4x4 matrix from scaling, rotation and position.
  /// @param mat Receives the output matrix.
  /// @param scaling The scaling for the x,y,z axes
  /// @param rotation The rotation as a hamilton quaternion
  /// @param position The position for the x,y,z axes
  void aiMatrix4FromScalingQuaternionPosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4FromScalingQuaternionPosition(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiMatrix4FromScalingQuaternionPositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiQuaternion>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4FromScalingQuaternionPosition');
  late final _aiMatrix4FromScalingQuaternionPosition =
      _aiMatrix4FromScalingQuaternionPositionPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Add 4x4 matrices.
  /// @param dst First addend, receives result.
  /// @param src Matrix to be added to 'dst'.
  void aiMatrix4Add(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMatrix4Add(
      dst,
      src,
    );
  }

  late final _aiMatrix4AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix4Add');
  late final _aiMatrix4Add = _aiMatrix4AddPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Check if 4x4 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix4AreEqual(
    ffi.Pointer<aiMatrix4x4> a,
    ffi.Pointer<aiMatrix4x4> b,
  ) {
    return _aiMatrix4AreEqual(
      a,
      b,
    );
  }

  late final _aiMatrix4AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix4AreEqual');
  late final _aiMatrix4AreEqual = _aiMatrix4AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Check if 4x4 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @param epsilon Epsilon
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix4AreEqualEpsilon(
    ffi.Pointer<aiMatrix4x4> a,
    ffi.Pointer<aiMatrix4x4> b,
    double epsilon,
  ) {
    return _aiMatrix4AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiMatrix4AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>,
              ffi.Float)>>('aiMatrix4AreEqualEpsilon');
  late final _aiMatrix4AreEqualEpsilon =
      _aiMatrix4AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>, double)>();

  /// Invert a 4x4 matrix.
  /// @param result Matrix to invert
  void aiMatrix4Inverse(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4Inverse(
      mat,
    );
  }

  late final _aiMatrix4InversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4Inverse');
  late final _aiMatrix4Inverse = _aiMatrix4InversePtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Get the determinant of a 4x4 matrix.
  /// @param mat Matrix to get the determinant from
  /// @return The determinant of the matrix
  double aiMatrix4Determinant(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4Determinant(
      mat,
    );
  }

  late final _aiMatrix4DeterminantPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4Determinant');
  late final _aiMatrix4Determinant = _aiMatrix4DeterminantPtr
      .asFunction<double Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Returns true of the matrix is the identity matrix.
  /// @param mat Matrix to get the determinant from
  /// @return 1 if \p mat is an identity matrix.
  /// @return 0 if \p mat is not an identity matrix.
  int aiMatrix4IsIdentity(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4IsIdentity(
      mat,
    );
  }

  late final _aiMatrix4IsIdentityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4IsIdentity');
  late final _aiMatrix4IsIdentity = _aiMatrix4IsIdentityPtr
      .asFunction<int Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Decompose a transformation matrix into its scaling,
  /// rotational as euler angles, and translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the output scaling for the x,y,z axes
  /// @param rotation Receives the output rotation as a Euler angles
  /// @param position Receives the output position for the x,y,z axes
  void aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiVector3D> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiMatrix4DecomposeIntoScalingEulerAnglesPositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4DecomposeIntoScalingEulerAnglesPosition');
  late final _aiMatrix4DecomposeIntoScalingEulerAnglesPosition =
      _aiMatrix4DecomposeIntoScalingEulerAnglesPositionPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Decompose a transformation matrix into its scaling,
  /// rotational split into an axis and rotational angle,
  /// and it's translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param rotation Receives the rotational component
  /// @param axis Receives the output rotation axis
  /// @param angle Receives the output rotation angle
  /// @param position Receives the output position for the x,y,z axes.
  void aiMatrix4DecomposeIntoScalingAxisAnglePosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiVector3D> axis,
    ffi.Pointer<ai_real> angle,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeIntoScalingAxisAnglePosition(
      mat,
      scaling,
      axis,
      angle,
      position,
    );
  }

  late final _aiMatrix4DecomposeIntoScalingAxisAnglePositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<ai_real>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4DecomposeIntoScalingAxisAnglePosition');
  late final _aiMatrix4DecomposeIntoScalingAxisAnglePosition =
      _aiMatrix4DecomposeIntoScalingAxisAnglePositionPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<ai_real>,
              ffi.Pointer<aiVector3D>)>();

  /// Decompose a transformation matrix into its rotational and
  /// translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  void aiMatrix4DecomposeNoScaling(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeNoScaling(
      mat,
      rotation,
      position,
    );
  }

  late final _aiMatrix4DecomposeNoScalingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4DecomposeNoScaling');
  late final _aiMatrix4DecomposeNoScaling =
      _aiMatrix4DecomposeNoScalingPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>();

  /// Creates a 4x4 matrix from a set of euler angles.
  /// @param mat Receives the output matrix
  /// @param x Rotation angle for the x-axis, in radians
  /// @param y Rotation angle for the y-axis, in radians
  /// @param z Rotation angle for the z-axis, in radians
  void aiMatrix4FromEulerAngles(
    ffi.Pointer<aiMatrix4x4> mat,
    double x,
    double y,
    double z,
  ) {
    return _aiMatrix4FromEulerAngles(
      mat,
      x,
      y,
      z,
    );
  }

  late final _aiMatrix4FromEulerAnglesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Float, ffi.Float,
              ffi.Float)>>('aiMatrix4FromEulerAngles');
  late final _aiMatrix4FromEulerAngles =
      _aiMatrix4FromEulerAnglesPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, double, double, double)>();

  /// Get a 4x4 rotation matrix around the X axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationX(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationX(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationXPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationX');
  late final _aiMatrix4RotationX = _aiMatrix4RotationXPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Get a 4x4 rotation matrix around the Y axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationY(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationY(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationYPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationY');
  late final _aiMatrix4RotationY = _aiMatrix4RotationYPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Get a 4x4 rotation matrix around the Z axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationZ(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationZ(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationZPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationZ');
  late final _aiMatrix4RotationZ = _aiMatrix4RotationZPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.
  /// @param mat Receives the output matrix
  /// @param axis Rotation axis, should be a normalized vector
  /// @param angle Rotation angle, in radians
  void aiMatrix4FromRotationAroundAxis(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiMatrix4FromRotationAroundAxis(
      mat,
      axis,
      angle,
    );
  }

  late final _aiMatrix4FromRotationAroundAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiMatrix4FromRotationAroundAxis');
  late final _aiMatrix4FromRotationAroundAxis =
      _aiMatrix4FromRotationAroundAxisPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>, double)>();

  /// Get a 4x4 translation matrix.
  /// @param mat Receives the output matrix
  /// @param translation The translation vector
  void aiMatrix4Translation(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> translation,
  ) {
    return _aiMatrix4Translation(
      mat,
      translation,
    );
  }

  late final _aiMatrix4TranslationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4Translation');
  late final _aiMatrix4Translation = _aiMatrix4TranslationPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>)>();

  /// Get a 4x4 scaling matrix.
  /// @param mat Receives the output matrix
  /// @param scaling The scaling vector
  void aiMatrix4Scaling(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
  ) {
    return _aiMatrix4Scaling(
      mat,
      scaling,
    );
  }

  late final _aiMatrix4ScalingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4Scaling');
  late final _aiMatrix4Scaling = _aiMatrix4ScalingPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>)>();

  /// Create a 4x4 matrix that rotates one vector to another vector.
  /// @param mat Receives the output matrix
  /// @param from Vector to rotate from
  /// @param to Vector to rotate to
  void aiMatrix4FromTo(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> from,
    ffi.Pointer<aiVector3D> to,
  ) {
    return _aiMatrix4FromTo(
      mat,
      from,
      to,
    );
  }

  late final _aiMatrix4FromToPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4FromTo');
  late final _aiMatrix4FromTo = _aiMatrix4FromToPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Create a Quaternion from euler angles.
  /// @param q Receives the output quaternion
  /// @param x Rotation angle for the x-axis, in radians
  /// @param y Rotation angle for the y-axis, in radians
  /// @param z Rotation angle for the z-axis, in radians
  void aiQuaternionFromEulerAngles(
    ffi.Pointer<aiQuaternion> q,
    double x,
    double y,
    double z,
  ) {
    return _aiQuaternionFromEulerAngles(
      q,
      x,
      y,
      z,
    );
  }

  late final _aiQuaternionFromEulerAnglesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>, ffi.Float, ffi.Float,
              ffi.Float)>>('aiQuaternionFromEulerAngles');
  late final _aiQuaternionFromEulerAngles =
      _aiQuaternionFromEulerAnglesPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, double, double, double)>();

  /// Create a Quaternion from an axis angle pair.
  /// @param q Receives the output quaternion
  /// @param axis The orientation axis
  /// @param angle The rotation angle, in radians
  void aiQuaternionFromAxisAngle(
    ffi.Pointer<aiQuaternion> q,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiQuaternionFromAxisAngle(
      q,
      axis,
      angle,
    );
  }

  late final _aiQuaternionFromAxisAnglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiQuaternionFromAxisAngle');
  late final _aiQuaternionFromAxisAngle =
      _aiQuaternionFromAxisAnglePtr.asFunction<
          void Function(
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>, double)>();

  /// Create a Quaternion from a normalized quaternion stored
  /// in a 3D vector.
  /// @param q Receives the output quaternion
  /// @param normalized The vector that stores the quaternion
  void aiQuaternionFromNormalizedQuaternion(
    ffi.Pointer<aiQuaternion> q,
    ffi.Pointer<aiVector3D> normalized,
  ) {
    return _aiQuaternionFromNormalizedQuaternion(
      q,
      normalized,
    );
  }

  late final _aiQuaternionFromNormalizedQuaternionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>>(
      'aiQuaternionFromNormalizedQuaternion');
  late final _aiQuaternionFromNormalizedQuaternion =
      _aiQuaternionFromNormalizedQuaternionPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Check if quaternions are equal.
  /// @param a First quaternion to compare
  /// @param b Second quaternion to compare
  /// @return 1 if the quaternions are equal
  /// @return 0 if the quaternions are not equal
  int aiQuaternionAreEqual(
    ffi.Pointer<aiQuaternion> a,
    ffi.Pointer<aiQuaternion> b,
  ) {
    return _aiQuaternionAreEqual(
      a,
      b,
    );
  }

  late final _aiQuaternionAreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>)>>('aiQuaternionAreEqual');
  late final _aiQuaternionAreEqual = _aiQuaternionAreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>)>();

  /// Check if quaternions are equal using epsilon.
  /// @param a First quaternion to compare
  /// @param b Second quaternion to compare
  /// @param epsilon Epsilon
  /// @return 1 if the quaternions are equal
  /// @return 0 if the quaternions are not equal
  int aiQuaternionAreEqualEpsilon(
    ffi.Pointer<aiQuaternion> a,
    ffi.Pointer<aiQuaternion> b,
    double epsilon,
  ) {
    return _aiQuaternionAreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiQuaternionAreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>,
              ffi.Float)>>('aiQuaternionAreEqualEpsilon');
  late final _aiQuaternionAreEqualEpsilon =
      _aiQuaternionAreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>, double)>();

  /// Normalize a quaternion.
  /// @param q Quaternion to normalize
  void aiQuaternionNormalize(
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionNormalize(
      q,
    );
  }

  late final _aiQuaternionNormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiQuaternion>)>>(
          'aiQuaternionNormalize');
  late final _aiQuaternionNormalize = _aiQuaternionNormalizePtr
      .asFunction<void Function(ffi.Pointer<aiQuaternion>)>();

  /// Compute quaternion conjugate.
  /// @param q Quaternion to compute conjugate,
  /// receives the output quaternion
  void aiQuaternionConjugate(
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionConjugate(
      q,
    );
  }

  late final _aiQuaternionConjugatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiQuaternion>)>>(
          'aiQuaternionConjugate');
  late final _aiQuaternionConjugate = _aiQuaternionConjugatePtr
      .asFunction<void Function(ffi.Pointer<aiQuaternion>)>();

  /// Multiply quaternions.
  /// @param dst First quaternion, receives the output quaternion
  /// @param q Second quaternion
  void aiQuaternionMultiply(
    ffi.Pointer<aiQuaternion> dst,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionMultiply(
      dst,
      q,
    );
  }

  late final _aiQuaternionMultiplyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>)>>('aiQuaternionMultiply');
  late final _aiQuaternionMultiply = _aiQuaternionMultiplyPtr.asFunction<
      void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>)>();

  /// Performs a spherical interpolation between two quaternions.
  /// @param dst Receives the quaternion resulting from the interpolation.
  /// @param start Quaternion when factor == 0
  /// @param end Quaternion when factor == 1
  /// @param factor Interpolation factor between 0 and 1
  void aiQuaternionInterpolate(
    ffi.Pointer<aiQuaternion> dst,
    ffi.Pointer<aiQuaternion> start,
    ffi.Pointer<aiQuaternion> end,
    double factor,
  ) {
    return _aiQuaternionInterpolate(
      dst,
      start,
      end,
      factor,
    );
  }

  late final _aiQuaternionInterpolatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>,
              ffi.Float)>>('aiQuaternionInterpolate');
  late final _aiQuaternionInterpolate = _aiQuaternionInterpolatePtr.asFunction<
      void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>,
          ffi.Pointer<aiQuaternion>, double)>();

  /// @brief Returns a string with legal copyright and licensing information
  /// about Assimp. The string may include multiple lines.
  /// @return Pointer to static string.
  ffi.Pointer<ffi.Char> aiGetLegalString() {
    return _aiGetLegalString();
  }

  late final _aiGetLegalStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetLegalString');
  late final _aiGetLegalString =
      _aiGetLegalStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Returns the current patch version number of Assimp.
  /// @return Patch version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionPatch() {
    return _aiGetVersionPatch();
  }

  late final _aiGetVersionPatchPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionPatch');
  late final _aiGetVersionPatch =
      _aiGetVersionPatchPtr.asFunction<int Function()>();

  /// @brief Returns the current minor version number of Assimp.
  /// @return Minor version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMinor() {
    return _aiGetVersionMinor();
  }

  late final _aiGetVersionMinorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionMinor');
  late final _aiGetVersionMinor =
      _aiGetVersionMinorPtr.asFunction<int Function()>();

  /// @brief Returns the current major version number of Assimp.
  /// @return Major version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMajor() {
    return _aiGetVersionMajor();
  }

  late final _aiGetVersionMajorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionMajor');
  late final _aiGetVersionMajor =
      _aiGetVersionMajorPtr.asFunction<int Function()>();

  /// @brief Returns the repository revision of the Assimp runtime.
  /// @return SVN Repository revision number of the Assimp runtime the
  /// application was linked/built against.
  int aiGetVersionRevision() {
    return _aiGetVersionRevision();
  }

  late final _aiGetVersionRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionRevision');
  late final _aiGetVersionRevision =
      _aiGetVersionRevisionPtr.asFunction<int Function()>();

  /// @brief Returns the branch-name of the Assimp runtime.
  /// @return The current branch name.
  ffi.Pointer<ffi.Char> aiGetBranchName() {
    return _aiGetBranchName();
  }

  late final _aiGetBranchNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetBranchName');
  late final _aiGetBranchName =
      _aiGetBranchNamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Returns assimp's compile flags
  /// @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants.
  int aiGetCompileFlags() {
    return _aiGetCompileFlags();
  }

  late final _aiGetCompileFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetCompileFlags');
  late final _aiGetCompileFlags =
      _aiGetCompileFlagsPtr.asFunction<int Function()>();
}

typedef va_list = ffi.Pointer<ffi.Char>;
typedef uintptr_t = ffi.UnsignedLongLong;

class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

class __crt_locale_data extends ffi.Opaque {}

class __crt_multibyte_data extends ffi.Opaque {}

class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

typedef errno_t = ffi.Int;
typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;
typedef rsize_t = ffi.Size;

/// @brief Enumerates components of the aiScene and aiMesh data structures
/// that can be excluded from the import using the #aiProcess_RemoveComponent step.
///
/// See the documentation to #aiProcess_RemoveComponent for more details.
abstract class aiComponent {
  static const int aiComponent_NORMALS = 2;
  static const int aiComponent_TANGENTS_AND_BITANGENTS = 4;

  /// ALL color sets
  /// Use aiComponent_COLORn(N) to specify the N'th set
  static const int aiComponent_COLORS = 8;

  /// ALL texture UV sets
  /// aiComponent_TEXCOORDn(N) to specify the N'th set
  static const int aiComponent_TEXCOORDS = 16;

  /// Removes all bone weights from all meshes.
  /// The scenegraph nodes corresponding to the bones are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  static const int aiComponent_BONEWEIGHTS = 32;

  /// Removes all node animations (aiScene::mAnimations).
  /// The corresponding scenegraph nodes are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  static const int aiComponent_ANIMATIONS = 64;

  /// Removes all embedded textures (aiScene::mTextures)
  static const int aiComponent_TEXTURES = 128;

  /// Removes all light sources (aiScene::mLights).
  /// The corresponding scenegraph nodes are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  static const int aiComponent_LIGHTS = 256;

  /// Removes all cameras (aiScene::mCameras).
  /// The corresponding scenegraph nodes are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  static const int aiComponent_CAMERAS = 512;

  /// Removes all meshes (aiScene::mMeshes).
  static const int aiComponent_MESHES = 1024;

  /// Removes all materials. One default material will
  /// be generated, so aiScene::mNumMaterials will be 1.
  static const int aiComponent_MATERIALS = 2048;
  static const int _aiComponent_Force32Bit = -1610612737;
}

typedef ai_real = ffi.Float;

class _exception extends ffi.Struct {
  @ffi.Int()
  external int type;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

class _complex extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

class _double_val extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> _Sh;

  @ffi.Double()
  external double _Val;
}

class _float_val extends ffi.Union {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedShort> _Sh;

  @ffi.Float()
  external double _Val;
}

class _ldouble_val extends ffi.Opaque {}

class _float_const extends ffi.Opaque {}

class aiVector2D extends ffi.Struct {
  @ai_real()
  external double x;

  @ai_real()
  external double y;
}

class aiColor4D extends ffi.Struct {
  @ai_real()
  external double r;

  @ai_real()
  external double g;

  @ai_real()
  external double b;

  @ai_real()
  external double a;
}

class aiMatrix3x3 extends ffi.Struct {
  @ai_real()
  external double a1;

  @ai_real()
  external double a2;

  @ai_real()
  external double a3;

  @ai_real()
  external double b1;

  @ai_real()
  external double b2;

  @ai_real()
  external double b3;

  @ai_real()
  external double c1;

  @ai_real()
  external double c2;

  @ai_real()
  external double c3;
}

class aiVector3D extends ffi.Struct {
  @ai_real()
  external double x;

  @ai_real()
  external double y;

  @ai_real()
  external double z;
}

class aiMatrix4x4 extends ffi.Struct {
  @ai_real()
  external double a1;

  @ai_real()
  external double a2;

  @ai_real()
  external double a3;

  @ai_real()
  external double a4;

  @ai_real()
  external double b1;

  @ai_real()
  external double b2;

  @ai_real()
  external double b3;

  @ai_real()
  external double b4;

  @ai_real()
  external double c1;

  @ai_real()
  external double c2;

  @ai_real()
  external double c3;

  @ai_real()
  external double c4;

  @ai_real()
  external double d1;

  @ai_real()
  external double d2;

  @ai_real()
  external double d3;

  @ai_real()
  external double d4;
}

class aiQuaternion extends ffi.Struct {
  @ai_real()
  external double w;

  @ai_real()
  external double x;

  @ai_real()
  external double y;

  @ai_real()
  external double z;
}

/// Represents a plane in a three-dimensional, euclidean space
class aiPlane extends ffi.Struct {
  /// ! Plane equation
  @ai_real()
  external double a;

  @ai_real()
  external double b;

  @ai_real()
  external double c;

  @ai_real()
  external double d;
}

/// Represents a ray
class aiRay extends ffi.Struct {
  /// ! Position and direction of the ray
  external aiVector3D pos;

  external aiVector3D dir;
}

/// Represents a color in Red-Green-Blue space.
class aiColor3D extends ffi.Struct {
  /// ! Red, green and blue color values
  @ai_real()
  external double r;

  @ai_real()
  external double g;

  @ai_real()
  external double b;
}

/// Represents an UTF-8 string, zero byte terminated.
///
/// The character set of an aiString is explicitly defined to be UTF-8. This Unicode
/// transformation was chosen in the belief that most strings in 3d files are limited
/// to ASCII, thus the character set needed to be strictly ASCII compatible.
///
/// Most text file loaders provide proper Unicode input file handling, special unicode
/// characters are correctly transcoded to UTF8 and are kept throughout the libraries'
/// import pipeline.
///
/// For most applications, it will be absolutely sufficient to interpret the
/// aiString as ASCII data and work with it as one would work with a plain char*.
/// Windows users in need of proper support for i.e asian characters can use the
/// MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the
/// UTF-8 strings to their working character set (i.e. MBCS, WideChar).
///
/// We use this representation instead of std::string to be C-compatible. The
/// (binary) length of such a string is limited to MAXLEN characters (including the
/// the terminating zero).
class aiString extends ffi.Struct {
  /// Binary length of the string excluding the terminal 0. This is NOT the
  /// logical length of strings containing UTF-8 multi-byte sequences! It's
  /// the number of bytes from the beginning of the string to its end.
  @ai_uint32()
  external int length;

  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> data;
}

typedef ai_uint32 = ffi.Uint32;

/// Standard return type for some library functions.
/// Rarely used, and if, mostly in the C API.
abstract class aiReturn {
  /// Indicates that a function was successful
  static const int aiReturn_SUCCESS = 0;

  /// Indicates that a function failed
  static const int aiReturn_FAILURE = -1;

  /// Indicates that not enough memory was available
  /// to perform the requested operation
  static const int aiReturn_OUTOFMEMORY = -3;

  /// @cond never
  /// Force 32-bit size enum
  static const int _AI_ENFORCE_ENUM_SIZE = 2147483647;
}

/// Seek origins (for the virtual file system API).
/// Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END.
abstract class aiOrigin {
  /// Beginning of the file
  static const int aiOrigin_SET = 0;

  /// Current position of the file pointer
  static const int aiOrigin_CUR = 1;

  /// End of the file, offsets must be negative
  static const int aiOrigin_END = 2;

  /// @cond never
  /// Force 32-bit size enum
  static const int _AI_ORIGIN_ENFORCE_ENUM_SIZE = 2147483647;
}

/// @brief Enumerates predefined log streaming destinations.
/// Logging to these streams can be enabled with a single call to
/// #LogStream::createDefaultStream.
abstract class aiDefaultLogStream {
  /// Stream the log to a file
  static const int aiDefaultLogStream_FILE = 1;

  /// Stream the log to std::cout
  static const int aiDefaultLogStream_STDOUT = 2;

  /// Stream the log to std::cerr
  static const int aiDefaultLogStream_STDERR = 4;

  /// MSVC only: Stream the log the the debugger
  /// (this relies on OutputDebugString from the Win32 SDK)
  static const int aiDefaultLogStream_DEBUGGER = 8;

  /// @cond never
  /// Force 32-bit size enum
  static const int _AI_DLS_ENFORCE_ENUM_SIZE = 2147483647;
}

/// Stores the memory requirements for different components (e.g. meshes, materials,
/// animations) of an import. All sizes are in bytes.
/// @see Importer::GetMemoryRequirements()
class aiMemoryInfo extends ffi.Struct {
  /// Storage allocated for texture data
  @ffi.UnsignedInt()
  external int textures;

  /// Storage allocated for material data
  @ffi.UnsignedInt()
  external int materials;

  /// Storage allocated for mesh data
  @ffi.UnsignedInt()
  external int meshes;

  /// Storage allocated for node data
  @ffi.UnsignedInt()
  external int nodes;

  /// Storage allocated for animation data
  @ffi.UnsignedInt()
  external int animations;

  /// Storage allocated for camera data
  @ffi.UnsignedInt()
  external int cameras;

  /// Storage allocated for light data
  @ffi.UnsignedInt()
  external int lights;

  /// Total storage allocated for the full import.
  @ffi.UnsignedInt()
  external int total;
}

/// @brief Helper structure to represent a texel in a ARGB8888 format
///
/// Used by aiTexture.
@ffi.Packed(1)
class aiTexel extends ffi.Struct {
  @ffi.UnsignedChar()
  external int b;

  @ffi.UnsignedChar()
  external int g;

  @ffi.UnsignedChar()
  external int r;

  @ffi.UnsignedChar()
  external int a;
}

/// Helper structure to describe an embedded texture
///
/// Normally textures are contained in external files but some file formats embed
/// them directly in the model file. There are two types of embedded textures:
/// 1. Uncompressed textures. The color data is given in an uncompressed format.
/// 2. Compressed textures stored in a file format like png or jpg. The raw file
/// bytes are given so the application must utilize an image decoder (e.g. DevIL) to
/// get access to the actual color data.
///
/// Embedded textures are referenced from materials using strings like "*0", "*1", etc.
/// as the texture paths (a single asterisk character followed by the
/// zero-based index of the texture in the aiScene::mTextures array).
class aiTexture extends ffi.Struct {
  /// Width of the texture, in pixels
  ///
  /// If mHeight is zero the texture is compressed in a format
  /// like JPEG. In this case mWidth specifies the size of the
  /// memory area pcData is pointing to, in bytes.
  @ffi.UnsignedInt()
  external int mWidth;

  /// Height of the texture, in pixels
  ///
  /// If this value is zero, pcData points to an compressed texture
  /// in any format (e.g. JPEG).
  @ffi.UnsignedInt()
  external int mHeight;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Char> achFormatHint;

  /// Data of the texture.
  ///
  /// Points to an array of mWidth * mHeight aiTexel's.
  /// The format of the texture data is always ARGB8888 to
  /// make the implementation for user of the library as easy
  /// as possible. If mHeight = 0 this is a pointer to a memory
  /// buffer of size mWidth containing the compressed texture
  /// data. Good luck, have fun!
  external ffi.Pointer<aiTexel> pcData;

  /// Texture original filename
  ///
  /// Used to get the texture reference
  external aiString mFilename;
}

/// An axis-aligned bounding box.
class aiAABB extends ffi.Struct {
  external aiVector3D mMin;

  external aiVector3D mMax;
}

/// @brief A single face in a mesh, referring to multiple vertices.
///
/// If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3
/// it's called 'polygon' (hey, that's just a definition!).
/// <br>
/// aiMesh::mPrimitiveTypes can be queried to quickly examine which types of
/// primitive are actually present in a mesh. The #aiProcess_SortByPType flag
/// executes a special post-processing algorithm which splits meshes with
/// *different* primitive types mixed up (e.g. lines and triangles) in several
/// 'clean' submeshes. Furthermore there is a configuration option (
/// #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove
/// specific kinds of primitives from the imported scene, completely and forever.
/// In many cases you'll probably want to set this setting to
/// @code
/// aiPrimitiveType_LINE|aiPrimitiveType_POINT
/// @endcode
/// Together with the #aiProcess_Triangulate flag you can then be sure that
/// #aiFace::mNumIndices is always 3.
/// @note Take a look at the @link data Data Structures page @endlink for
/// more information on the layout and winding order of a face.
class aiFace extends ffi.Struct {
  /// ! Number of indices defining this face.
  /// ! The maximum value for this member is #AI_MAX_FACE_INDICES.
  @ffi.UnsignedInt()
  external int mNumIndices;

  /// ! Pointer to the indices array. Size of the array is given in numIndices.
  external ffi.Pointer<ffi.UnsignedInt> mIndices;
}

/// @brief A single influence of a bone on a vertex.
class aiVertexWeight extends ffi.Struct {
  /// ! Index of the vertex which is influenced by the bone.
  @ffi.UnsignedInt()
  external int mVertexId;

  /// ! The strength of the influence in the range (0...1).
  /// ! The influence from all bones at one vertex amounts to 1.
  @ai_real()
  external double mWeight;
}

/// A node in the imported hierarchy.
///
/// Each node has name, a parent node (except for the root node),
/// a transformation relative to its parent and possibly several child nodes.
/// Simple file formats don't support hierarchical structures - for these formats
/// the imported scene does consist of only a single root node without children.
class aiNode extends ffi.Struct {
  /// The name of the node.
  ///
  /// The name might be empty (length of zero) but all nodes which
  /// need to be referenced by either bones or animations are named.
  /// Multiple nodes may have the same name, except for nodes which are referenced
  /// by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
  ///
  /// Cameras and lights reference a specific node by name - if there
  /// are multiple nodes with this name, they are assigned to each of them.
  /// <br>
  /// There are no limitations with regard to the characters contained in
  /// the name string as it is usually taken directly from the source file.
  ///
  /// Implementations should be able to handle tokens such as whitespace, tabs,
  /// line feeds, quotation marks, ampersands etc.
  ///
  /// Sometimes assimp introduces new nodes not present in the source file
  /// into the hierarchy (usually out of necessity because sometimes the
  /// source hierarchy format is simply not compatible). Their names are
  /// surrounded by @verbatim <> @endverbatim e.g.
  /// @verbatim<DummyRootNode> @endverbatim.
  external aiString mName;

  /// The transformation relative to the node's parent.
  external aiMatrix4x4 mTransformation;

  /// Parent node. nullptr if this node is the root node.
  external ffi.Pointer<aiNode> mParent;

  /// The number of child nodes of this node.
  @ffi.UnsignedInt()
  external int mNumChildren;

  /// The child nodes of this node. nullptr if mNumChildren is 0.
  external ffi.Pointer<ffi.Pointer<aiNode>> mChildren;

  /// The number of meshes of this node.
  @ffi.UnsignedInt()
  external int mNumMeshes;

  /// The meshes of this node. Each entry is an index into the
  /// mesh list of the #aiScene.
  external ffi.Pointer<ffi.UnsignedInt> mMeshes;

  /// Metadata associated with this node or nullptr if there is no metadata.
  /// Whether any metadata is generated depends on the source file format. See the
  /// @link importer_notes @endlink page for more information on every source file
  /// format. Importers that don't document any metadata don't write any.
  external ffi.Pointer<aiMetadata> mMetaData;
}

/// Container for holding metadata.
///
/// Metadata is a key-value store using string keys and values.
class aiMetadata extends ffi.Struct {
  /// Length of the mKeys and mValues arrays, respectively
  @ffi.UnsignedInt()
  external int mNumProperties;

  /// Arrays of keys, may not be NULL. Entries in this array may not be NULL as well.
  external ffi.Pointer<aiString> mKeys;

  /// Arrays of values, may not be NULL. Entries in this array may be NULL if the
  /// corresponding property key has no assigned value.
  external ffi.Pointer<aiMetadataEntry> mValues;
}

/// Metadata entry
///
/// The type field uniquely identifies the underlying type of the data field
class aiMetadataEntry extends ffi.Struct {
  @ffi.Int32()
  external int mType;

  external ffi.Pointer<ffi.Void> mData;
}

/// Enum used to distinguish data types
abstract class aiMetadataType {
  static const int AI_BOOL = 0;
  static const int AI_INT32 = 1;
  static const int AI_UINT64 = 2;
  static const int AI_FLOAT = 3;
  static const int AI_DOUBLE = 4;
  static const int AI_AISTRING = 5;
  static const int AI_AIVECTOR3D = 6;
  static const int AI_AIMETADATA = 7;
  static const int AI_META_MAX = 8;
  static const int FORCE_32BIT = 2147483647;
}

/// @brief A single bone of a mesh.
///
/// A bone has a name by which it can be found in the frame hierarchy and by
/// which it can be addressed by animations. In addition it has a number of
/// influences on vertices, and a matrix relating the mesh position to the
/// position of the bone at the time of binding.
class aiBone extends ffi.Struct {
  /// ! The name of the bone.
  external aiString mName;

  /// ! The number of vertices affected by this bone.
  /// ! The maximum value for this member is #AI_MAX_BONE_WEIGHTS.
  @ffi.UnsignedInt()
  external int mNumWeights;

  external ffi.Pointer<aiNode> mArmature;

  external ffi.Pointer<aiNode> mNode;

  /// ! The influence weights of this bone, by vertex index.
  external ffi.Pointer<aiVertexWeight> mWeights;

  /// Matrix that transforms from bone space to mesh space in bind pose.
  ///
  /// This matrix describes the position of the mesh
  /// in the local space of this bone when the skeleton was bound.
  /// Thus it can be used directly to determine a desired vertex position,
  /// given the world-space transform of the bone when animated,
  /// and the position of the vertex in mesh space.
  ///
  /// It is sometimes called an inverse-bind matrix,
  /// or inverse bind pose matrix.
  external aiMatrix4x4 mOffsetMatrix;
}

/// @brief Enumerates the types of geometric primitives supported by Assimp.
///
/// @see aiFace Face data structure
/// @see aiProcess_SortByPType Per-primitive sorting of meshes
/// @see aiProcess_Triangulate Automatic triangulation
/// @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.
abstract class aiPrimitiveType {
  /// A point primitive.
  ///
  /// This is just a single vertex in the virtual world,
  /// #aiFace contains just one index for such a primitive.
  static const int aiPrimitiveType_POINT = 1;

  /// A line primitive.
  ///
  /// This is a line defined through a start and an end position.
  /// #aiFace contains exactly two indices for such a primitive.
  static const int aiPrimitiveType_LINE = 2;

  /// A triangular primitive.
  ///
  /// A triangle consists of three indices.
  static const int aiPrimitiveType_TRIANGLE = 4;

  /// A higher-level polygon with more than 3 edges.
  ///
  /// A triangle is a polygon, but polygon in this context means
  /// "all polygons that are not triangles". The "Triangulate"-Step
  /// is provided for your convenience, it splits all polygons in
  /// triangles (which are much easier to handle).
  static const int aiPrimitiveType_POLYGON = 8;

  /// A flag to determine whether this triangles only mesh is NGON encoded.
  ///
  /// NGON encoding is a special encoding that tells whether 2 or more consecutive triangles
  /// should be considered as a triangle fan. This is identified by looking at the first vertex index.
  /// 2 consecutive triangles with the same 1st vertex index are part of the same
  /// NGON.
  ///
  /// At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as
  /// triangles, as usual after a triangulation pass.
  ///
  /// To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.
  ///
  /// @see aiProcess_Triangulate
  /// @link https://github.com/KhronosGroup/glTF/pull/1620
  static const int aiPrimitiveType_NGONEncodingFlag = 16;
  static const int _aiPrimitiveType_Force32Bit = 2147483647;
}

/// @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex
/// animations for a particular frame.
///
/// You may think of an #aiAnimMesh as a `patch` for the host mesh, which
/// replaces only certain vertex data streams at a particular time.
/// Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
/// The actual relationship between the time line and anim meshes is
/// established by #aiMeshAnim, which references singular mesh attachments
/// by their ID and binds them to a time offset.
class aiAnimMesh extends ffi.Struct {
  /// Anim Mesh name
  external aiString mName;

  /// Replacement for aiMesh::mVertices. If this array is non-nullptr,
  /// it *must* contain mNumVertices entries. The corresponding
  /// array in the host mesh must be non-nullptr as well - animation
  /// meshes may neither add or nor remove vertex components (if
  /// a replacement array is nullptr and the corresponding source
  /// array is not, the source data is taken instead)
  external ffi.Pointer<aiVector3D> mVertices;

  /// Replacement for aiMesh::mNormals.
  external ffi.Pointer<aiVector3D> mNormals;

  /// Replacement for aiMesh::mTangents.
  external ffi.Pointer<aiVector3D> mTangents;

  /// Replacement for aiMesh::mBitangents.
  external ffi.Pointer<aiVector3D> mBitangents;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  /// The number of vertices in the aiAnimMesh, and thus the length of all
  /// the member arrays.
  ///
  /// This has always the same value as the mNumVertices property in the
  /// corresponding aiMesh. It is duplicated here merely to make the length
  /// of the member arrays accessible even if the aiMesh is not known, e.g.
  /// from language bindings.
  @ffi.UnsignedInt()
  external int mNumVertices;

  /// Weight of the AnimMesh.
  @ffi.Float()
  external double mWeight;
}

/// @brief Enumerates the methods of mesh morphing supported by Assimp.
abstract class aiMorphingMethod {
  /// Interpolation between morph targets
  static const int aiMorphingMethod_VERTEX_BLEND = 1;

  /// Normalized morphing between morph targets
  static const int aiMorphingMethod_MORPH_NORMALIZED = 2;

  /// Relative morphing between morph targets
  static const int aiMorphingMethod_MORPH_RELATIVE = 3;
  static const int _aiMorphingMethod_Force32Bit = 2147483647;
}

/// @brief A mesh represents a geometry or model with a single material.
///
/// It usually consists of a number of vertices and a series of primitives/faces
/// referencing the vertices. In addition there might be a series of bones, each
/// of them addressing a number of vertices with a certain weight. Vertex data
/// is presented in channels with each channel containing a single per-vertex
/// information such as a set of texture coordinates or a normal vector.
/// If a data pointer is non-null, the corresponding data stream is present.
/// From C++-programs you can also use the comfort functions Has*() to
/// test for the presence of various data streams.
///
/// A Mesh uses only a single material which is referenced by a material ID.
/// @note The mPositions member is usually not optional. However, vertex positions
/// *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in
/// @code
/// aiScene::mFlags
/// @endcode
class aiMesh extends ffi.Struct {
  /// Bitwise combination of the members of the #aiPrimitiveType enum.
  /// This specifies which types of primitives are present in the mesh.
  /// The "SortByPrimitiveType"-Step can be used to make sure the
  /// output meshes consist of one primitive type each.
  @ffi.UnsignedInt()
  external int mPrimitiveTypes;

  /// The number of vertices in this mesh.
  /// This is also the size of all of the per-vertex data arrays.
  /// The maximum value for this member is #AI_MAX_VERTICES.
  @ffi.UnsignedInt()
  external int mNumVertices;

  /// The number of primitives (triangles, polygons, lines) in this  mesh.
  /// This is also the size of the mFaces array.
  /// The maximum value for this member is #AI_MAX_FACES.
  @ffi.UnsignedInt()
  external int mNumFaces;

  /// Vertex positions.
  /// This array is always present in a mesh. The array is
  /// mNumVertices in size.
  external ffi.Pointer<aiVector3D> mVertices;

  /// Vertex normals.
  /// The array contains normalized vectors, nullptr if not present.
  /// The array is mNumVertices in size. Normals are undefined for
  /// point and line primitives. A mesh consisting of points and
  /// lines only may not have normal vectors. Meshes with mixed
  /// primitive types (i.e. lines and triangles) may have normals,
  /// but the normals for vertices that are only referenced by
  /// point or line primitives are undefined and set to QNaN (WARN:
  /// qNaN compares to inequal to *everything*, even to qNaN itself.
  /// Using code like this to check whether a field is qnan is:
  /// @code
  /// #define IS_QNAN(f) (f != f)
  /// @endcode
  /// still dangerous because even 1.f == 1.f could evaluate to false! (
  /// remember the subtleties of IEEE754 artithmetics). Use stuff like
  /// @c fpclassify instead.
  /// @note Normal vectors computed by Assimp are always unit-length.
  /// However, this needn't apply for normals that have been taken
  /// directly from the model file.
  external ffi.Pointer<aiVector3D> mNormals;

  /// Vertex tangents.
  /// The tangent of a vertex points in the direction of the positive
  /// X texture axis. The array contains normalized vectors, nullptr if
  /// not present. The array is mNumVertices in size. A mesh consisting
  /// of points and lines only may not have normal vectors. Meshes with
  /// mixed primitive types (i.e. lines and triangles) may have
  /// normals, but the normals for vertices that are only referenced by
  /// point or line primitives are undefined and set to qNaN.  See
  /// the #mNormals member for a detailed discussion of qNaNs.
  /// @note If the mesh contains tangents, it automatically also
  /// contains bitangents.
  external ffi.Pointer<aiVector3D> mTangents;

  /// Vertex bitangents.
  /// The bitangent of a vertex points in the direction of the positive
  /// Y texture axis. The array contains normalized vectors, nullptr if not
  /// present. The array is mNumVertices in size.
  /// @note If the mesh contains tangents, it automatically also contains
  /// bitangents.
  external ffi.Pointer<aiVector3D> mBitangents;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> mNumUVComponents;

  /// The faces the mesh is constructed from.
  /// Each face refers to a number of vertices by their indices.
  /// This array is always present in a mesh, its size is given
  /// in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT
  /// is NOT set each face references an unique set of vertices.
  external ffi.Pointer<aiFace> mFaces;

  /// The number of bones this mesh contains.
  /// Can be 0, in which case the mBones array is nullptr.
  @ffi.UnsignedInt()
  external int mNumBones;

  /// The bones of this mesh.
  /// A bone consists of a name by which it can be found in the
  /// frame hierarchy and a set of vertex weights.
  external ffi.Pointer<ffi.Pointer<aiBone>> mBones;

  /// The material used by this mesh.
  /// A mesh uses only a single material. If an imported model uses
  /// multiple materials, the import splits up the mesh. Use this value
  /// as index into the scene's material list.
  @ffi.UnsignedInt()
  external int mMaterialIndex;

  /// Name of the mesh. Meshes can be named, but this is not a
  /// requirement and leaving this field empty is totally fine.
  /// There are mainly three uses for mesh names:
  /// - some formats name nodes and meshes independently.
  /// - importers tend to split meshes up to meet the
  /// one-material-per-mesh requirement. Assigning
  /// the same (dummy) name to each of the result meshes
  /// aids the caller at recovering the original mesh
  /// partitioning.
  /// - Vertex animations refer to meshes by their names.
  external aiString mName;

  /// The number of attachment meshes. Note! Currently only works with Collada loader.
  @ffi.UnsignedInt()
  external int mNumAnimMeshes;

  /// Attachment meshes for this mesh, for vertex-based animation.
  /// Attachment meshes carry replacement data for some of the
  /// mesh'es vertex components (usually positions, normals).
  /// Note! Currently only works with Collada loader.
  external ffi.Pointer<ffi.Pointer<aiAnimMesh>> mAnimMeshes;

  /// Method of morphing when anim-meshes are specified.
  /// @see aiMorphingMethod to learn more about the provided morphing targets.
  @ffi.UnsignedInt()
  external int mMethod;

  /// The bounding box.
  external aiAABB mAABB;

  /// Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS
  external ffi.Pointer<ffi.Pointer<aiString>> mTextureCoordsNames;
}

/// Enumerates all supported types of light sources.
abstract class aiLightSourceType {
  static const int aiLightSource_UNDEFINED = 0;

  /// ! A directional light source has a well-defined direction
  /// ! but is infinitely far away. That's quite a good
  /// ! approximation for sun light.
  static const int aiLightSource_DIRECTIONAL = 1;

  /// ! A point light source has a well-defined position
  /// ! in space but no direction - it emits light in all
  /// ! directions. A normal bulb is a point light.
  static const int aiLightSource_POINT = 2;

  /// ! A spot light source emits light in a specific
  /// ! angle. It has a position and a direction it is pointing to.
  /// ! A good example for a spot light is a light spot in
  /// ! sport arenas.
  static const int aiLightSource_SPOT = 3;

  /// ! The generic light level of the world, including the bounces
  /// ! of all other light sources.
  /// ! Typically, there's at most one ambient light in a scene.
  /// ! This light type doesn't have a valid position, direction, or
  /// ! other properties, just a color.
  static const int aiLightSource_AMBIENT = 4;

  /// ! An area light is a rectangle with predefined size that uniformly
  /// ! emits light from one of its sides. The position is center of the
  /// ! rectangle and direction is its normal vector.
  static const int aiLightSource_AREA = 5;
  static const int _aiLightSource_Force32Bit = 2147483647;
}

/// Helper structure to describe a light source.
///
/// Assimp supports multiple sorts of light sources, including
/// directional, point and spot lights. All of them are defined with just
/// a single structure and distinguished by their parameters.
/// Note - some file formats (such as 3DS, ASE) export a "target point" -
/// the point a spot light is looking at (it can even be animated). Assimp
/// writes the target point as a sub-node of a spot-lights's main node,
/// called "<spotName>.Target". However, this is just additional information
/// then, the transformation tracks of the main node make the
/// spot light already point in the right direction.
class aiLight extends ffi.Struct {
  /// The name of the light source.
  ///
  /// There must be a node in the scene-graph with the same name.
  /// This node specifies the position of the light in the scene
  /// hierarchy and can be animated.
  external aiString mName;

  /// The type of the light source.
  ///
  /// aiLightSource_UNDEFINED is not a valid value for this member.
  @ffi.Int32()
  external int mType;

  /// Position of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The position is undefined for directional lights.
  external aiVector3D mPosition;

  /// Direction of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The direction is undefined for point lights. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mDirection;

  /// Up direction of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The direction is undefined for point lights. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mUp;

  /// Constant light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att0 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationConstant;

  /// Linear light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att1 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationLinear;

  /// Quadratic light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att2 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationQuadratic;

  /// Diffuse color of the light source
  ///
  /// The diffuse light color is multiplied with the diffuse
  /// material color to obtain the final color that contributes
  /// to the diffuse shading term.
  external aiColor3D mColorDiffuse;

  /// Specular color of the light source
  ///
  /// The specular light color is multiplied with the specular
  /// material color to obtain the final color that contributes
  /// to the specular shading term.
  external aiColor3D mColorSpecular;

  /// Ambient color of the light source
  ///
  /// The ambient light color is multiplied with the ambient
  /// material color to obtain the final color that contributes
  /// to the ambient shading term. Most renderers will ignore
  /// this value it, is just a remaining of the fixed-function pipeline
  /// that is still supported by quite many file formats.
  external aiColor3D mColorAmbient;

  /// Inner angle of a spot light's light cone.
  ///
  /// The spot light has maximum influence on objects inside this
  /// angle. The angle is given in radians. It is 2PI for point
  /// lights and undefined for directional lights.
  @ffi.Float()
  external double mAngleInnerCone;

  /// Outer angle of a spot light's light cone.
  ///
  /// The spot light does not affect objects outside this angle.
  /// The angle is given in radians. It is 2PI for point lights and
  /// undefined for directional lights. The outer angle must be
  /// greater than or equal to the inner angle.
  /// It is assumed that the application uses a smooth
  /// interpolation between the inner and the outer cone of the
  /// spot light.
  @ffi.Float()
  external double mAngleOuterCone;

  /// Size of area light source.
  external aiVector2D mSize;
}

/// Helper structure to describe a virtual camera.
///
/// Cameras have a representation in the node graph and can be animated.
/// An important aspect is that the camera itself is also part of the
/// scene-graph. This means, any values such as the look-at vector are not
/// *absolute*, they're <b>relative</b> to the coordinate system defined
/// by the node which corresponds to the camera. This allows for camera
/// animations. For static cameras parameters like the 'look-at' or 'up' vectors
/// are usually specified directly in aiCamera, but beware, they could also
/// be encoded in the node transformation. The following (pseudo)code sample
/// shows how to do it: <br><br>
/// @code
/// // Get the camera matrix for a camera at a specific time
/// // if the node hierarchy for the camera does not contain
/// // at least one animated node this is a static computation
/// get-camera-matrix (node sceneRoot, camera cam) : matrix
/// {
/// node   cnd = find-node-for-camera(cam)
/// matrix cmt = identity()
///
/// // as usual - get the absolute camera transformation for this frame
/// for each node nd in hierarchy from sceneRoot to cnd
/// matrix cur
/// if (is-animated(nd))
/// cur = eval-animation(nd)
/// else cur = nd->mTransformation;
/// cmt = mult-matrices( cmt, cur )
/// end for
///
/// // now multiply with the camera's own local transform
/// cam = mult-matrices (cam, get-camera-matrix(cmt) )
/// }
/// @endcode
///
/// @note some file formats (such as 3DS, ASE) export a "target point" -
/// the point the camera is looking at (it can even be animated). Assimp
/// writes the target point as a subnode of the camera's main node,
/// called "<camName>.Target". However this is just additional information
/// then the transformation tracks of the camera main node make the
/// camera already look in the right direction.
class aiCamera extends ffi.Struct {
  /// The name of the camera.
  ///
  /// There must be a node in the scenegraph with the same name.
  /// This node specifies the position of the camera in the scene
  /// hierarchy and can be animated.
  external aiString mName;

  /// Position of the camera relative to the coordinate space
  /// defined by the corresponding node.
  ///
  /// The default value is 0|0|0.
  external aiVector3D mPosition;

  /// 'Up' - vector of the camera coordinate system relative to
  /// the coordinate space defined by the corresponding node.
  ///
  /// The 'right' vector of the camera coordinate system is
  /// the cross product of  the up and lookAt vectors.
  /// The default value is 0|1|0. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mUp;

  /// 'LookAt' - vector of the camera coordinate system relative to
  /// the coordinate space defined by the corresponding node.
  ///
  /// This is the viewing direction of the user.
  /// The default value is 0|0|1. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mLookAt;

  /// Horizontal field of view angle, in radians.
  ///
  /// The field of view angle is the angle between the center
  /// line of the screen and the left or right border.
  /// The default value is 1/4PI.
  @ffi.Float()
  external double mHorizontalFOV;

  /// Distance of the near clipping plane from the camera.
  ///
  /// The value may not be 0.f (for arithmetic reasons to prevent
  /// a division through zero). The default value is 0.1f.
  @ffi.Float()
  external double mClipPlaneNear;

  /// Distance of the far clipping plane from the camera.
  ///
  /// The far clipping plane must, of course, be further away than the
  /// near clipping plane. The default value is 1000.f. The ratio
  /// between the near and the far plane should not be too
  /// large (between 1000-10000 should be ok) to avoid floating-point
  /// inaccuracies which could lead to z-fighting.
  @ffi.Float()
  external double mClipPlaneFar;

  /// Screen aspect ratio.
  ///
  /// This is the ration between the width and the height of the
  /// screen. Typical values are 4/3, 1/2 or 1/1. This value is
  /// 0 if the aspect ratio is not defined in the source file.
  /// 0 is also the default value.
  @ffi.Float()
  external double mAspect;

  /// Half horizontal orthographic width, in scene units.
  ///
  /// The orthographic width specifies the half width of the
  /// orthographic view box. If non-zero the camera is
  /// orthographic and the mAspect should define to the
  /// ratio between the orthographic width and height
  /// and mHorizontalFOV should be set to 0.
  /// The default value is 0 (not orthographic).
  @ffi.Float()
  external double mOrthographicWidth;
}

/// @brief Defines how the Nth texture of a specific type is combined with
/// the result of all previous layers.
///
/// Example (left: key, right: value): <br>
/// @code
/// DiffColor0     - gray
/// DiffTextureOp0 - aiTextureOpMultiply
/// DiffTexture0   - tex1.png
/// DiffTextureOp0 - aiTextureOpAdd
/// DiffTexture1   - tex2.png
/// @endcode
/// Written as equation, the final diffuse term for a specific pixel would be:
/// @code
/// diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +
/// sampleTex(DiffTexture1,UV0) * diffContrib;
/// @endcode
/// where 'diffContrib' is the intensity of the incoming light for that pixel.
abstract class aiTextureOp {
  /// T = T1 * T2
  static const int aiTextureOp_Multiply = 0;

  /// T = T1 + T2
  static const int aiTextureOp_Add = 1;

  /// T = T1 - T2
  static const int aiTextureOp_Subtract = 2;

  /// T = T1 / T2
  static const int aiTextureOp_Divide = 3;

  /// T = (T1 + T2) - (T1 * T2)
  static const int aiTextureOp_SmoothAdd = 4;

  /// T = T1 + (T2-0.5)
  static const int aiTextureOp_SignedAdd = 5;
  static const int _aiTextureOp_Force32Bit = 2147483647;
}

/// @brief Defines how UV coordinates outside the [0...1] range are handled.
///
/// Commonly referred to as 'wrapping mode'.
abstract class aiTextureMapMode {
  /// A texture coordinate u|v is translated to u%1|v%1
  static const int aiTextureMapMode_Wrap = 0;

  /// Texture coordinates outside [0...1]
  /// are clamped to the nearest valid value.
  static const int aiTextureMapMode_Clamp = 1;

  /// If the texture coordinates for a pixel are outside [0...1]
  /// the texture is not applied to that pixel
  static const int aiTextureMapMode_Decal = 3;

  /// A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and
  /// 1-(u%1)|1-(v%1) otherwise
  static const int aiTextureMapMode_Mirror = 2;
  static const int _aiTextureMapMode_Force32Bit = 2147483647;
}

/// @brief Defines how the mapping coords for a texture are generated.
///
/// Real-time applications typically require full UV coordinates, so the use of
/// the aiProcess_GenUVCoords step is highly recommended. It generates proper
/// UV channels for non-UV mapped objects, as long as an accurate description
/// how the mapping should look like (e.g spherical) is given.
/// See the #AI_MATKEY_MAPPING property for more details.
abstract class aiTextureMapping {
  /// The mapping coordinates are taken from an UV channel.
  ///
  /// #AI_MATKEY_UVWSRC property specifies from which UV channel
  /// the texture coordinates are to be taken from (remember,
  /// meshes can have more than one UV channel).
  static const int aiTextureMapping_UV = 0;

  /// Spherical mapping
  static const int aiTextureMapping_SPHERE = 1;

  /// Cylindrical mapping
  static const int aiTextureMapping_CYLINDER = 2;

  /// Cubic mapping
  static const int aiTextureMapping_BOX = 3;

  /// Planar mapping
  static const int aiTextureMapping_PLANE = 4;

  /// Undefined mapping. Have fun.
  static const int aiTextureMapping_OTHER = 5;
  static const int _aiTextureMapping_Force32Bit = 2147483647;
}

/// @brief Defines the purpose of a texture
///
/// This is a very difficult topic. Different 3D packages support different
/// kinds of textures. For very common texture types, such as bumpmaps, the
/// rendering results depend on implementation details in the rendering
/// pipelines of these applications. Assimp loads all texture references from
/// the model file and tries to determine which of the predefined texture
/// types below is the best choice to match the original use of the texture
/// as closely as possible.<br>
///
/// In content pipelines you'll usually define how textures have to be handled,
/// and the artists working on models have to conform to this specification,
/// regardless which 3D tool they're using.
abstract class aiTextureType {
  /// Dummy value.
  ///
  /// No texture, but the value to be used as 'texture semantic'
  /// (#aiMaterialProperty::mSemantic) for all material properties
  /// *not* related to textures.
  static const int aiTextureType_NONE = 0;

  /// The texture is combined with the result of the diffuse
  /// lighting equation.
  /// OR
  /// PBR Specular/Glossiness
  static const int aiTextureType_DIFFUSE = 1;

  /// The texture is combined with the result of the specular
  /// lighting equation.
  /// OR
  /// PBR Specular/Glossiness
  static const int aiTextureType_SPECULAR = 2;

  /// The texture is combined with the result of the ambient
  /// lighting equation.
  static const int aiTextureType_AMBIENT = 3;

  /// The texture is added to the result of the lighting
  /// calculation. It isn't influenced by incoming light.
  static const int aiTextureType_EMISSIVE = 4;

  /// The texture is a height map.
  ///
  /// By convention, higher gray-scale values stand for
  /// higher elevations from the base height.
  static const int aiTextureType_HEIGHT = 5;

  /// The texture is a (tangent space) normal-map.
  ///
  /// Again, there are several conventions for tangent-space
  /// normal maps. Assimp does (intentionally) not
  /// distinguish here.
  static const int aiTextureType_NORMALS = 6;

  /// The texture defines the glossiness of the material.
  ///
  /// The glossiness is in fact the exponent of the specular
  /// (phong) lighting equation. Usually there is a conversion
  /// function defined to map the linear color values in the
  /// texture to a suitable exponent. Have fun.
  static const int aiTextureType_SHININESS = 7;

  /// The texture defines per-pixel opacity.
  ///
  /// Usually 'white' means opaque and 'black' means
  /// 'transparency'. Or quite the opposite. Have fun.
  static const int aiTextureType_OPACITY = 8;

  /// Displacement texture
  ///
  /// The exact purpose and format is application-dependent.
  /// Higher color values stand for higher vertex displacements.
  static const int aiTextureType_DISPLACEMENT = 9;

  /// Lightmap texture (aka Ambient Occlusion)
  ///
  /// Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
  /// covered by this material property. The texture contains a
  /// scaling value for the final color value of a pixel. Its
  /// intensity is not affected by incoming light.
  static const int aiTextureType_LIGHTMAP = 10;

  /// Reflection texture
  ///
  /// Contains the color of a perfect mirror reflection.
  /// Rarely used, almost never for real-time applications.
  static const int aiTextureType_REFLECTION = 11;

  /// PBR Materials
  /// PBR definitions from maya and other modelling packages now use this standard.
  /// This was originally introduced around 2012.
  /// Support for this is in game engines like Godot, Unreal or Unity3D.
  /// Modelling packages which use this are very common now.
  static const int aiTextureType_BASE_COLOR = 12;
  static const int aiTextureType_NORMAL_CAMERA = 13;
  static const int aiTextureType_EMISSION_COLOR = 14;
  static const int aiTextureType_METALNESS = 15;
  static const int aiTextureType_DIFFUSE_ROUGHNESS = 16;
  static const int aiTextureType_AMBIENT_OCCLUSION = 17;

  /// Sheen
  /// Generally used to simulate textiles that are covered in a layer of microfibers
  /// eg velvet
  /// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen
  static const int aiTextureType_SHEEN = 19;

  /// Clearcoat
  /// Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate
  /// https://autodesk.github.io/standard-surface/#closures/coating
  /// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
  static const int aiTextureType_CLEARCOAT = 20;

  /// Transmission
  /// Simulates transmission through the surface
  /// May include further information such as wall thickness
  static const int aiTextureType_TRANSMISSION = 21;

  /// Unknown texture
  ///
  /// A texture reference that does not match any of the definitions
  /// above is considered to be 'unknown'. It is still imported,
  /// but is excluded from any further post-processing.
  static const int aiTextureType_UNKNOWN = 18;
  static const int _aiTextureType_Force32Bit = 2147483647;
}

/// @brief Defines all shading models supported by the library
///
/// Property: #AI_MATKEY_SHADING_MODEL
///
/// The list of shading modes has been taken from Blender.
/// See Blender documentation for more information. The API does
/// not distinguish between "specular" and "diffuse" shaders (thus the
/// specular term for diffuse shading models like Oren-Nayar remains
/// undefined). <br>
/// Again, this value is just a hint. Assimp tries to select the shader whose
/// most common implementation matches the original rendering results of the
/// 3D modeler which wrote a particular model as closely as possible.
abstract class aiShadingMode {
  /// Flat shading. Shading is done on per-face base,
  /// diffuse only. Also known as 'faceted shading'.
  static const int aiShadingMode_Flat = 1;

  /// Simple Gouraud shading.
  static const int aiShadingMode_Gouraud = 2;

  /// Phong-Shading -
  static const int aiShadingMode_Phong = 3;

  /// Phong-Blinn-Shading
  static const int aiShadingMode_Blinn = 4;

  /// Toon-Shading per pixel
  ///
  /// Also known as 'comic' shader.
  static const int aiShadingMode_Toon = 5;

  /// OrenNayar-Shading per pixel
  ///
  /// Extension to standard Lambertian shading, taking the
  /// roughness of the material into account
  static const int aiShadingMode_OrenNayar = 6;

  /// Minnaert-Shading per pixel
  ///
  /// Extension to standard Lambertian shading, taking the
  /// "darkness" of the material into account
  static const int aiShadingMode_Minnaert = 7;

  /// CookTorrance-Shading per pixel
  ///
  /// Special shader for metallic surfaces.
  static const int aiShadingMode_CookTorrance = 8;

  /// No shading at all. Constant light influence of 1.0.
  /// Also known as "Unlit"
  static const int aiShadingMode_NoShading = 9;
  static const int aiShadingMode_Unlit = 9;

  /// Fresnel shading
  static const int aiShadingMode_Fresnel = 10;

  /// Physically-Based Rendering (PBR) shading using
  /// Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
  /// There are multiple methods under this banner, and model files may provide
  /// data for more than one PBR-BRDF method.
  /// Applications should use the set of provided properties to determine which
  /// of their preferred PBR rendering methods are likely to be available
  /// eg:
  /// - If AI_MATKEY_METALLIC_FACTOR is set, then a Metallic/Roughness is available
  /// - If AI_MATKEY_GLOSSINESS_FACTOR is set, then a Specular/Glossiness is available
  /// Note that some PBR methods allow layering of techniques
  static const int aiShadingMode_PBR_BRDF = 11;
  static const int _aiShadingMode_Force32Bit = 2147483647;
}

/// @brief Defines some mixed flags for a particular texture.
///
/// Usually you'll instruct your cg artists how textures have to look like ...
/// and how they will be processed in your application. However, if you use
/// Assimp for completely generic loading purposes you might also need to
/// process these flags in order to display as many 'unknown' 3D models as
/// possible correctly.
///
/// This corresponds to the #AI_MATKEY_TEXFLAGS property.
abstract class aiTextureFlags {
  /// The texture's color values have to be inverted (component-wise 1-n)
  static const int aiTextureFlags_Invert = 1;

  /// Explicit request to the application to process the alpha channel
  /// of the texture.
  ///
  /// Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These
  /// flags are set if the library can say for sure that the alpha
  /// channel is used/is not used. If the model format does not
  /// define this, it is left to the application to decide whether
  /// the texture alpha channel - if any - is evaluated or not.
  static const int aiTextureFlags_UseAlpha = 2;

  /// Explicit request to the application to ignore the alpha channel
  /// of the texture.
  ///
  /// Mutually exclusive with #aiTextureFlags_UseAlpha.
  static const int aiTextureFlags_IgnoreAlpha = 4;
  static const int _aiTextureFlags_Force32Bit = 2147483647;
}

/// @brief Defines alpha-blend flags.
///
/// If you're familiar with OpenGL or D3D, these flags aren't new to you.
/// They define *how* the final color value of a pixel is computed, basing
/// on the previous color at that pixel and the new color value from the
/// material.
/// The blend formula is:
/// @code
/// SourceColor * SourceBlend + DestColor * DestBlend
/// @endcode
/// where DestColor is the previous color in the frame-buffer at this
/// position and SourceColor is the material color before the transparency
/// calculation.<br>
/// This corresponds to the #AI_MATKEY_BLEND_FUNC property.
abstract class aiBlendMode {
  /// Formula:
  /// @code
  /// SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)
  /// @endcode
  static const int aiBlendMode_Default = 0;

  /// Additive blending
  ///
  /// Formula:
  /// @code
  /// SourceColor*1 + DestColor*1
  /// @endcode
  static const int aiBlendMode_Additive = 1;
  static const int _aiBlendMode_Force32Bit = 2147483647;
}

/// @brief Defines how an UV channel is transformed.
///
/// This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.
/// See its documentation for more details.
///
/// Typically you'll want to build a matrix of this information. However,
/// we keep separate scaling/translation/rotation values to make it
/// easier to process and optimize UV transformations internally.
class aiUVTransform extends ffi.Struct {
  /// Translation on the u and v axes.
  ///
  /// The default value is (0|0).
  external aiVector2D mTranslation;

  /// Scaling on the u and v axes.
  ///
  /// The default value is (1|1).
  external aiVector2D mScaling;

  /// Rotation - in counter-clockwise direction.
  ///
  /// The rotation angle is specified in radians. The
  /// rotation center is 0.5f|0.5f. The default value
  /// 0.f.
  @ai_real()
  external double mRotation;
}

/// @brief A very primitive RTTI system for the contents of material
/// properties.
abstract class aiPropertyTypeInfo {
  /// Array of single-precision (32 Bit) floats
  ///
  /// It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in floating-point format.
  /// The material system performs the type conversion automatically.
  static const int aiPTI_Float = 1;

  /// Array of double-precision (64 Bit) floats
  ///
  /// It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in floating-point format.
  /// The material system performs the type conversion automatically.
  static const int aiPTI_Double = 2;

  /// The material property is an aiString.
  ///
  /// Arrays of strings aren't possible, aiGetMaterialString() (or the
  /// C++-API aiMaterial::Get()) *must* be used to query a string property.
  static const int aiPTI_String = 3;

  /// Array of (32 Bit) integers
  ///
  /// It is possible to use aiGetMaterialFloat[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in integer format.
  /// The material system performs the type conversion automatically.
  static const int aiPTI_Integer = 4;

  /// Simple binary buffer, content undefined. Not convertible to anything.
  static const int aiPTI_Buffer = 5;
  static const int _aiPTI_Force32Bit = 2147483647;
}

/// @brief Data structure for a single material property
///
/// As an user, you'll probably never need to deal with this data structure.
/// Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family
/// of functions to query material properties easily. Processing them
/// manually is faster, but it is not the recommended way. It isn't worth
/// the effort. <br>
/// Material property names follow a simple scheme:
/// @code
/// $<name>
/// ?<name>
/// A public property, there must be corresponding AI_MATKEY_XXX define
/// 2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials
/// post-processing step.
/// ~<name>
/// A temporary property for internal use.
/// @endcode
/// @see aiMaterial
class aiMaterialProperty extends ffi.Struct {
  /// Specifies the name of the property (key)
  /// Keys are generally case insensitive.
  external aiString mKey;

  /// Textures: Specifies their exact usage semantic.
  /// For non-texture properties, this member is always 0
  /// (or, better-said, #aiTextureType_NONE).
  @ffi.UnsignedInt()
  external int mSemantic;

  /// Textures: Specifies the index of the texture.
  /// For non-texture properties, this member is always 0.
  @ffi.UnsignedInt()
  external int mIndex;

  /// Size of the buffer mData is pointing to, in bytes.
  /// This value may not be 0.
  @ffi.UnsignedInt()
  external int mDataLength;

  /// Type information for the property.
  ///
  /// Defines the data layout inside the data buffer. This is used
  /// by the library internally to perform debug checks and to
  /// utilize proper type conversions.
  /// (It's probably a hacky solution, but it works.)
  @ffi.Int32()
  external int mType;

  /// Binary buffer to hold the property's value.
  /// The size of the buffer is always mDataLength.
  external ffi.Pointer<ffi.Char> mData;
}

class aiMaterial extends ffi.Struct {
  /// List of all material properties loaded.
  external ffi.Pointer<ffi.Pointer<aiMaterialProperty>> mProperties;

  /// Number of properties in the data base
  @ffi.UnsignedInt()
  external int mNumProperties;

  /// Storage allocated
  @ffi.UnsignedInt()
  external int mNumAllocated;
}

/// A time-value pair specifying a certain 3D vector for the given time.
class aiVectorKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The value of this key
  external aiVector3D mValue;
}

/// A time-value pair specifying a rotation for the given time.
/// Rotations are expressed with quaternions.
class aiQuatKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The value of this key
  external aiQuaternion mValue;
}

/// Binds a anim-mesh to a specific point in time.
class aiMeshKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// Index into the aiMesh::mAnimMeshes array of the
  /// mesh corresponding to the #aiMeshAnim hosting this
  /// key frame. The referenced anim mesh is evaluated
  /// according to the rules defined in the docs for #aiAnimMesh.
  @ffi.UnsignedInt()
  external int mValue;
}

/// Binds a morph anim mesh to a specific point in time.
class aiMeshMorphKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The values and weights at the time of this key
  external ffi.Pointer<ffi.UnsignedInt> mValues;

  external ffi.Pointer<ffi.Double> mWeights;

  /// The number of values and weights
  @ffi.UnsignedInt()
  external int mNumValuesAndWeights;
}

/// Defines how an animation channel behaves outside the defined time
/// range. This corresponds to aiNodeAnim::mPreState and
/// aiNodeAnim::mPostState.
abstract class aiAnimBehaviour {
  /// The value from the default node transformation is taken
  static const int aiAnimBehaviour_DEFAULT = 0;

  /// The nearest key value is used without interpolation
  static const int aiAnimBehaviour_CONSTANT = 1;

  /// The value of the nearest two keys is linearly
  /// extrapolated for the current time value.
  static const int aiAnimBehaviour_LINEAR = 2;

  /// The animation is repeated.
  ///
  /// If the animation key go from n to m and the current
  /// time is t, use the value at (t-n) % (|m-n|).
  static const int aiAnimBehaviour_REPEAT = 3;
  static const int _aiAnimBehaviour_Force32Bit = 2147483647;
}

/// Describes the animation of a single node. The name specifies the
/// bone/node which is affected by this animation channel. The keyframes
/// are given in three separate series of values, one each for position,
/// rotation and scaling. The transformation matrix computed from these
/// values replaces the node's original transformation matrix at a
/// specific time.
/// This means all keys are absolute and not relative to the bone default pose.
/// The order in which the transformations are applied is
/// - as usual - scaling, rotation, translation.
///
/// @note All keys are returned in their correct, chronological order.
/// Duplicate keys don't pass the validation step. Most likely there
/// will be no negative time values, but they are not forbidden also ( so
/// implementations need to cope with them! )
class aiNodeAnim extends ffi.Struct {
  /// The name of the node affected by this animation. The node
  /// must exist and it must be unique.
  external aiString mNodeName;

  /// The number of position keys
  @ffi.UnsignedInt()
  external int mNumPositionKeys;

  /// The position keys of this animation channel. Positions are
  /// specified as 3D vector. The array is mNumPositionKeys in size.
  ///
  /// If there are position keys, there will also be at least one
  /// scaling and one rotation key.
  external ffi.Pointer<aiVectorKey> mPositionKeys;

  /// The number of rotation keys
  @ffi.UnsignedInt()
  external int mNumRotationKeys;

  /// The rotation keys of this animation channel. Rotations are
  /// given as quaternions,  which are 4D vectors. The array is
  /// mNumRotationKeys in size.
  ///
  /// If there are rotation keys, there will also be at least one
  /// scaling and one position key.
  external ffi.Pointer<aiQuatKey> mRotationKeys;

  /// The number of scaling keys
  @ffi.UnsignedInt()
  external int mNumScalingKeys;

  /// The scaling keys of this animation channel. Scalings are
  /// specified as 3D vector. The array is mNumScalingKeys in size.
  ///
  /// If there are scaling keys, there will also be at least one
  /// position and one rotation key.
  external ffi.Pointer<aiVectorKey> mScalingKeys;

  /// Defines how the animation behaves before the first
  /// key is encountered.
  ///
  /// The default value is aiAnimBehaviour_DEFAULT (the original
  /// transformation matrix of the affected node is used).
  @ffi.Int32()
  external int mPreState;

  /// Defines how the animation behaves after the last
  /// key was processed.
  ///
  /// The default value is aiAnimBehaviour_DEFAULT (the original
  /// transformation matrix of the affected node is taken).
  @ffi.Int32()
  external int mPostState;
}

/// Describes vertex-based animations for a single mesh or a group of
/// meshes. Meshes carry the animation data for each frame in their
/// aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to
/// define keyframes linking each mesh attachment to a particular
/// point in time.
class aiMeshAnim extends ffi.Struct {
  /// Name of the mesh to be animated. An empty string is not allowed,
  /// animated meshes need to be named (not necessarily uniquely,
  /// the name can basically serve as wild-card to select a group
  /// of meshes with similar animation setup)
  external aiString mName;

  /// Size of the #mKeys array. Must be 1, at least.
  @ffi.UnsignedInt()
  external int mNumKeys;

  /// Key frames of the animation. May not be nullptr.
  external ffi.Pointer<aiMeshKey> mKeys;
}

/// Describes a morphing animation of a given mesh.
class aiMeshMorphAnim extends ffi.Struct {
  /// Name of the mesh to be animated. An empty string is not allowed,
  /// animated meshes need to be named (not necessarily uniquely,
  /// the name can basically serve as wildcard to select a group
  /// of meshes with similar animation setup)
  external aiString mName;

  /// Size of the #mKeys array. Must be 1, at least.
  @ffi.UnsignedInt()
  external int mNumKeys;

  /// Key frames of the animation. May not be nullptr.
  external ffi.Pointer<aiMeshMorphKey> mKeys;
}

/// An animation consists of key-frame data for a number of nodes. For
/// each node affected by the animation a separate series of data is given.
class aiAnimation extends ffi.Struct {
  /// The name of the animation. If the modeling package this data was
  /// exported from does support only a single animation channel, this
  /// name is usually empty (length is zero).
  external aiString mName;

  /// Duration of the animation in ticks.
  @ffi.Double()
  external double mDuration;

  /// Ticks per second. 0 if not specified in the imported file
  @ffi.Double()
  external double mTicksPerSecond;

  /// The number of bone animation channels. Each channel affects
  /// a single node.
  @ffi.UnsignedInt()
  external int mNumChannels;

  /// The node animation channels. Each channel affects a single node.
  /// The array is mNumChannels in size.
  external ffi.Pointer<ffi.Pointer<aiNodeAnim>> mChannels;

  /// The number of mesh animation channels. Each channel affects
  /// a single mesh and defines vertex-based animation.
  @ffi.UnsignedInt()
  external int mNumMeshChannels;

  /// The mesh animation channels. Each channel affects a single mesh.
  /// The array is mNumMeshChannels in size.
  external ffi.Pointer<ffi.Pointer<aiMeshAnim>> mMeshChannels;

  /// The number of mesh animation channels. Each channel affects
  /// a single mesh and defines morphing animation.
  @ffi.UnsignedInt()
  external int mNumMorphMeshChannels;

  /// The morph mesh animation channels. Each channel affects a single mesh.
  /// The array is mNumMorphMeshChannels in size.
  external ffi.Pointer<ffi.Pointer<aiMeshMorphAnim>> mMorphMeshChannels;
}

/// The root structure of the imported data.
///
/// Everything that was imported from the given file can be accessed from here.
/// Objects of this class are generally maintained and owned by Assimp, not
/// by the caller. You shouldn't want to instance it, nor should you ever try to
/// delete a given scene on your own.
class aiScene extends ffi.Struct {
  /// Any combination of the AI_SCENE_FLAGS_XXX flags. By default
  /// this value is 0, no flags are set. Most applications will
  /// want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE
  /// bit set.
  @ffi.UnsignedInt()
  external int mFlags;

  /// The root node of the hierarchy.
  ///
  /// There will always be at least the root node if the import
  /// was successful (and no special flags have been set).
  /// Presence of further nodes depends on the format and content
  /// of the imported file.
  external ffi.Pointer<aiNode> mRootNode;

  /// The number of meshes in the scene.
  @ffi.UnsignedInt()
  external int mNumMeshes;

  /// The array of meshes.
  ///
  /// Use the indices given in the aiNode structure to access
  /// this array. The array is mNumMeshes in size. If the
  /// AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
  /// be at least ONE material.
  external ffi.Pointer<ffi.Pointer<aiMesh>> mMeshes;

  /// The number of materials in the scene.
  @ffi.UnsignedInt()
  external int mNumMaterials;

  /// The array of materials.
  ///
  /// Use the index given in each aiMesh structure to access this
  /// array. The array is mNumMaterials in size. If the
  /// AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
  /// be at least ONE material.
  external ffi.Pointer<ffi.Pointer<aiMaterial>> mMaterials;

  /// The number of animations in the scene.
  @ffi.UnsignedInt()
  external int mNumAnimations;

  /// The array of animations.
  ///
  /// All animations imported from the given file are listed here.
  /// The array is mNumAnimations in size.
  external ffi.Pointer<ffi.Pointer<aiAnimation>> mAnimations;

  /// The number of textures embedded into the file
  @ffi.UnsignedInt()
  external int mNumTextures;

  /// The array of embedded textures.
  ///
  /// Not many file formats embed their textures into the file.
  /// An example is Quake's MDL format (which is also used by
  /// some GameStudio versions)
  external ffi.Pointer<ffi.Pointer<aiTexture>> mTextures;

  /// The number of light sources in the scene. Light sources
  /// are fully optional, in most cases this attribute will be 0
  @ffi.UnsignedInt()
  external int mNumLights;

  /// The array of light sources.
  ///
  /// All light sources imported from the given file are
  /// listed here. The array is mNumLights in size.
  external ffi.Pointer<ffi.Pointer<aiLight>> mLights;

  /// The number of cameras in the scene. Cameras
  /// are fully optional, in most cases this attribute will be 0
  @ffi.UnsignedInt()
  external int mNumCameras;

  /// The array of cameras.
  ///
  /// All cameras imported from the given file are listed here.
  /// The array is mNumCameras in size. The first camera in the
  /// array (if existing) is the default camera view into
  /// the scene.
  external ffi.Pointer<ffi.Pointer<aiCamera>> mCameras;

  /// @brief  The global metadata assigned to the scene itself.
  ///
  /// This data contains global metadata which belongs to the scene like
  /// unit-conversions, versions, vendors or other model-specific data. This
  /// can be used to store format-specific metadata as well.
  external ffi.Pointer<aiMetadata> mMetaData;

  /// The name of the scene itself.
  external aiString mName;

  external ffi.Pointer<ffi.Char> mPrivate;
}

/// @brief C-API: File system callbacks
///
/// Provided are functions to open and close files. Supply a custom structure to
/// the import function. If you don't, a default implementation is used. Use custom
/// file systems to enable reading from other sources, such as ZIPs
/// or memory locations.
class aiFileIO extends ffi.Struct {
  /// Function used to open a new file
  external aiFileOpenProc OpenProc;

  /// Function used to close an existing file
  external aiFileCloseProc CloseProc;

  /// User-defined, opaque data
  external aiUserData UserData;
}

typedef aiFileOpenProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<aiFile> Function(ffi.Pointer<aiFileIO>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>;

/// @brief C-API: File callbacks
///
/// Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)
/// replacement functions.
///
/// The default implementation of the functions utilizes the fXXX functions from
/// the CRT. However, you can supply a custom implementation to Assimp by
/// delivering a custom aiFileIO. Use this to enable reading from other sources,
/// such as ZIP archives or memory locations.
class aiFile extends ffi.Struct {
  /// Callback to read from a file
  external aiFileReadProc ReadProc;

  /// Callback to write to a file
  external aiFileWriteProc WriteProc;

  /// Callback to retrieve the current position of
  /// the file cursor (ftell())
  external aiFileTellProc TellProc;

  /// Callback to retrieve the size of the file,
  /// in bytes
  external aiFileTellProc FileSizeProc;

  /// Callback to set the current position
  /// of the file cursor (fseek())
  external aiFileSeek SeekProc;

  /// Callback to flush the file contents
  external aiFileFlushProc FlushProc;

  /// User-defined, opaque data
  external aiUserData UserData;
}

typedef aiFileReadProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Size Function(
            ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size)>>;
typedef aiFileWriteProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Size Function(
            ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size)>>;
typedef aiFileTellProc
    = ffi.Pointer<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<aiFile>)>>;
typedef aiFileSeek = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<aiFile>, ffi.Size, ffi.Int32)>>;
typedef aiFileFlushProc
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiFile>)>>;
typedef aiUserData = ffi.Pointer<ffi.Char>;
typedef aiFileCloseProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<aiFileIO>, ffi.Pointer<aiFile>)>>;

/// @brief  Describes an file format which Assimp can export to.
///
/// Use #aiGetExportFormatCount() to learn how many export-formats are supported by
/// the current Assimp-build and #aiGetExportFormatDescription() to retrieve the
/// description of the export format option.
class aiExportFormatDesc extends ffi.Struct {
  /// a short string ID to uniquely identify the export format. Use this ID string to
  /// specify which file format you want to export to when calling #aiExportScene().
  /// Example: "dae" or "obj"
  external ffi.Pointer<ffi.Char> id;

  /// A short description of the file format to present to users. Useful if you want
  /// to allow the user to select an export format.
  external ffi.Pointer<ffi.Char> description;

  /// Recommended file extension for the exported file in lower case.
  external ffi.Pointer<ffi.Char> fileExtension;
}

/// Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an
/// exported scene. The memory referred by this structure is owned by Assimp.
/// to free its resources. Don't try to free the memory on your side - it will crash for most build configurations
/// due to conflicting heaps.
///
/// Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.
/// This is used when exporters write more than one output file for a given #aiScene. See the remarks for
/// #aiExportDataBlob::name for more information.
class aiExportDataBlob extends ffi.Struct {
  /// Size of the data in bytes
  @ffi.Size()
  external int size;

  /// The data.
  external ffi.Pointer<ffi.Void> data;

  /// Name of the blob. An empty string always
  /// indicates the first (and primary) blob,
  /// which contains the actual file data.
  /// Any other blobs are auxiliary files produced
  /// by exporters (i.e. material files). Existence
  /// of such files depends on the file format. Most
  /// formats don't split assets across multiple files.
  ///
  /// If used, blob names usually contain the file
  /// extension that should be used when writing
  /// the data to disc.
  ///
  /// The blob names generated can be influenced by
  /// setting the #AI_CONFIG_EXPORT_BLOB_NAME export
  /// property to the name that is used for the master
  /// blob. All other names are typically derived from
  /// the base name, by the file format exporter.
  external aiString name;

  /// Pointer to the next blob in the chain or NULL if there is none.
  external ffi.Pointer<aiExportDataBlob> next;
}

/// Mixed set of flags for #aiImporterDesc, indicating some features
/// common to many importers
abstract class aiImporterFlags {
  /// Indicates that there is a textual encoding of the
  /// file format; and that it is supported.
  static const int aiImporterFlags_SupportTextFlavour = 1;

  /// Indicates that there is a binary encoding of the
  /// file format; and that it is supported.
  static const int aiImporterFlags_SupportBinaryFlavour = 2;

  /// Indicates that there is a compressed encoding of the
  /// file format; and that it is supported.
  static const int aiImporterFlags_SupportCompressedFlavour = 4;

  /// Indicates that the importer reads only a very particular
  /// subset of the file format. This happens commonly for
  /// declarative or procedural formats which cannot easily
  /// be mapped to #aiScene
  static const int aiImporterFlags_LimitedSupport = 8;

  /// Indicates that the importer is highly experimental and
  /// should be used with care. This only happens for trunk
  /// (i.e. SVN) versions, experimental code is not included
  /// in releases.
  static const int aiImporterFlags_Experimental = 16;
}

/// Meta information about a particular importer. Importers need to fill
/// this structure, but they can freely decide how talkative they are.
/// A common use case for loader meta info is a user interface
/// in which the user can choose between various import/export file
/// formats. Building such an UI by hand means a lot of maintenance
/// as importers/exporters are added to Assimp, so it might be useful
/// to have a common mechanism to query some rough importer
/// characteristics.
class aiImporterDesc extends ffi.Struct {
  /// Full name of the importer (i.e. Blender3D importer)
  external ffi.Pointer<ffi.Char> mName;

  /// Original author (left blank if unknown or whole assimp team)
  external ffi.Pointer<ffi.Char> mAuthor;

  /// Current maintainer, left blank if the author maintains
  external ffi.Pointer<ffi.Char> mMaintainer;

  /// Implementation comments, i.e. unimplemented features
  external ffi.Pointer<ffi.Char> mComments;

  /// These flags indicate some characteristics common to many
  /// importers.
  @ffi.UnsignedInt()
  external int mFlags;

  /// Minimum format version that can be loaded im major.minor format,
  /// both are set to 0 if there is either no version scheme
  /// or if the loader doesn't care.
  @ffi.UnsignedInt()
  external int mMinMajor;

  @ffi.UnsignedInt()
  external int mMinMinor;

  /// Maximum format version that can be loaded im major.minor format,
  /// both are set to 0 if there is either no version scheme
  /// or if the loader doesn't care. Loaders that expect to be
  /// forward-compatible to potential future format versions should
  /// indicate  zero, otherwise they should specify the current
  /// maximum version.
  @ffi.UnsignedInt()
  external int mMaxMajor;

  @ffi.UnsignedInt()
  external int mMaxMinor;

  /// List of file extensions this importer can handle.
  /// List entries are separated by space characters.
  /// All entries are lower case without a leading dot (i.e.
  /// "xml dae" would be a valid value. Note that multiple
  /// importers may respond to the same file extension -
  /// assimp calls all importers in the order in which they
  /// are registered and each importer gets the opportunity
  /// to load the file until one importer "claims" the file. Apart
  /// from file extension checks, importers typically use
  /// other methods to quickly reject files (i.e. magic
  /// words) so this does not mean that common or generic
  /// file extensions such as XML would be tediously slow.
  external ffi.Pointer<ffi.Char> mFileExtensions;
}

/// C-API: Represents a log stream. A log stream receives all log messages and
/// streams them _somewhere_.
/// @see aiGetPredefinedLogStream
/// @see aiAttachLogStream
/// @see aiDetachLogStream
class aiLogStream extends ffi.Struct {
  /// callback to be called
  external aiLogStreamCallback callback;

  /// user data to be passed to the callback
  external ffi.Pointer<ffi.Char> user;
}

typedef aiLogStreamCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>;

/// C-API: Represents an opaque set of settings to be used during importing.
/// @see aiCreatePropertyStore
/// @see aiReleasePropertyStore
/// @see aiImportFileExWithProperties
/// @see aiSetPropertyInteger
/// @see aiSetPropertyFloat
/// @see aiSetPropertyString
/// @see aiSetPropertyMatrix
class aiPropertyStore extends ffi.Struct {
  @ffi.Char()
  external int sentinel;
}

/// Our own C boolean type
typedef aiBool = ffi.Int;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int CHAR_BIT = 8;

const int SCHAR_MIN = -128;

const int SCHAR_MAX = 127;

const int UCHAR_MAX = 255;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int MB_LEN_MAX = 5;

const int SHRT_MIN = -32768;

const int SHRT_MAX = 32767;

const int USHRT_MAX = 65535;

const int INT_MIN = -2147483648;

const int INT_MAX = 2147483647;

const int UINT_MAX = 4294967295;

const int LONG_MIN = -2147483648;

const int LONG_MAX = 2147483647;

const int ULONG_MAX = 4294967295;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int _I8_MIN = -128;

const int _I8_MAX = 127;

const int _UI8_MAX = 255;

const int _I16_MIN = -32768;

const int _I16_MAX = 32767;

const int _UI16_MAX = 65535;

const int _I32_MIN = -2147483648;

const int _I32_MAX = 2147483647;

const int _UI32_MAX = 4294967295;

const int _I64_MIN = -9223372036854775808;

const int _I64_MAX = 9223372036854775807;

const int _UI64_MAX = -1;

const int SIZE_MAX = -1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int EDEADLK = 36;

const int ENAMETOOLONG = 38;

const int ENOLCK = 39;

const int ENOSYS = 40;

const int ENOTEMPTY = 41;

const int EINVAL = 22;

const int ERANGE = 34;

const int EILSEQ = 42;

const int STRUNCATE = 80;

const int EDEADLOCK = 36;

const int EADDRINUSE = 100;

const int EADDRNOTAVAIL = 101;

const int EAFNOSUPPORT = 102;

const int EALREADY = 103;

const int EBADMSG = 104;

const int ECANCELED = 105;

const int ECONNABORTED = 106;

const int ECONNREFUSED = 107;

const int ECONNRESET = 108;

const int EDESTADDRREQ = 109;

const int EHOSTUNREACH = 110;

const int EIDRM = 111;

const int EINPROGRESS = 112;

const int EISCONN = 113;

const int ELOOP = 114;

const int EMSGSIZE = 115;

const int ENETDOWN = 116;

const int ENETRESET = 117;

const int ENETUNREACH = 118;

const int ENOBUFS = 119;

const int ENODATA = 120;

const int ENOLINK = 121;

const int ENOMSG = 122;

const int ENOPROTOOPT = 123;

const int ENOSR = 124;

const int ENOSTR = 125;

const int ENOTCONN = 126;

const int ENOTRECOVERABLE = 127;

const int ENOTSOCK = 128;

const int ENOTSUP = 129;

const int EOPNOTSUPP = 130;

const int EOTHER = 131;

const int EOVERFLOW = 132;

const int EOWNERDEAD = 133;

const int EPROTO = 134;

const int EPROTONOSUPPORT = 135;

const int EPROTOTYPE = 136;

const int ETIME = 137;

const int ETIMEDOUT = 138;

const int ETXTBSY = 139;

const int EWOULDBLOCK = 140;

const int _NLSCMPERROR = 2147483647;

const String AI_CONFIG_GLOB_MEASURE_TIME = 'GLOB_MEASURE_TIME';

const String AI_CONFIG_IMPORT_NO_SKELETON_MESHES = 'IMPORT_NO_SKELETON_MESHES';

const String AI_CONFIG_PP_SBBC_MAX_BONES = 'PP_SBBC_MAX_BONES';

const int AI_SBBC_DEFAULT_MAX_BONES = 60;

const String AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE = 'PP_CT_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX =
    'PP_CT_TEXTURE_CHANNEL_INDEX';

const String AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE =
    'PP_GSN_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_IMPORT_MDL_COLORMAP = 'IMPORT_MDL_COLORMAP';

const String AI_CONFIG_PP_RRM_EXCLUDE_LIST = 'PP_RRM_EXCLUDE_LIST';

const String AI_CONFIG_PP_PTV_KEEP_HIERARCHY = 'PP_PTV_KEEP_HIERARCHY';

const String AI_CONFIG_PP_PTV_NORMALIZE = 'PP_PTV_NORMALIZE';

const String AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION =
    'PP_PTV_ADD_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION =
    'PP_PTV_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_FD_REMOVE = 'PP_FD_REMOVE';

const String AI_CONFIG_PP_FD_CHECKAREA = 'PP_FD_CHECKAREA';

const String AI_CONFIG_PP_OG_EXCLUDE_LIST = 'PP_OG_EXCLUDE_LIST';

const String AI_CONFIG_PP_SLM_TRIANGLE_LIMIT = 'PP_SLM_TRIANGLE_LIMIT';

const int AI_SLM_DEFAULT_MAX_TRIANGLES = 1000000;

const String AI_CONFIG_PP_SLM_VERTEX_LIMIT = 'PP_SLM_VERTEX_LIMIT';

const int AI_SLM_DEFAULT_MAX_VERTICES = 1000000;

const String AI_CONFIG_PP_LBW_MAX_WEIGHTS = 'PP_LBW_MAX_WEIGHTS';

const int AI_LMW_MAX_WEIGHTS = 4;

const String AI_CONFIG_PP_DB_THRESHOLD = 'PP_DB_THRESHOLD';

const double AI_DEBONE_THRESHOLD = 1.0;

const String AI_CONFIG_PP_DB_ALL_OR_NONE = 'PP_DB_ALL_OR_NONE';

const int PP_ICL_PTCACHE_SIZE = 12;

const String AI_CONFIG_PP_ICL_PTCACHE_SIZE = 'PP_ICL_PTCACHE_SIZE';

const String AI_CONFIG_PP_RVC_FLAGS = 'PP_RVC_FLAGS';

const String AI_CONFIG_PP_SBP_REMOVE = 'PP_SBP_REMOVE';

const String AI_CONFIG_PP_FID_ANIM_ACCURACY = 'PP_FID_ANIM_ACCURACY';

const String AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS =
    'PP_FID_IGNORE_TEXTURECOORDS';

const int AI_UVTRAFO_SCALING = 1;

const int AI_UVTRAFO_ROTATION = 2;

const int AI_UVTRAFO_TRANSLATION = 4;

const int AI_UVTRAFO_ALL = 7;

const String AI_CONFIG_PP_TUV_EVALUATE = 'PP_TUV_EVALUATE';

const String AI_CONFIG_FAVOUR_SPEED = 'FAVOUR_SPEED';

const String AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER =
    'IMPORT_SCHEMA_DOCUMENT_PROVIDER';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS =
    'IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS =
    'IMPORT_FBX_READ_ALL_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_MATERIALS = 'IMPORT_FBX_READ_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_TEXTURES = 'IMPORT_FBX_READ_TEXTURES';

const String AI_CONFIG_IMPORT_FBX_READ_CAMERAS = 'IMPORT_FBX_READ_CAMERAS';

const String AI_CONFIG_IMPORT_FBX_READ_LIGHTS = 'IMPORT_FBX_READ_LIGHTS';

const String AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS =
    'IMPORT_FBX_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_FBX_READ_WEIGHTS = 'IMPORT_FBX_READ_WEIGHTS';

const String AI_CONFIG_IMPORT_FBX_STRICT_MODE = 'IMPORT_FBX_STRICT_MODE';

const String AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS =
    'IMPORT_FBX_PRESERVE_PIVOTS';

const String AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES =
    'IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES';

const String AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING =
    'AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING';

const String AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES =
    'AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES';

const String AI_CONFIG_FBX_CONVERT_TO_M = 'AI_CONFIG_FBX_CONVERT_TO_M';

const String AI_CONFIG_IMPORT_GLOBAL_KEYFRAME = 'IMPORT_GLOBAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MD3_KEYFRAME = 'IMPORT_MD3_KEYFRAME';

const String AI_CONFIG_IMPORT_MD2_KEYFRAME = 'IMPORT_MD2_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_KEYFRAME = 'IMPORT_MDL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDC_KEYFRAME = 'IMPORT_MDC_KEYFRAME';

const String AI_CONFIG_IMPORT_SMD_KEYFRAME = 'IMPORT_SMD_KEYFRAME';

const String AI_CONFIG_IMPORT_UNREAL_KEYFRAME = 'IMPORT_UNREAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS =
    'IMPORT_MDL_HL1_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS =
    'IMPORT_MDL_HL1_READ_ANIMATION_EVENTS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS =
    'IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS =
    'IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS =
    'IMPORT_MDL_HL1_READ_ATTACHMENTS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS =
    'IMPORT_MDL_HL1_READ_BONE_CONTROLLERS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES =
    'IMPORT_MDL_HL1_READ_HITBOXES';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO =
    'IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO';

const String AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST =
    'IMPORT_SMD_LOAD_ANIMATION_LIST';

const String AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL = 'IMPORT_AC_SEPARATE_BFCULL';

const String AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION =
    'IMPORT_AC_EVAL_SUBDIVISION';

const String AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS = 'UNREAL_HANDLE_FLAGS';

const String AI_CONFIG_IMPORT_TER_MAKE_UVS = 'IMPORT_TER_MAKE_UVS';

const String AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS =
    'IMPORT_ASE_RECONSTRUCT_NORMALS';

const String AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART =
    'IMPORT_MD3_HANDLE_MULTIPART';

const String AI_CONFIG_IMPORT_MD3_SKIN_NAME = 'IMPORT_MD3_SKIN_NAME';

const String AI_CONFIG_IMPORT_MD3_LOAD_SHADERS = 'IMPORT_MD3_LOAD_SHADERS';

const String AI_CONFIG_IMPORT_MD3_SHADER_SRC = 'IMPORT_MD3_SHADER_SRC';

const String AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY = 'IMPORT_LWO_ONE_LAYER_ONLY';

const String AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD =
    'IMPORT_MD5_NO_ANIM_AUTOLOAD';

const String AI_CONFIG_IMPORT_LWS_ANIM_START = 'IMPORT_LWS_ANIM_START';

const String AI_CONFIG_IMPORT_LWS_ANIM_END = 'IMPORT_LWS_ANIM_END';

const String AI_CONFIG_IMPORT_IRR_ANIM_FPS = 'IMPORT_IRR_ANIM_FPS';

const String AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE = 'IMPORT_OGRE_MATERIAL_FILE';

const String AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME =
    'IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME';

const String AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT =
    'AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT';

const String AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS =
    'IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS';

const String AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION =
    'IMPORT_IFC_CUSTOM_TRIANGULATION';

const String AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE =
    'IMPORT_IFC_SMOOTHING_ANGLE';

const double AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE = 10.0;

const String AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION =
    'IMPORT_IFC_CYLINDRICAL_TESSELLATION';

const int AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION = 32;

const String AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION =
    'IMPORT_COLLADA_IGNORE_UP_DIRECTION';

const String AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES =
    'IMPORT_COLLADA_USE_COLLADA_NAMES';

const String AI_CONFIG_EXPORT_XFILE_64BIT = 'EXPORT_XFILE_64BIT';

const String AI_CONFIG_EXPORT_POINT_CLOUDS = 'EXPORT_POINT_CLOUDS';

const String AI_CONFIG_EXPORT_BLOB_NAME = 'EXPORT_BLOB_NAME';

const String AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY = 'GLOBAL_SCALE_FACTOR';

const double AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT = 1.0;

const String AI_CONFIG_APP_SCALE_KEY = 'APP_SCALE_FACTOR';

const int ASSIMP_AI_REAL_TEXT_PRECISION = 9;

const double AI_MATH_PI = 3.141592653589793;

const double AI_MATH_TWO_PI = 6.283185307179586;

const double AI_MATH_HALF_PI = 1.5707963267948966;

const double AI_MATH_PI_F = 3.1415927410125732;

const double AI_MATH_TWO_PI_F = 6.2831854820251465;

const double AI_MATH_HALF_PI_F = 1.5707963705062866;

const int _DOMAIN = 1;

const int _SING = 2;

const int _OVERFLOW = 3;

const int _UNDERFLOW = 4;

const int _TLOSS = 5;

const int _PLOSS = 6;

const double _HUGE_ENUF = 1e+300;

const double INFINITY = double.infinity;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double NAN = double.nan;

const int _DENORM = -2;

const int _FINITE = -1;

const int _INFCODE = 1;

const int _NANCODE = 2;

const int FP_INFINITE = 1;

const int FP_NAN = 2;

const int FP_NORMAL = -1;

const int FP_SUBNORMAL = -2;

const int FP_ZERO = 0;

const int _C2 = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = 2147483647;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const int math_errhandling = 3;

const int _FE_DIVBYZERO = 4;

const int _FE_INEXACT = 32;

const int _FE_INVALID = 1;

const int _FE_OVERFLOW = 8;

const int _FE_UNDERFLOW = 16;

const int _D0_C = 3;

const int _D1_C = 2;

const int _D2_C = 1;

const int _D3_C = 0;

const int _DBIAS = 1022;

const int _DOFF = 4;

const int _F0_C = 1;

const int _F1_C = 0;

const int _FBIAS = 126;

const int _FOFF = 7;

const int _FRND = 1;

const int _L0_C = 3;

const int _L1_C = 2;

const int _L2_C = 1;

const int _L3_C = 0;

const int _LBIAS = 1022;

const int _LOFF = 4;

const int _DFRAC = 15;

const int _DMASK = 32752;

const int _DMAX = 2047;

const int _DSIGN = 32768;

const int _FFRAC = 127;

const int _FMASK = 32640;

const int _FMAX = 255;

const int _FSIGN = 32768;

const int _LFRAC = 65535;

const int _LMASK = 32767;

const int _LMAX = 32767;

const int _LSIGN = 32768;

const int _DHUGE_EXP = 1842;

const int _FHUGE_EXP = 229;

const int _LHUGE_EXP = 29490;

const int _FP_LT = 1;

const int _FP_EQ = 2;

const int _FP_GT = 4;

const int DOMAIN = 1;

const int SING = 2;

const int OVERFLOW = 3;

const int UNDERFLOW = 4;

const int TLOSS = 5;

const int PLOSS = 6;

const int MAXLEN = 1024;

const int AI_SUCCESS = 0;

const int AI_FAILURE = -1;

const int AI_OUTOFMEMORY = -3;

const int DLS_FILE = 1;

const int DLS_STDOUT = 2;

const int DLS_STDERR = 4;

const int DLS_DEBUGGER = 8;

const String AI_EMBEDDED_TEXNAME_PREFIX = '*';

const int HINTMAXTEXTURELEN = 9;

const int AI_MAX_FACE_INDICES = 32767;

const int AI_MAX_BONE_WEIGHTS = 2147483647;

const int AI_MAX_VERTICES = 2147483647;

const int AI_MAX_FACES = 2147483647;

const int AI_MAX_NUMBER_OF_COLOR_SETS = 8;

const int AI_MAX_NUMBER_OF_TEXTURECOORDS = 8;

const String AI_DEFAULT_MATERIAL_NAME = 'DefaultMaterial';

const int AI_TEXTURE_TYPE_MAX = 21;

const String AI_MATKEY_NAME = '?mat.name';

const String AI_MATKEY_TWOSIDED = '\$mat.twosided';

const String AI_MATKEY_SHADING_MODEL = '\$mat.shadingm';

const String AI_MATKEY_ENABLE_WIREFRAME = '\$mat.wireframe';

const String AI_MATKEY_BLEND_FUNC = '\$mat.blend';

const String AI_MATKEY_OPACITY = '\$mat.opacity';

const String AI_MATKEY_TRANSPARENCYFACTOR = '\$mat.transparencyfactor';

const String AI_MATKEY_BUMPSCALING = '\$mat.bumpscaling';

const String AI_MATKEY_SHININESS = '\$mat.shininess';

const String AI_MATKEY_REFLECTIVITY = '\$mat.reflectivity';

const String AI_MATKEY_SHININESS_STRENGTH = '\$mat.shinpercent';

const String AI_MATKEY_REFRACTI = '\$mat.refracti';

const String AI_MATKEY_COLOR_DIFFUSE = '\$clr.diffuse';

const String AI_MATKEY_COLOR_AMBIENT = '\$clr.ambient';

const String AI_MATKEY_COLOR_SPECULAR = '\$clr.specular';

const String AI_MATKEY_COLOR_EMISSIVE = '\$clr.emissive';

const String AI_MATKEY_COLOR_TRANSPARENT = '\$clr.transparent';

const String AI_MATKEY_COLOR_REFLECTIVE = '\$clr.reflective';

const String AI_MATKEY_GLOBAL_BACKGROUND_IMAGE = '?bg.global';

const String AI_MATKEY_GLOBAL_SHADERLANG = '?sh.lang';

const String AI_MATKEY_SHADER_VERTEX = '?sh.vs';

const String AI_MATKEY_SHADER_FRAGMENT = '?sh.fs';

const String AI_MATKEY_SHADER_GEO = '?sh.gs';

const String AI_MATKEY_SHADER_TESSELATION = '?sh.ts';

const String AI_MATKEY_SHADER_PRIMITIVE = '?sh.ps';

const String AI_MATKEY_SHADER_COMPUTE = '?sh.cs';

const String AI_MATKEY_USE_COLOR_MAP = '\$mat.useColorMap';

const String AI_MATKEY_BASE_COLOR = '\$clr.base';

const int AI_MATKEY_BASE_COLOR_TEXTURE = 12;

const String AI_MATKEY_USE_METALLIC_MAP = '\$mat.useMetallicMap';

const String AI_MATKEY_METALLIC_FACTOR = '\$mat.metallicFactor';

const int AI_MATKEY_METALLIC_TEXTURE = 15;

const String AI_MATKEY_USE_ROUGHNESS_MAP = '\$mat.useRoughnessMap';

const String AI_MATKEY_ROUGHNESS_FACTOR = '\$mat.roughnessFactor';

const int AI_MATKEY_ROUGHNESS_TEXTURE = 16;

const String AI_MATKEY_ANISOTROPY_FACTOR = '\$mat.anisotropyFactor';

const String AI_MATKEY_SPECULAR_FACTOR = '\$mat.specularFactor';

const String AI_MATKEY_GLOSSINESS_FACTOR = '\$mat.glossinessFactor';

const String AI_MATKEY_SHEEN_COLOR_FACTOR = '\$clr.sheen.factor';

const String AI_MATKEY_SHEEN_ROUGHNESS_FACTOR = '\$mat.sheen.roughnessFactor';

const int AI_MATKEY_SHEEN_COLOR_TEXTURE = 19;

const int AI_MATKEY_SHEEN_ROUGHNESS_TEXTURE = 19;

const String AI_MATKEY_CLEARCOAT_FACTOR = '\$mat.clearcoat.factor';

const String AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR =
    '\$mat.clearcoat.roughnessFactor';

const int AI_MATKEY_CLEARCOAT_TEXTURE = 20;

const int AI_MATKEY_CLEARCOAT_ROUGHNESS_TEXTURE = 20;

const int AI_MATKEY_CLEARCOAT_NORMAL_TEXTURE = 20;

const String AI_MATKEY_TRANSMISSION_FACTOR = '\$mat.transmission.factor';

const int AI_MATKEY_TRANSMISSION_TEXTURE = 21;

const String AI_MATKEY_VOLUME_THICKNESS_FACTOR = '\$mat.volume.thicknessFactor';

const int AI_MATKEY_VOLUME_THICKNESS_TEXTURE = 21;

const String AI_MATKEY_VOLUME_ATTENUATION_DISTANCE =
    '\$mat.volume.attenuationDistance';

const String AI_MATKEY_VOLUME_ATTENUATION_COLOR =
    '\$mat.volume.attenuationColor';

const String AI_MATKEY_USE_EMISSIVE_MAP = '\$mat.useEmissiveMap';

const String AI_MATKEY_EMISSIVE_INTENSITY = '\$mat.emissiveIntensity';

const String AI_MATKEY_USE_AO_MAP = '\$mat.useAOMap';

const String _AI_MATKEY_TEXTURE_BASE = '\$tex.file';

const String _AI_MATKEY_UVWSRC_BASE = '\$tex.uvwsrc';

const String _AI_MATKEY_TEXOP_BASE = '\$tex.op';

const String _AI_MATKEY_MAPPING_BASE = '\$tex.mapping';

const String _AI_MATKEY_TEXBLEND_BASE = '\$tex.blend';

const String _AI_MATKEY_MAPPINGMODE_U_BASE = '\$tex.mapmodeu';

const String _AI_MATKEY_MAPPINGMODE_V_BASE = '\$tex.mapmodev';

const String _AI_MATKEY_TEXMAP_AXIS_BASE = '\$tex.mapaxis';

const String _AI_MATKEY_UVTRANSFORM_BASE = '\$tex.uvtrafo';

const String _AI_MATKEY_TEXFLAGS_BASE = '\$tex.flags';

const int AI_SCENE_FLAGS_INCOMPLETE = 1;

const int AI_SCENE_FLAGS_VALIDATED = 2;

const int AI_SCENE_FLAGS_VALIDATION_WARNING = 4;

const int AI_SCENE_FLAGS_NON_VERBOSE_FORMAT = 8;

const int AI_SCENE_FLAGS_TERRAIN = 16;

const int AI_SCENE_FLAGS_ALLOW_SHARED = 32;

const int AI_FALSE = 0;

const int AI_TRUE = 1;

const int ASSIMP_CFLAGS_SHARED = 1;

const int ASSIMP_CFLAGS_STLPORT = 2;

const int ASSIMP_CFLAGS_DEBUG = 4;

const int ASSIMP_CFLAGS_NOBOOST = 8;

const int ASSIMP_CFLAGS_SINGLETHREADED = 16;

const int ASSIMP_CFLAGS_DOUBLE_SUPPORT = 32;
