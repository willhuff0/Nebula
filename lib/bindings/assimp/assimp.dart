// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class Assimp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Assimp(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Assimp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __len,
  ) {
    return _memmove(
      __dst,
      __src,
      __len,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __b,
    int __c,
    int __len,
  ) {
    return _memset(
      __b,
      __c,
      __len,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcat(
      __s1,
      __s2,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dst,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strcspn(
      __s,
      __charset,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncat(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strpbrk(
      __s,
      __charset,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strspn(
      __s,
      __charset,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strstr(
      __big,
      __little,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
  ) {
    return _strtok(
      __str,
      __sep,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strxfrm(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lasts,
  ) {
    return _strtok_r(
      __str,
      __sep,
      __lasts,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __strerrbuf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __strerrbuf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s1,
  ) {
    return _strdup(
      __s1,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dst,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dst,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strndup(
      __s1,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strnlen(
      __s1,
      __n,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int memset_s(
    ffi.Pointer<ffi.Void> __s,
    int __smax,
    int __c,
    int __n,
  ) {
    return _memset_s(
      __s,
      __smax,
      __c,
      __n,
    );
  }

  late final _memset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Void>, rsize_t, ffi.Int, rsize_t)>>('memset_s');
  late final _memset_s = _memset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  ffi.Pointer<ffi.Void> memmem(
    ffi.Pointer<ffi.Void> __big,
    int __big_len,
    ffi.Pointer<ffi.Void> __little,
    int __little_len,
  ) {
    return _memmem(
      __big,
      __big_len,
      __little,
      __little_len,
    );
  }

  late final _memmemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmem');
  late final _memmem = _memmemPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern4(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern4,
    int __len,
  ) {
    return _memset_pattern4(
      __b,
      __pattern4,
      __len,
    );
  }

  late final _memset_pattern4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern4');
  late final _memset_pattern4 = _memset_pattern4Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern8(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern8,
    int __len,
  ) {
    return _memset_pattern8(
      __b,
      __pattern8,
      __len,
    );
  }

  late final _memset_pattern8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern8');
  late final _memset_pattern8 = _memset_pattern8Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern16(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern16,
    int __len,
  ) {
    return _memset_pattern16(
      __b,
      __pattern16,
      __len,
    );
  }

  late final _memset_pattern16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern16');
  late final _memset_pattern16 = _memset_pattern16Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strcasestr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strcasestr(
      __big,
      __little,
    );
  }

  late final _strcasestrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasestr');
  late final _strcasestr = _strcasestrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strnstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
    int __len,
  ) {
    return _strnstr(
      __big,
      __little,
      __len,
    );
  }

  late final _strnstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strnstr');
  late final _strnstr = _strnstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcat(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcat(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcat');
  late final _strlcat = _strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcpy(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcpy');
  late final _strlcpy = _strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void strmode(
    int __mode,
    ffi.Pointer<ffi.Char> __bp,
  ) {
    return _strmode(
      __mode,
      __bp,
    );
  }

  late final _strmodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('strmode');
  late final _strmode =
      _strmodePtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  void swab(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _swab(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _swabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ssize_t)>>('swab');
  late final _swab = _swabPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int timingsafe_bcmp(
    ffi.Pointer<ffi.Void> __b1,
    ffi.Pointer<ffi.Void> __b2,
    int __len,
  ) {
    return _timingsafe_bcmp(
      __b1,
      __b2,
      __len,
    );
  }

  late final _timingsafe_bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('timingsafe_bcmp');
  late final _timingsafe_bcmp = _timingsafe_bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int strsignal_r(
    int __sig,
    ffi.Pointer<ffi.Char> __strsignalbuf,
    int __buflen,
  ) {
    return _strsignal_r(
      __sig,
      __strsignalbuf,
      __buflen,
    );
  }

  late final _strsignal_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strsignal_r');
  late final _strsignal_r = _strsignal_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int bcmp(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcopy(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _bzero(
      arg0,
      arg1,
    );
  }

  late final _bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _index(
      arg0,
      arg1,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _rindex(
      arg0,
      arg1,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int arg0,
  ) {
    return _ffs(
      arg0,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _strcasecmp(
      arg0,
      arg1,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _strncasecmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int ffsl(
    int arg0,
  ) {
    return _ffsl(
      arg0,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int arg0,
  ) {
    return _ffsll(
      arg0,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int fls(
    int arg0,
  ) {
    return _fls(
      arg0,
    );
  }

  late final _flsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fls');
  late final _fls = _flsPtr.asFunction<int Function(int)>();

  int flsl(
    int arg0,
  ) {
    return _flsl(
      arg0,
    );
  }

  late final _flslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('flsl');
  late final _flsl = _flslPtr.asFunction<int Function(int)>();

  int flsll(
    int arg0,
  ) {
    return _flsll(
      arg0,
    );
  }

  late final _flsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('flsll');
  late final _flsll = _flsllPtr.asFunction<int Function(int)>();

  int __darwin_check_fd_set_overflow(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return ___darwin_check_fd_set_overflow(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___darwin_check_fd_set_overflowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('__darwin_check_fd_set_overflow');
  late final ___darwin_check_fd_set_overflow =
      ___darwin_check_fd_set_overflowPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  late final ffi.Pointer<ai_real> _ai_epsilon = _lookup<ai_real>('ai_epsilon');

  double get ai_epsilon => _ai_epsilon.value;

  set ai_epsilon(double value) => _ai_epsilon.value = value;

  int __math_errhandling() {
    return ___math_errhandling();
  }

  late final ___math_errhandlingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('__math_errhandling');
  late final ___math_errhandling =
      ___math_errhandlingPtr.asFunction<int Function()>();

  int __fpclassifyf(
    double arg0,
  ) {
    return ___fpclassifyf(
      arg0,
    );
  }

  late final ___fpclassifyfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('__fpclassifyf');
  late final ___fpclassifyf =
      ___fpclassifyfPtr.asFunction<int Function(double)>();

  int __fpclassifyd(
    double arg0,
  ) {
    return ___fpclassifyd(
      arg0,
    );
  }

  late final ___fpclassifydPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>(
          '__fpclassifyd');
  late final ___fpclassifyd =
      ___fpclassifydPtr.asFunction<int Function(double)>();

  double acosf(
    double arg0,
  ) {
    return _acosf(
      arg0,
    );
  }

  late final _acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acosf');
  late final _acosf = _acosfPtr.asFunction<double Function(double)>();

  double acos(
    double arg0,
  ) {
    return _acos(
      arg0,
    );
  }

  late final _acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acos');
  late final _acos = _acosPtr.asFunction<double Function(double)>();

  double asinf(
    double arg0,
  ) {
    return _asinf(
      arg0,
    );
  }

  late final _asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinf');
  late final _asinf = _asinfPtr.asFunction<double Function(double)>();

  double asin(
    double arg0,
  ) {
    return _asin(
      arg0,
    );
  }

  late final _asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asin');
  late final _asin = _asinPtr.asFunction<double Function(double)>();

  double atanf(
    double arg0,
  ) {
    return _atanf(
      arg0,
    );
  }

  late final _atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanf');
  late final _atanf = _atanfPtr.asFunction<double Function(double)>();

  double atan(
    double arg0,
  ) {
    return _atan(
      arg0,
    );
  }

  late final _atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atan');
  late final _atan = _atanPtr.asFunction<double Function(double)>();

  double atan2f(
    double arg0,
    double arg1,
  ) {
    return _atan2f(
      arg0,
      arg1,
    );
  }

  late final _atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'atan2f');
  late final _atan2f = _atan2fPtr.asFunction<double Function(double, double)>();

  double atan2(
    double arg0,
    double arg1,
  ) {
    return _atan2(
      arg0,
      arg1,
    );
  }

  late final _atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'atan2');
  late final _atan2 = _atan2Ptr.asFunction<double Function(double, double)>();

  double cosf(
    double arg0,
  ) {
    return _cosf(
      arg0,
    );
  }

  late final _cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cosf');
  late final _cosf = _cosfPtr.asFunction<double Function(double)>();

  double cos(
    double arg0,
  ) {
    return _cos(
      arg0,
    );
  }

  late final _cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cos');
  late final _cos = _cosPtr.asFunction<double Function(double)>();

  double sinf(
    double arg0,
  ) {
    return _sinf(
      arg0,
    );
  }

  late final _sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinf');
  late final _sinf = _sinfPtr.asFunction<double Function(double)>();

  double sin(
    double arg0,
  ) {
    return _sin(
      arg0,
    );
  }

  late final _sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sin');
  late final _sin = _sinPtr.asFunction<double Function(double)>();

  double tanf(
    double arg0,
  ) {
    return _tanf(
      arg0,
    );
  }

  late final _tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanf');
  late final _tanf = _tanfPtr.asFunction<double Function(double)>();

  double tan(
    double arg0,
  ) {
    return _tan(
      arg0,
    );
  }

  late final _tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tan');
  late final _tan = _tanPtr.asFunction<double Function(double)>();

  double acoshf(
    double arg0,
  ) {
    return _acoshf(
      arg0,
    );
  }

  late final _acoshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acoshf');
  late final _acoshf = _acoshfPtr.asFunction<double Function(double)>();

  double acosh(
    double arg0,
  ) {
    return _acosh(
      arg0,
    );
  }

  late final _acoshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acosh');
  late final _acosh = _acoshPtr.asFunction<double Function(double)>();

  double asinhf(
    double arg0,
  ) {
    return _asinhf(
      arg0,
    );
  }

  late final _asinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinhf');
  late final _asinhf = _asinhfPtr.asFunction<double Function(double)>();

  double asinh(
    double arg0,
  ) {
    return _asinh(
      arg0,
    );
  }

  late final _asinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asinh');
  late final _asinh = _asinhPtr.asFunction<double Function(double)>();

  double atanhf(
    double arg0,
  ) {
    return _atanhf(
      arg0,
    );
  }

  late final _atanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanhf');
  late final _atanhf = _atanhfPtr.asFunction<double Function(double)>();

  double atanh(
    double arg0,
  ) {
    return _atanh(
      arg0,
    );
  }

  late final _atanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atanh');
  late final _atanh = _atanhPtr.asFunction<double Function(double)>();

  double coshf(
    double arg0,
  ) {
    return _coshf(
      arg0,
    );
  }

  late final _coshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('coshf');
  late final _coshf = _coshfPtr.asFunction<double Function(double)>();

  double cosh(
    double arg0,
  ) {
    return _cosh(
      arg0,
    );
  }

  late final _coshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cosh');
  late final _cosh = _coshPtr.asFunction<double Function(double)>();

  double sinhf(
    double arg0,
  ) {
    return _sinhf(
      arg0,
    );
  }

  late final _sinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinhf');
  late final _sinhf = _sinhfPtr.asFunction<double Function(double)>();

  double sinh(
    double arg0,
  ) {
    return _sinh(
      arg0,
    );
  }

  late final _sinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sinh');
  late final _sinh = _sinhPtr.asFunction<double Function(double)>();

  double tanhf(
    double arg0,
  ) {
    return _tanhf(
      arg0,
    );
  }

  late final _tanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanhf');
  late final _tanhf = _tanhfPtr.asFunction<double Function(double)>();

  double tanh(
    double arg0,
  ) {
    return _tanh(
      arg0,
    );
  }

  late final _tanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tanh');
  late final _tanh = _tanhPtr.asFunction<double Function(double)>();

  double expf(
    double arg0,
  ) {
    return _expf(
      arg0,
    );
  }

  late final _expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expf');
  late final _expf = _expfPtr.asFunction<double Function(double)>();

  double exp(
    double arg0,
  ) {
    return _exp(
      arg0,
    );
  }

  late final _expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp');
  late final _exp = _expPtr.asFunction<double Function(double)>();

  double exp2f(
    double arg0,
  ) {
    return _exp2f(
      arg0,
    );
  }

  late final _exp2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('exp2f');
  late final _exp2f = _exp2fPtr.asFunction<double Function(double)>();

  double exp2(
    double arg0,
  ) {
    return _exp2(
      arg0,
    );
  }

  late final _exp2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp2');
  late final _exp2 = _exp2Ptr.asFunction<double Function(double)>();

  double expm1f(
    double arg0,
  ) {
    return _expm1f(
      arg0,
    );
  }

  late final _expm1fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expm1f');
  late final _expm1f = _expm1fPtr.asFunction<double Function(double)>();

  double expm1(
    double arg0,
  ) {
    return _expm1(
      arg0,
    );
  }

  late final _expm1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('expm1');
  late final _expm1 = _expm1Ptr.asFunction<double Function(double)>();

  double logf(
    double arg0,
  ) {
    return _logf(
      arg0,
    );
  }

  late final _logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logf');
  late final _logf = _logfPtr.asFunction<double Function(double)>();

  double log(
    double arg0,
  ) {
    return _log(
      arg0,
    );
  }

  late final _logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log');
  late final _log = _logPtr.asFunction<double Function(double)>();

  double log10f(
    double arg0,
  ) {
    return _log10f(
      arg0,
    );
  }

  late final _log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log10f');
  late final _log10f = _log10fPtr.asFunction<double Function(double)>();

  double log10(
    double arg0,
  ) {
    return _log10(
      arg0,
    );
  }

  late final _log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log10');
  late final _log10 = _log10Ptr.asFunction<double Function(double)>();

  double log2f(
    double arg0,
  ) {
    return _log2f(
      arg0,
    );
  }

  late final _log2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log2f');
  late final _log2f = _log2fPtr.asFunction<double Function(double)>();

  double log2(
    double arg0,
  ) {
    return _log2(
      arg0,
    );
  }

  late final _log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log2');
  late final _log2 = _log2Ptr.asFunction<double Function(double)>();

  double log1pf(
    double arg0,
  ) {
    return _log1pf(
      arg0,
    );
  }

  late final _log1pfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log1pf');
  late final _log1pf = _log1pfPtr.asFunction<double Function(double)>();

  double log1p(
    double arg0,
  ) {
    return _log1p(
      arg0,
    );
  }

  late final _log1pPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log1p');
  late final _log1p = _log1pPtr.asFunction<double Function(double)>();

  double logbf(
    double arg0,
  ) {
    return _logbf(
      arg0,
    );
  }

  late final _logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logbf');
  late final _logbf = _logbfPtr.asFunction<double Function(double)>();

  double logb(
    double arg0,
  ) {
    return _logb(
      arg0,
    );
  }

  late final _logbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('logb');
  late final _logb = _logbPtr.asFunction<double Function(double)>();

  double modff(
    double arg0,
    ffi.Pointer<ffi.Float> arg1,
  ) {
    return _modff(
      arg0,
      arg1,
    );
  }

  late final _modffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Float>)>>('modff');
  late final _modff =
      _modffPtr.asFunction<double Function(double, ffi.Pointer<ffi.Float>)>();

  double modf(
    double arg0,
    ffi.Pointer<ffi.Double> arg1,
  ) {
    return _modf(
      arg0,
      arg1,
    );
  }

  late final _modfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Double>)>>('modf');
  late final _modf =
      _modfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Double>)>();

  double ldexpf(
    double arg0,
    int arg1,
  ) {
    return _ldexpf(
      arg0,
      arg1,
    );
  }

  late final _ldexpfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'ldexpf');
  late final _ldexpf = _ldexpfPtr.asFunction<double Function(double, int)>();

  double ldexp(
    double arg0,
    int arg1,
  ) {
    return _ldexp(
      arg0,
      arg1,
    );
  }

  late final _ldexpPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'ldexp');
  late final _ldexp = _ldexpPtr.asFunction<double Function(double, int)>();

  double frexpf(
    double arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _frexpf(
      arg0,
      arg1,
    );
  }

  late final _frexpfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Int>)>>('frexpf');
  late final _frexpf =
      _frexpfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  double frexp(
    double arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _frexp(
      arg0,
      arg1,
    );
  }

  late final _frexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Int>)>>('frexp');
  late final _frexp =
      _frexpPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  int ilogbf(
    double arg0,
  ) {
    return _ilogbf(
      arg0,
    );
  }

  late final _ilogbfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('ilogbf');
  late final _ilogbf = _ilogbfPtr.asFunction<int Function(double)>();

  int ilogb(
    double arg0,
  ) {
    return _ilogb(
      arg0,
    );
  }

  late final _ilogbPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>('ilogb');
  late final _ilogb = _ilogbPtr.asFunction<int Function(double)>();

  double scalbnf(
    double arg0,
    int arg1,
  ) {
    return _scalbnf(
      arg0,
      arg1,
    );
  }

  late final _scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'scalbnf');
  late final _scalbnf = _scalbnfPtr.asFunction<double Function(double, int)>();

  double scalbn(
    double arg0,
    int arg1,
  ) {
    return _scalbn(
      arg0,
      arg1,
    );
  }

  late final _scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'scalbn');
  late final _scalbn = _scalbnPtr.asFunction<double Function(double, int)>();

  double scalblnf(
    double arg0,
    int arg1,
  ) {
    return _scalblnf(
      arg0,
      arg1,
    );
  }

  late final _scalblnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Long)>>(
          'scalblnf');
  late final _scalblnf =
      _scalblnfPtr.asFunction<double Function(double, int)>();

  double scalbln(
    double arg0,
    int arg1,
  ) {
    return _scalbln(
      arg0,
      arg1,
    );
  }

  late final _scalblnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Long)>>(
          'scalbln');
  late final _scalbln = _scalblnPtr.asFunction<double Function(double, int)>();

  double fabsf(
    double arg0,
  ) {
    return _fabsf(
      arg0,
    );
  }

  late final _fabsfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('fabsf');
  late final _fabsf = _fabsfPtr.asFunction<double Function(double)>();

  double fabs(
    double arg0,
  ) {
    return _fabs(
      arg0,
    );
  }

  late final _fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('fabs');
  late final _fabs = _fabsPtr.asFunction<double Function(double)>();

  double cbrtf(
    double arg0,
  ) {
    return _cbrtf(
      arg0,
    );
  }

  late final _cbrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cbrtf');
  late final _cbrtf = _cbrtfPtr.asFunction<double Function(double)>();

  double cbrt(
    double arg0,
  ) {
    return _cbrt(
      arg0,
    );
  }

  late final _cbrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cbrt');
  late final _cbrt = _cbrtPtr.asFunction<double Function(double)>();

  double hypotf(
    double arg0,
    double arg1,
  ) {
    return _hypotf(
      arg0,
      arg1,
    );
  }

  late final _hypotfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'hypotf');
  late final _hypotf = _hypotfPtr.asFunction<double Function(double, double)>();

  double hypot(
    double arg0,
    double arg1,
  ) {
    return _hypot(
      arg0,
      arg1,
    );
  }

  late final _hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'hypot');
  late final _hypot = _hypotPtr.asFunction<double Function(double, double)>();

  double powf(
    double arg0,
    double arg1,
  ) {
    return _powf(
      arg0,
      arg1,
    );
  }

  late final _powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'powf');
  late final _powf = _powfPtr.asFunction<double Function(double, double)>();

  double pow(
    double arg0,
    double arg1,
  ) {
    return _pow(
      arg0,
      arg1,
    );
  }

  late final _powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'pow');
  late final _pow = _powPtr.asFunction<double Function(double, double)>();

  double sqrtf(
    double arg0,
  ) {
    return _sqrtf(
      arg0,
    );
  }

  late final _sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sqrtf');
  late final _sqrtf = _sqrtfPtr.asFunction<double Function(double)>();

  double sqrt(
    double arg0,
  ) {
    return _sqrt(
      arg0,
    );
  }

  late final _sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sqrt');
  late final _sqrt = _sqrtPtr.asFunction<double Function(double)>();

  double erff(
    double arg0,
  ) {
    return _erff(
      arg0,
    );
  }

  late final _erffPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erff');
  late final _erff = _erffPtr.asFunction<double Function(double)>();

  double erf(
    double arg0,
  ) {
    return _erf(
      arg0,
    );
  }

  late final _erfPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erf');
  late final _erf = _erfPtr.asFunction<double Function(double)>();

  double erfcf(
    double arg0,
  ) {
    return _erfcf(
      arg0,
    );
  }

  late final _erfcfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erfcf');
  late final _erfcf = _erfcfPtr.asFunction<double Function(double)>();

  double erfc(
    double arg0,
  ) {
    return _erfc(
      arg0,
    );
  }

  late final _erfcPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erfc');
  late final _erfc = _erfcPtr.asFunction<double Function(double)>();

  double lgammaf(
    double arg0,
  ) {
    return _lgammaf(
      arg0,
    );
  }

  late final _lgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('lgammaf');
  late final _lgammaf = _lgammafPtr.asFunction<double Function(double)>();

  double lgamma(
    double arg0,
  ) {
    return _lgamma(
      arg0,
    );
  }

  late final _lgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('lgamma');
  late final _lgamma = _lgammaPtr.asFunction<double Function(double)>();

  double tgammaf(
    double arg0,
  ) {
    return _tgammaf(
      arg0,
    );
  }

  late final _tgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tgammaf');
  late final _tgammaf = _tgammafPtr.asFunction<double Function(double)>();

  double tgamma(
    double arg0,
  ) {
    return _tgamma(
      arg0,
    );
  }

  late final _tgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tgamma');
  late final _tgamma = _tgammaPtr.asFunction<double Function(double)>();

  double ceilf(
    double arg0,
  ) {
    return _ceilf(
      arg0,
    );
  }

  late final _ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('ceilf');
  late final _ceilf = _ceilfPtr.asFunction<double Function(double)>();

  double ceil(
    double arg0,
  ) {
    return _ceil(
      arg0,
    );
  }

  late final _ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('ceil');
  late final _ceil = _ceilPtr.asFunction<double Function(double)>();

  double floorf(
    double arg0,
  ) {
    return _floorf(
      arg0,
    );
  }

  late final _floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('floorf');
  late final _floorf = _floorfPtr.asFunction<double Function(double)>();

  double floor(
    double arg0,
  ) {
    return _floor(
      arg0,
    );
  }

  late final _floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('floor');
  late final _floor = _floorPtr.asFunction<double Function(double)>();

  double nearbyintf(
    double arg0,
  ) {
    return _nearbyintf(
      arg0,
    );
  }

  late final _nearbyintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('nearbyintf');
  late final _nearbyintf = _nearbyintfPtr.asFunction<double Function(double)>();

  double nearbyint(
    double arg0,
  ) {
    return _nearbyint(
      arg0,
    );
  }

  late final _nearbyintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('nearbyint');
  late final _nearbyint = _nearbyintPtr.asFunction<double Function(double)>();

  double rintf(
    double arg0,
  ) {
    return _rintf(
      arg0,
    );
  }

  late final _rintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('rintf');
  late final _rintf = _rintfPtr.asFunction<double Function(double)>();

  double rint(
    double arg0,
  ) {
    return _rint(
      arg0,
    );
  }

  late final _rintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('rint');
  late final _rint = _rintPtr.asFunction<double Function(double)>();

  int lrintf(
    double arg0,
  ) {
    return _lrintf(
      arg0,
    );
  }

  late final _lrintfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lrintf');
  late final _lrintf = _lrintfPtr.asFunction<int Function(double)>();

  int lrint(
    double arg0,
  ) {
    return _lrint(
      arg0,
    );
  }

  late final _lrintPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lrint');
  late final _lrint = _lrintPtr.asFunction<int Function(double)>();

  double roundf(
    double arg0,
  ) {
    return _roundf(
      arg0,
    );
  }

  late final _roundfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('roundf');
  late final _roundf = _roundfPtr.asFunction<double Function(double)>();

  double round(
    double arg0,
  ) {
    return _round(
      arg0,
    );
  }

  late final _roundPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('round');
  late final _round = _roundPtr.asFunction<double Function(double)>();

  int lroundf(
    double arg0,
  ) {
    return _lroundf(
      arg0,
    );
  }

  late final _lroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lroundf');
  late final _lroundf = _lroundfPtr.asFunction<int Function(double)>();

  int lround(
    double arg0,
  ) {
    return _lround(
      arg0,
    );
  }

  late final _lroundPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lround');
  late final _lround = _lroundPtr.asFunction<int Function(double)>();

  int llrintf(
    double arg0,
  ) {
    return _llrintf(
      arg0,
    );
  }

  late final _llrintfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llrintf');
  late final _llrintf = _llrintfPtr.asFunction<int Function(double)>();

  int llrint(
    double arg0,
  ) {
    return _llrint(
      arg0,
    );
  }

  late final _llrintPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llrint');
  late final _llrint = _llrintPtr.asFunction<int Function(double)>();

  int llroundf(
    double arg0,
  ) {
    return _llroundf(
      arg0,
    );
  }

  late final _llroundfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llroundf');
  late final _llroundf = _llroundfPtr.asFunction<int Function(double)>();

  int llround(
    double arg0,
  ) {
    return _llround(
      arg0,
    );
  }

  late final _llroundPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llround');
  late final _llround = _llroundPtr.asFunction<int Function(double)>();

  double truncf(
    double arg0,
  ) {
    return _truncf(
      arg0,
    );
  }

  late final _truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('truncf');
  late final _truncf = _truncfPtr.asFunction<double Function(double)>();

  double trunc(
    double arg0,
  ) {
    return _trunc(
      arg0,
    );
  }

  late final _truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('trunc');
  late final _trunc = _truncPtr.asFunction<double Function(double)>();

  double fmodf(
    double arg0,
    double arg1,
  ) {
    return _fmodf(
      arg0,
      arg1,
    );
  }

  late final _fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmodf');
  late final _fmodf = _fmodfPtr.asFunction<double Function(double, double)>();

  double fmod(
    double arg0,
    double arg1,
  ) {
    return _fmod(
      arg0,
      arg1,
    );
  }

  late final _fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmod');
  late final _fmod = _fmodPtr.asFunction<double Function(double, double)>();

  double remainderf(
    double arg0,
    double arg1,
  ) {
    return _remainderf(
      arg0,
      arg1,
    );
  }

  late final _remainderfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'remainderf');
  late final _remainderf =
      _remainderfPtr.asFunction<double Function(double, double)>();

  double remainder(
    double arg0,
    double arg1,
  ) {
    return _remainder(
      arg0,
      arg1,
    );
  }

  late final _remainderPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'remainder');
  late final _remainder =
      _remainderPtr.asFunction<double Function(double, double)>();

  double remquof(
    double arg0,
    double arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _remquof(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _remquofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Int>)>>('remquof');
  late final _remquof = _remquofPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double remquo(
    double arg0,
    double arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _remquo(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _remquoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Double, ffi.Pointer<ffi.Int>)>>('remquo');
  late final _remquo = _remquoPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double copysignf(
    double arg0,
    double arg1,
  ) {
    return _copysignf(
      arg0,
      arg1,
    );
  }

  late final _copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'copysignf');
  late final _copysignf =
      _copysignfPtr.asFunction<double Function(double, double)>();

  double copysign(
    double arg0,
    double arg1,
  ) {
    return _copysign(
      arg0,
      arg1,
    );
  }

  late final _copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'copysign');
  late final _copysign =
      _copysignPtr.asFunction<double Function(double, double)>();

  double nanf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _nanf(
      arg0,
    );
  }

  late final _nanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Char>)>>(
          'nanf');
  late final _nanf =
      _nanfPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nan(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _nan(
      arg0,
    );
  }

  late final _nanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'nan');
  late final _nan =
      _nanPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nextafterf(
    double arg0,
    double arg1,
  ) {
    return _nextafterf(
      arg0,
      arg1,
    );
  }

  late final _nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'nextafterf');
  late final _nextafterf =
      _nextafterfPtr.asFunction<double Function(double, double)>();

  double nextafter(
    double arg0,
    double arg1,
  ) {
    return _nextafter(
      arg0,
      arg1,
    );
  }

  late final _nextafterPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'nextafter');
  late final _nextafter =
      _nextafterPtr.asFunction<double Function(double, double)>();

  double fdimf(
    double arg0,
    double arg1,
  ) {
    return _fdimf(
      arg0,
      arg1,
    );
  }

  late final _fdimfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fdimf');
  late final _fdimf = _fdimfPtr.asFunction<double Function(double, double)>();

  double fdim(
    double arg0,
    double arg1,
  ) {
    return _fdim(
      arg0,
      arg1,
    );
  }

  late final _fdimPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fdim');
  late final _fdim = _fdimPtr.asFunction<double Function(double, double)>();

  double fmaxf(
    double arg0,
    double arg1,
  ) {
    return _fmaxf(
      arg0,
      arg1,
    );
  }

  late final _fmaxfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmaxf');
  late final _fmaxf = _fmaxfPtr.asFunction<double Function(double, double)>();

  double fmax(
    double arg0,
    double arg1,
  ) {
    return _fmax(
      arg0,
      arg1,
    );
  }

  late final _fmaxPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmax');
  late final _fmax = _fmaxPtr.asFunction<double Function(double, double)>();

  double fminf(
    double arg0,
    double arg1,
  ) {
    return _fminf(
      arg0,
      arg1,
    );
  }

  late final _fminfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fminf');
  late final _fminf = _fminfPtr.asFunction<double Function(double, double)>();

  double fmin(
    double arg0,
    double arg1,
  ) {
    return _fmin(
      arg0,
      arg1,
    );
  }

  late final _fminPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmin');
  late final _fmin = _fminPtr.asFunction<double Function(double, double)>();

  double fmaf(
    double arg0,
    double arg1,
    double arg2,
  ) {
    return _fmaf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fmafPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Float, ffi.Float)>>('fmaf');
  late final _fmaf =
      _fmafPtr.asFunction<double Function(double, double, double)>();

  double fma(
    double arg0,
    double arg1,
    double arg2,
  ) {
    return _fma(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fmaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Double, ffi.Double)>>('fma');
  late final _fma =
      _fmaPtr.asFunction<double Function(double, double, double)>();

  double __exp10f(
    double arg0,
  ) {
    return ___exp10f(
      arg0,
    );
  }

  late final ___exp10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__exp10f');
  late final ___exp10f = ___exp10fPtr.asFunction<double Function(double)>();

  double __exp10(
    double arg0,
  ) {
    return ___exp10(
      arg0,
    );
  }

  late final ___exp10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__exp10');
  late final ___exp10 = ___exp10Ptr.asFunction<double Function(double)>();

  double __cospif(
    double arg0,
  ) {
    return ___cospif(
      arg0,
    );
  }

  late final ___cospifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__cospif');
  late final ___cospif = ___cospifPtr.asFunction<double Function(double)>();

  double __cospi(
    double arg0,
  ) {
    return ___cospi(
      arg0,
    );
  }

  late final ___cospiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__cospi');
  late final ___cospi = ___cospiPtr.asFunction<double Function(double)>();

  double __sinpif(
    double arg0,
  ) {
    return ___sinpif(
      arg0,
    );
  }

  late final ___sinpifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__sinpif');
  late final ___sinpif = ___sinpifPtr.asFunction<double Function(double)>();

  double __sinpi(
    double arg0,
  ) {
    return ___sinpi(
      arg0,
    );
  }

  late final ___sinpiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__sinpi');
  late final ___sinpi = ___sinpiPtr.asFunction<double Function(double)>();

  double __tanpif(
    double arg0,
  ) {
    return ___tanpif(
      arg0,
    );
  }

  late final ___tanpifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__tanpif');
  late final ___tanpif = ___tanpifPtr.asFunction<double Function(double)>();

  double __tanpi(
    double arg0,
  ) {
    return ___tanpi(
      arg0,
    );
  }

  late final ___tanpiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__tanpi');
  late final ___tanpi = ___tanpiPtr.asFunction<double Function(double)>();

  __float2 __sincosf_stret(
    double arg0,
  ) {
    return ___sincosf_stret(
      arg0,
    );
  }

  late final ___sincosf_stretPtr =
      _lookup<ffi.NativeFunction<__float2 Function(ffi.Float)>>(
          '__sincosf_stret');
  late final ___sincosf_stret =
      ___sincosf_stretPtr.asFunction<__float2 Function(double)>();

  __double2 __sincos_stret(
    double arg0,
  ) {
    return ___sincos_stret(
      arg0,
    );
  }

  late final ___sincos_stretPtr =
      _lookup<ffi.NativeFunction<__double2 Function(ffi.Double)>>(
          '__sincos_stret');
  late final ___sincos_stret =
      ___sincos_stretPtr.asFunction<__double2 Function(double)>();

  __float2 __sincospif_stret(
    double arg0,
  ) {
    return ___sincospif_stret(
      arg0,
    );
  }

  late final ___sincospif_stretPtr =
      _lookup<ffi.NativeFunction<__float2 Function(ffi.Float)>>(
          '__sincospif_stret');
  late final ___sincospif_stret =
      ___sincospif_stretPtr.asFunction<__float2 Function(double)>();

  __double2 __sincospi_stret(
    double arg0,
  ) {
    return ___sincospi_stret(
      arg0,
    );
  }

  late final ___sincospi_stretPtr =
      _lookup<ffi.NativeFunction<__double2 Function(ffi.Double)>>(
          '__sincospi_stret');
  late final ___sincospi_stret =
      ___sincospi_stretPtr.asFunction<__double2 Function(double)>();

  double j0(
    double arg0,
  ) {
    return _j0(
      arg0,
    );
  }

  late final _j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j0');
  late final _j0 = _j0Ptr.asFunction<double Function(double)>();

  double j1(
    double arg0,
  ) {
    return _j1(
      arg0,
    );
  }

  late final _j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j1');
  late final _j1 = _j1Ptr.asFunction<double Function(double)>();

  double jn(
    int arg0,
    double arg1,
  ) {
    return _jn(
      arg0,
      arg1,
    );
  }

  late final _jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'jn');
  late final _jn = _jnPtr.asFunction<double Function(int, double)>();

  double y0(
    double arg0,
  ) {
    return _y0(
      arg0,
    );
  }

  late final _y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y0');
  late final _y0 = _y0Ptr.asFunction<double Function(double)>();

  double y1(
    double arg0,
  ) {
    return _y1(
      arg0,
    );
  }

  late final _y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y1');
  late final _y1 = _y1Ptr.asFunction<double Function(double)>();

  double yn(
    int arg0,
    double arg1,
  ) {
    return _yn(
      arg0,
      arg1,
    );
  }

  late final _ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'yn');
  late final _yn = _ynPtr.asFunction<double Function(int, double)>();

  double scalb(
    double arg0,
    double arg1,
  ) {
    return _scalb(
      arg0,
      arg1,
    );
  }

  late final _scalbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'scalb');
  late final _scalb = _scalbPtr.asFunction<double Function(double, double)>();

  late final ffi.Pointer<ffi.Int> _signgam = _lookup<ffi.Int>('signgam');

  int get signgam => _signgam.value;

  set signgam(int value) => _signgam.value = value;

  ffi.Pointer<ffi.Char> aiTextureTypeToString(
    int in1,
  ) {
    return _aiTextureTypeToString(
      in1,
    );
  }

  late final _aiTextureTypeToStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'aiTextureTypeToString');
  late final _aiTextureTypeToString = _aiTextureTypeToStringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int aiGetMaterialProperty(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Pointer<aiMaterialProperty>> pPropOut,
  ) {
    return _aiGetMaterialProperty(
      pMat,
      pKey,
      type,
      index,
      pPropOut,
    );
  }

  late final _aiGetMaterialPropertyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<aiMaterial>,
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedInt,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Pointer<aiMaterialProperty>>)>>(
      'aiGetMaterialProperty');
  late final _aiGetMaterialProperty = _aiGetMaterialPropertyPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<aiMaterialProperty>>)>();

  int aiGetMaterialFloatArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ai_real> pOut,
    ffi.Pointer<ffi.UnsignedInt> pMax,
  ) {
    return _aiGetMaterialFloatArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    );
  }

  late final _aiGetMaterialFloatArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ai_real>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialFloatArray');
  late final _aiGetMaterialFloatArray = _aiGetMaterialFloatArrayPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ai_real>, ffi.Pointer<ffi.UnsignedInt>)>();

  int aiGetMaterialIntegerArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Int> pOut,
    ffi.Pointer<ffi.UnsignedInt> pMax,
  ) {
    return _aiGetMaterialIntegerArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    );
  }

  late final _aiGetMaterialIntegerArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialIntegerArray');
  late final _aiGetMaterialIntegerArray =
      _aiGetMaterialIntegerArrayPtr.asFunction<
          int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedInt>)>();

  int aiGetMaterialColor(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiColor4D> pOut,
  ) {
    return _aiGetMaterialColor(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiColor4D>)>>('aiGetMaterialColor');
  late final _aiGetMaterialColor = _aiGetMaterialColorPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<aiColor4D>)>();

  int aiGetMaterialUVTransform(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiUVTransform> pOut,
  ) {
    return _aiGetMaterialUVTransform(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialUVTransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiUVTransform>)>>('aiGetMaterialUVTransform');
  late final _aiGetMaterialUVTransform =
      _aiGetMaterialUVTransformPtr.asFunction<
          int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<aiUVTransform>)>();

  int aiGetMaterialString(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiString> pOut,
  ) {
    return _aiGetMaterialString(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiString>)>>('aiGetMaterialString');
  late final _aiGetMaterialString = _aiGetMaterialStringPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<aiString>)>();

  int aiGetMaterialTextureCount(
    ffi.Pointer<aiMaterial> pMat,
    int type,
  ) {
    return _aiGetMaterialTextureCount(
      pMat,
      type,
    );
  }

  late final _aiGetMaterialTextureCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<aiMaterial>,
              ffi.Int32)>>('aiGetMaterialTextureCount');
  late final _aiGetMaterialTextureCount = _aiGetMaterialTextureCountPtr
      .asFunction<int Function(ffi.Pointer<aiMaterial>, int)>();

  int aiGetMaterialTexture(
    ffi.Pointer<aiMaterial> mat,
    int type,
    int index,
    ffi.Pointer<aiString> path,
    ffi.Pointer<ffi.Int32> mapping,
    ffi.Pointer<ffi.UnsignedInt> uvindex,
    ffi.Pointer<ai_real> blend,
    ffi.Pointer<ffi.Int32> op,
    ffi.Pointer<ffi.Int32> mapmode,
    ffi.Pointer<ffi.UnsignedInt> flags,
  ) {
    return _aiGetMaterialTexture(
      mat,
      type,
      index,
      path,
      mapping,
      uvindex,
      blend,
      op,
      mapmode,
      flags,
    );
  }

  late final _aiGetMaterialTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiMaterial>,
              ffi.Int32,
              ffi.UnsignedInt,
              ffi.Pointer<aiString>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ai_real>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialTexture');
  late final _aiGetMaterialTexture = _aiGetMaterialTexturePtr.asFunction<
      int Function(
          ffi.Pointer<aiMaterial>,
          int,
          int,
          ffi.Pointer<aiString>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ai_real>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Returns the number of export file formats available in the current Assimp build.
  /// Use aiGetExportFormatDescription() to retrieve infos of a specific export format.
  int aiGetExportFormatCount() {
    return _aiGetExportFormatCount();
  }

  late final _aiGetExportFormatCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'aiGetExportFormatCount');
  late final _aiGetExportFormatCount =
      _aiGetExportFormatCountPtr.asFunction<int Function()>();

  /// Returns a description of the nth export file format. Use #aiGetExportFormatCount()
  /// to learn how many export formats are supported. The description must be released by
  /// calling aiReleaseExportFormatDescription afterwards.
  /// @param pIndex Index of the export format to retrieve information for. Valid range is
  /// 0 to #aiGetExportFormatCount()
  /// @return A description of that specific export format. NULL if pIndex is out of range.
  ffi.Pointer<aiExportFormatDesc> aiGetExportFormatDescription(
    int pIndex,
  ) {
    return _aiGetExportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetExportFormatDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiExportFormatDesc> Function(
              ffi.Size)>>('aiGetExportFormatDescription');
  late final _aiGetExportFormatDescription = _aiGetExportFormatDescriptionPtr
      .asFunction<ffi.Pointer<aiExportFormatDesc> Function(int)>();

  /// Release a description of the nth export file format. Must be returned by
  /// aiGetExportFormatDescription
  /// @param desc Pointer to the description
  void aiReleaseExportFormatDescription(
    ffi.Pointer<aiExportFormatDesc> desc,
  ) {
    return _aiReleaseExportFormatDescription(
      desc,
    );
  }

  late final _aiReleaseExportFormatDescriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<aiExportFormatDesc>)>>(
      'aiReleaseExportFormatDescription');
  late final _aiReleaseExportFormatDescription =
      _aiReleaseExportFormatDescriptionPtr
          .asFunction<void Function(ffi.Pointer<aiExportFormatDesc>)>();

  /// Create a modifiable copy of a scene.
  /// This is useful to import files via Assimp, change their topology and
  /// export them again. Since the scene returned by the various importer functions
  /// is const, a modifiable copy is needed.
  /// @param pIn Valid scene to be copied
  /// @param pOut Receives a modifiable copy of the scene. Use aiFreeScene() to
  /// delete it again.
  void aiCopyScene(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<ffi.Pointer<aiScene>> pOut,
  ) {
    return _aiCopyScene(
      pIn,
      pOut,
    );
  }

  late final _aiCopyScenePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Pointer<aiScene>>)>>('aiCopyScene');
  late final _aiCopyScene = _aiCopyScenePtr.asFunction<
      void Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Pointer<aiScene>>)>();

  /// Frees a scene copy created using aiCopyScene()
  void aiFreeScene(
    ffi.Pointer<aiScene> pIn,
  ) {
    return _aiFreeScene(
      pIn,
    );
  }

  late final _aiFreeScenePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiScene>)>>(
          'aiFreeScene');
  late final _aiFreeScene =
      _aiFreeScenePtr.asFunction<void Function(ffi.Pointer<aiScene>)>();

  /// Exports the given scene to a chosen file format and writes the result file(s) to disk.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// The scene is expected to conform to Assimp's Importer output format as specified
  /// in the @link data Data Structures Page @endlink. In short, this means the model data
  /// should use a right-handed coordinate systems, face winding should be counter-clockwise
  /// and the UV coordinate origin is assumed to be in the upper left. If your input data
  /// uses different conventions, have a look at the last parameter.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated
  /// flags, but in reality only a subset of them makes sense here. Specifying
  /// 'preprocessing' flags is useful if the input scene does not conform to
  /// Assimp's default conventions as specified in the @link data Data Structures Page @endlink.
  /// In short, this means the geometry data should use a right-handed coordinate systems, face
  /// winding should be counter-clockwise and the UV coordinate origin is assumed to be in
  /// the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder flags are used in the import side to allow users
  /// to have those defaults automatically adapted to their conventions. Specifying those flags
  /// for exporting has the opposite effect, respectively. Some other of the
  /// #aiPostProcessSteps enumerated values may be useful as well, but you'll need
  /// to try out what their effect on the exported file is. Many formats impose
  /// their own restrictions on the structure of the geometry stored therein,
  /// so some preprocessing may have little or no effect at all, or may be
  /// redundant as exporters would apply them anyhow. A good example
  /// is triangulation - whilst you can enforce it by specifying
  /// the #aiProcess_Triangulate flag, most export formats support only
  /// triangulate data so they would run the step anyway.
  ///
  /// If assimp detects that the input scene was directly taken from the importer side of
  /// the library (i.e. not copied using aiCopyScene and potentially modified afterwards),
  /// any post-processing steps already applied to the scene will not be applied again, unless
  /// they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder).
  /// @return a status code indicating the result of the export
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  int aiExportScene(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    ffi.Pointer<ffi.Char> pFileName,
    int pPreprocessing,
  ) {
    return _aiExportScene(
      pScene,
      pFormatId,
      pFileName,
      pPreprocessing,
    );
  }

  late final _aiExportScenePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiExportScene');
  late final _aiExportScene = _aiExportScenePtr.asFunction<
      int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Exports the given scene to a chosen file format using custom IO logic supplied by you.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pIO custom IO implementation to be used. Use this if you use your own storage methods.
  /// If none is supplied, a default implementation using standard file IO is used. Note that
  /// #aiExportSceneToBlob is provided as convenience function to export to memory buffers.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return a status code indicating the result of the export
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  int aiExportSceneEx(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    ffi.Pointer<ffi.Char> pFileName,
    ffi.Pointer<aiFileIO> pIO,
    int pPreprocessing,
  ) {
    return _aiExportSceneEx(
      pScene,
      pFormatId,
      pFileName,
      pIO,
      pPreprocessing,
    );
  }

  late final _aiExportSceneExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiFileIO>,
              ffi.UnsignedInt)>>('aiExportSceneEx');
  late final _aiExportSceneEx = _aiExportSceneExPtr.asFunction<
      int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<aiFileIO>, int)>();

  /// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which
  /// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()
  /// to free the resources associated with the export.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return the exported data or NULL in case of error
  ffi.Pointer<aiExportDataBlob> aiExportSceneToBlob(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    int pPreprocessing,
  ) {
    return _aiExportSceneToBlob(
      pScene,
      pFormatId,
      pPreprocessing,
    );
  }

  late final _aiExportSceneToBlobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiExportDataBlob> Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiExportSceneToBlob');
  late final _aiExportSceneToBlob = _aiExportSceneToBlobPtr.asFunction<
      ffi.Pointer<aiExportDataBlob> Function(
          ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>, int)>();

  /// Releases the memory associated with the given exported data. Use this function to free a data blob
  /// returned by aiExportScene().
  /// @param pData the data blob returned by #aiExportSceneToBlob
  void aiReleaseExportBlob(
    ffi.Pointer<aiExportDataBlob> pData,
  ) {
    return _aiReleaseExportBlob(
      pData,
    );
  }

  late final _aiReleaseExportBlobPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiExportDataBlob>)>>(
      'aiReleaseExportBlob');
  late final _aiReleaseExportBlob = _aiReleaseExportBlobPtr
      .asFunction<void Function(ffi.Pointer<aiExportDataBlob>)>();

  ffi.Pointer<aiImporterDesc> aiGetImporterDesc(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _aiGetImporterDesc(
      extension1,
    );
  }

  late final _aiGetImporterDescPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiImporterDesc> Function(
              ffi.Pointer<ffi.Char>)>>('aiGetImporterDesc');
  late final _aiGetImporterDesc = _aiGetImporterDescPtr.asFunction<
      ffi.Pointer<aiImporterDesc> Function(ffi.Pointer<ffi.Char>)>();

  /// Reads the given file and returns its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @return Pointer to the imported data or NULL if the import failed.
  ffi.Pointer<aiScene> aiImportFile(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
  ) {
    return _aiImportFile(
      pFile,
      pFlags,
    );
  }

  late final _aiImportFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiImportFile');
  late final _aiImportFile = _aiImportFilePtr
      .asFunction<ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Reads the given file using user-defined I/O functions and returns
  /// its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  ffi.Pointer<aiScene> aiImportFileEx(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
  ) {
    return _aiImportFileEx(
      pFile,
      pFlags,
      pFS,
    );
  }

  late final _aiImportFileExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              ffi.Pointer<aiFileIO>)>>('aiImportFileEx');
  late final _aiImportFileEx = _aiImportFileExPtr.asFunction<
      ffi.Pointer<aiScene> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<aiFileIO>)>();

  /// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.
  ///
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @see aiImportFileEx
  ffi.Pointer<aiScene> aiImportFileExWithProperties(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileExWithProperties(
      pFile,
      pFlags,
      pFS,
      pProps,
    );
  }

  late final _aiImportFileExWithPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<aiFileIO>,
              ffi.Pointer<aiPropertyStore>)>>('aiImportFileExWithProperties');
  late final _aiImportFileExWithProperties =
      _aiImportFileExWithPropertiesPtr.asFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<aiFileIO>, ffi.Pointer<aiPropertyStore>)>();

  /// Reads the given file from a given memory buffer,
  ///
  /// If the call succeeds, the contents of the file are returned as a pointer to an
  /// aiScene object. The returned data is intended to be read-only, the importer keeps
  /// ownership of the data and will destroy it upon destruction. If the import fails,
  /// NULL is returned.
  /// A human-readable error description can be retrieved by calling aiGetErrorString().
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  ffi.Pointer<aiScene> aiImportFileFromMemory(
    ffi.Pointer<ffi.Char> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Char> pHint,
  ) {
    return _aiImportFileFromMemory(
      pBuffer,
      pLength,
      pFlags,
      pHint,
    );
  }

  late final _aiImportFileFromMemoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('aiImportFileFromMemory');
  late final _aiImportFileFromMemory = _aiImportFileFromMemoryPtr.asFunction<
      ffi.Pointer<aiScene> Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>)>();

  /// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.
  ///
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  /// @see aiImportFileFromMemory
  ffi.Pointer<aiScene> aiImportFileFromMemoryWithProperties(
    ffi.Pointer<ffi.Char> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Char> pHint,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileFromMemoryWithProperties(
      pBuffer,
      pLength,
      pFlags,
      pHint,
      pProps,
    );
  }

  late final _aiImportFileFromMemoryWithPropertiesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<aiScene> Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedInt,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<aiPropertyStore>)>>(
      'aiImportFileFromMemoryWithProperties');
  late final _aiImportFileFromMemoryWithProperties =
      _aiImportFileFromMemoryWithPropertiesPtr.asFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<aiPropertyStore>)>();

  /// Apply post-processing to an already-imported scene.
  ///
  /// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the
  /// same flags. However, you can use this separate function to inspect the imported
  /// scene first to fine-tune your post-processing setup.
  /// @param pScene Scene to work on.
  /// @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.
  /// @return A pointer to the post-processed data. Post processing is done in-place,
  /// meaning this is still the same #aiScene which you passed for pScene. However,
  /// _if_ post-processing failed, the scene could now be NULL. That's quite a rare
  /// case, post processing steps are not really designed to 'fail'. To be exact,
  /// the #aiProcess_ValidateDataStructure flag is currently the only post processing step
  /// which can actually cause the scene to be reset to NULL.
  ffi.Pointer<aiScene> aiApplyPostProcessing(
    ffi.Pointer<aiScene> pScene,
    int pFlags,
  ) {
    return _aiApplyPostProcessing(
      pScene,
      pFlags,
    );
  }

  late final _aiApplyPostProcessingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<aiScene>, ffi.UnsignedInt)>>('aiApplyPostProcessing');
  late final _aiApplyPostProcessing = _aiApplyPostProcessingPtr
      .asFunction<ffi.Pointer<aiScene> Function(ffi.Pointer<aiScene>, int)>();

  /// Get one of the predefine log streams. This is the quick'n'easy solution to
  /// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's
  /// overall import performance.
  ///
  /// Usage is rather simple (this will stream the log to a file, named log.txt, and
  /// the stdout stream of the process:
  /// @code
  /// struct aiLogStream c;
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,"log.txt");
  /// aiAttachLogStream(&c);
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
  /// aiAttachLogStream(&c);
  /// @endcode
  ///
  /// @param pStreams One of the #aiDefaultLogStream enumerated values.
  /// @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.
  /// Pass NULL for all other flags.
  /// @return The log stream. callback is set to NULL if something went wrong.
  aiLogStream aiGetPredefinedLogStream(
    int pStreams,
    ffi.Pointer<ffi.Char> file,
  ) {
    return _aiGetPredefinedLogStream(
      pStreams,
      file,
    );
  }

  late final _aiGetPredefinedLogStreamPtr = _lookup<
      ffi.NativeFunction<
          aiLogStream Function(
              ffi.Int32, ffi.Pointer<ffi.Char>)>>('aiGetPredefinedLogStream');
  late final _aiGetPredefinedLogStream = _aiGetPredefinedLogStreamPtr
      .asFunction<aiLogStream Function(int, ffi.Pointer<ffi.Char>)>();

  /// Attach a custom log stream to the libraries' logging system.
  ///
  /// Attaching a log stream can slightly reduce Assimp's overall import
  /// performance. Multiple log-streams can be attached.
  /// @param stream Describes the new log stream.
  /// @note To ensure proper destruction of the logging system, you need to manually
  /// call aiDetachLogStream() on every single log stream you attach.
  /// Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.
  void aiAttachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiAttachLogStream(
      stream,
    );
  }

  late final _aiAttachLogStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiLogStream>)>>(
          'aiAttachLogStream');
  late final _aiAttachLogStream = _aiAttachLogStreamPtr
      .asFunction<void Function(ffi.Pointer<aiLogStream>)>();

  /// Enable verbose logging. Verbose logging includes debug-related stuff and
  /// detailed import statistics. This can have severe impact on import performance
  /// and memory consumption. However, it might be useful to find out why a file
  /// didn't read correctly.
  /// @param d AI_TRUE or AI_FALSE, your decision.
  void aiEnableVerboseLogging(
    int d,
  ) {
    return _aiEnableVerboseLogging(
      d,
    );
  }

  late final _aiEnableVerboseLoggingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(aiBool)>>(
          'aiEnableVerboseLogging');
  late final _aiEnableVerboseLogging =
      _aiEnableVerboseLoggingPtr.asFunction<void Function(int)>();

  /// Detach a custom log stream from the libraries' logging system.
  ///
  /// This is the counterpart of #aiAttachLogStream. If you attached a stream,
  /// don't forget to detach it again.
  /// @param stream The log stream to be detached.
  /// @return AI_SUCCESS if the log stream has been detached successfully.
  /// @see aiDetachAllLogStreams
  int aiDetachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiDetachLogStream(
      stream,
    );
  }

  late final _aiDetachLogStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<aiLogStream>)>>(
          'aiDetachLogStream');
  late final _aiDetachLogStream = _aiDetachLogStreamPtr
      .asFunction<int Function(ffi.Pointer<aiLogStream>)>();

  /// Detach all active log streams from the libraries' logging system.
  /// This ensures that the logging system is terminated properly and all
  /// resources allocated by it are actually freed. If you attached a stream,
  /// don't forget to detach it again.
  /// @see aiAttachLogStream
  /// @see aiDetachLogStream
  void aiDetachAllLogStreams() {
    return _aiDetachAllLogStreams();
  }

  late final _aiDetachAllLogStreamsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aiDetachAllLogStreams');
  late final _aiDetachAllLogStreams =
      _aiDetachAllLogStreamsPtr.asFunction<void Function()>();

  /// Releases all resources associated with the given import process.
  ///
  /// Call this function after you're done with the imported data.
  /// @param pScene The imported data to release. NULL is a valid value.
  void aiReleaseImport(
    ffi.Pointer<aiScene> pScene,
  ) {
    return _aiReleaseImport(
      pScene,
    );
  }

  late final _aiReleaseImportPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiScene>)>>(
          'aiReleaseImport');
  late final _aiReleaseImport =
      _aiReleaseImportPtr.asFunction<void Function(ffi.Pointer<aiScene>)>();

  /// Returns the error text of the last failed import process.
  ///
  /// @return A textual description of the error that occurred at the last
  /// import process. NULL if there was no error. There can't be an error if you
  /// got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.
  ffi.Pointer<ffi.Char> aiGetErrorString() {
    return _aiGetErrorString();
  }

  late final _aiGetErrorStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetErrorString');
  late final _aiGetErrorString =
      _aiGetErrorStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Returns whether a given file extension is supported by ASSIMP
  ///
  /// @param szExtension Extension for which the function queries support for.
  /// Must include a leading dot '.'. Example: ".3ds", ".md3"
  /// @return AI_TRUE if the file extension is supported.
  int aiIsExtensionSupported(
    ffi.Pointer<ffi.Char> szExtension,
  ) {
    return _aiIsExtensionSupported(
      szExtension,
    );
  }

  late final _aiIsExtensionSupportedPtr =
      _lookup<ffi.NativeFunction<aiBool Function(ffi.Pointer<ffi.Char>)>>(
          'aiIsExtensionSupported');
  late final _aiIsExtensionSupported = _aiIsExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a list of all file extensions supported by ASSIMP.
  ///
  /// If a file extension is contained in the list this does, of course, not
  /// mean that ASSIMP is able to load all files with this extension.
  /// @param szOut String to receive the extension list.
  /// Format of the list: "*.3ds;*.obj;*.dae". NULL is not a valid parameter.
  void aiGetExtensionList(
    ffi.Pointer<aiString> szOut,
  ) {
    return _aiGetExtensionList(
      szOut,
    );
  }

  late final _aiGetExtensionListPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiString>)>>(
          'aiGetExtensionList');
  late final _aiGetExtensionList =
      _aiGetExtensionListPtr.asFunction<void Function(ffi.Pointer<aiString>)>();

  /// Get the approximated storage required by an imported asset
  /// @param pIn Input asset.
  /// @param in Data structure to be filled.
  void aiGetMemoryRequirements(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<aiMemoryInfo> in1,
  ) {
    return _aiGetMemoryRequirements(
      pIn,
      in1,
    );
  }

  late final _aiGetMemoryRequirementsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiScene>,
              ffi.Pointer<aiMemoryInfo>)>>('aiGetMemoryRequirements');
  late final _aiGetMemoryRequirements = _aiGetMemoryRequirementsPtr.asFunction<
      void Function(ffi.Pointer<aiScene>, ffi.Pointer<aiMemoryInfo>)>();

  /// Create an empty property store. Property stores are used to collect import
  /// settings.
  /// @return New property store. Property stores need to be manually destroyed using
  /// the #aiReleasePropertyStore API function.
  ffi.Pointer<aiPropertyStore> aiCreatePropertyStore() {
    return _aiCreatePropertyStore();
  }

  late final _aiCreatePropertyStorePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aiPropertyStore> Function()>>(
          'aiCreatePropertyStore');
  late final _aiCreatePropertyStore = _aiCreatePropertyStorePtr
      .asFunction<ffi.Pointer<aiPropertyStore> Function()>();

  /// Delete a property store.
  /// @param p Property store to be deleted.
  void aiReleasePropertyStore(
    ffi.Pointer<aiPropertyStore> p,
  ) {
    return _aiReleasePropertyStore(
      p,
    );
  }

  late final _aiReleasePropertyStorePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiPropertyStore>)>>(
      'aiReleasePropertyStore');
  late final _aiReleasePropertyStore = _aiReleasePropertyStorePtr
      .asFunction<void Function(ffi.Pointer<aiPropertyStore>)>();

  /// Set an integer property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyInteger(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    int value,
  ) {
    return _aiSetImportPropertyInteger(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyIntegerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('aiSetImportPropertyInteger');
  late final _aiSetImportPropertyInteger =
      _aiSetImportPropertyIntegerPtr.asFunction<
          void Function(
              ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>, int)>();

  /// Set a floating-point property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyFloat(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    double value,
  ) {
    return _aiSetImportPropertyFloat(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyFloatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ai_real)>>('aiSetImportPropertyFloat');
  late final _aiSetImportPropertyFloat =
      _aiSetImportPropertyFloatPtr.asFunction<
          void Function(
              ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>, double)>();

  /// Set a string property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param st New value for the property
  void aiSetImportPropertyString(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    ffi.Pointer<aiString> st,
  ) {
    return _aiSetImportPropertyString(
      store,
      szName,
      st,
    );
  }

  late final _aiSetImportPropertyStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiString>)>>('aiSetImportPropertyString');
  late final _aiSetImportPropertyString =
      _aiSetImportPropertyStringPtr.asFunction<
          void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiString>)>();

  /// Set a matrix property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param mat New value for the property
  void aiSetImportPropertyMatrix(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiSetImportPropertyMatrix(
      store,
      szName,
      mat,
    );
  }

  late final _aiSetImportPropertyMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiMatrix4x4>)>>('aiSetImportPropertyMatrix');
  late final _aiSetImportPropertyMatrix =
      _aiSetImportPropertyMatrixPtr.asFunction<
          void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiMatrix4x4>)>();

  /// Construct a quaternion from a 3x3 rotation matrix.
  /// @param quat Receives the output quaternion.
  /// @param mat Matrix to 'quaternionize'.
  /// @see aiQuaternion(const aiMatrix3x3& pRotMatrix)
  void aiCreateQuaternionFromMatrix(
    ffi.Pointer<aiQuaternion> quat,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiCreateQuaternionFromMatrix(
      quat,
      mat,
    );
  }

  late final _aiCreateQuaternionFromMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiMatrix3x3>)>>('aiCreateQuaternionFromMatrix');
  late final _aiCreateQuaternionFromMatrix =
      _aiCreateQuaternionFromMatrixPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiMatrix3x3>)>();

  /// Decompose a transformation matrix into its rotational, translational and
  /// scaling components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the scaling component
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  /// @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;
  void aiDecomposeMatrix(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiDecomposeMatrix(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiDecomposeMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>>('aiDecomposeMatrix');
  late final _aiDecomposeMatrix = _aiDecomposeMatrixPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Transpose a 4x4 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransposeMatrix4(
      mat,
    );
  }

  late final _aiTransposeMatrix4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiTransposeMatrix4');
  late final _aiTransposeMatrix4 = _aiTransposeMatrix4Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Transpose a 3x3 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransposeMatrix3(
      mat,
    );
  }

  late final _aiTransposeMatrix3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiTransposeMatrix3');
  late final _aiTransposeMatrix3 = _aiTransposeMatrix3Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Transform a vector by a 3x3 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix3(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransformVecByMatrix3(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiMatrix3x3>)>>('aiTransformVecByMatrix3');
  late final _aiTransformVecByMatrix3 = _aiTransformVecByMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiMatrix3x3>)>();

  /// Transform a vector by a 4x4 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix4(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransformVecByMatrix4(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiMatrix4x4>)>>('aiTransformVecByMatrix4');
  late final _aiTransformVecByMatrix4 = _aiTransformVecByMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiMatrix4x4>)>();

  /// Multiply two 4x4 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix4(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMultiplyMatrix4(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMultiplyMatrix4');
  late final _aiMultiplyMatrix4 = _aiMultiplyMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Multiply two 3x3 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix3(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix3x3> src,
  ) {
    return _aiMultiplyMatrix3(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMultiplyMatrix3');
  late final _aiMultiplyMatrix3 = _aiMultiplyMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 3x3 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiIdentityMatrix3(
      mat,
    );
  }

  late final _aiIdentityMatrix3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiIdentityMatrix3');
  late final _aiIdentityMatrix3 = _aiIdentityMatrix3Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 4x4 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiIdentityMatrix4(
      mat,
    );
  }

  late final _aiIdentityMatrix4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiIdentityMatrix4');
  late final _aiIdentityMatrix4 = _aiIdentityMatrix4Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Returns the number of import file formats available in the current Assimp build.
  /// Use aiGetImportFormatDescription() to retrieve infos of a specific import format.
  int aiGetImportFormatCount() {
    return _aiGetImportFormatCount();
  }

  late final _aiGetImportFormatCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'aiGetImportFormatCount');
  late final _aiGetImportFormatCount =
      _aiGetImportFormatCountPtr.asFunction<int Function()>();

  /// Returns a description of the nth import file format. Use #aiGetImportFormatCount()
  /// to learn how many import formats are supported.
  /// @param pIndex Index of the import format to retrieve information for. Valid range is
  /// 0 to #aiGetImportFormatCount()
  /// @return A description of that specific import format. NULL if pIndex is out of range.
  ffi.Pointer<aiImporterDesc> aiGetImportFormatDescription(
    int pIndex,
  ) {
    return _aiGetImportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetImportFormatDescriptionPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<aiImporterDesc> Function(ffi.Size)>>(
      'aiGetImportFormatDescription');
  late final _aiGetImportFormatDescription = _aiGetImportFormatDescriptionPtr
      .asFunction<ffi.Pointer<aiImporterDesc> Function(int)>();

  /// Check if 2D vectors are equal.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector2AreEqual(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
  ) {
    return _aiVector2AreEqual(
      a,
      b,
    );
  }

  late final _aiVector2AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2AreEqual');
  late final _aiVector2AreEqual = _aiVector2AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Check if 2D vectors are equal using epsilon.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector2AreEqualEpsilon(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
    double epsilon,
  ) {
    return _aiVector2AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiVector2AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>,
              ffi.Float)>>('aiVector2AreEqualEpsilon');
  late final _aiVector2AreEqualEpsilon =
      _aiVector2AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>, double)>();

  /// Add 2D vectors.
  /// @param dst First addend, receives result.
  /// @param src Vector to be added to 'dst'.
  void aiVector2Add(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> src,
  ) {
    return _aiVector2Add(
      dst,
      src,
    );
  }

  late final _aiVector2AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2Add');
  late final _aiVector2Add = _aiVector2AddPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Subtract 2D vectors.
  /// @param dst Minuend, receives result.
  /// @param src Vector to be subtracted from 'dst'.
  void aiVector2Subtract(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> src,
  ) {
    return _aiVector2Subtract(
      dst,
      src,
    );
  }

  late final _aiVector2SubtractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2Subtract');
  late final _aiVector2Subtract = _aiVector2SubtractPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Multiply a 2D vector by a scalar.
  /// @param dst Vector to be scaled by \p s
  /// @param s Scale factor
  void aiVector2Scale(
    ffi.Pointer<aiVector2D> dst,
    double s,
  ) {
    return _aiVector2Scale(
      dst,
      s,
    );
  }

  late final _aiVector2ScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector2D>, ffi.Float)>>('aiVector2Scale');
  late final _aiVector2Scale = _aiVector2ScalePtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>, double)>();

  /// Multiply each component of a 2D vector with
  /// the components of another vector.
  /// @param dst First vector, receives result
  /// @param other Second vector
  void aiVector2SymMul(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> other,
  ) {
    return _aiVector2SymMul(
      dst,
      other,
    );
  }

  late final _aiVector2SymMulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2SymMul');
  late final _aiVector2SymMul = _aiVector2SymMulPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Divide a 2D vector by a scalar.
  /// @param dst Vector to be divided by \p s
  /// @param s Scalar divisor
  void aiVector2DivideByScalar(
    ffi.Pointer<aiVector2D> dst,
    double s,
  ) {
    return _aiVector2DivideByScalar(
      dst,
      s,
    );
  }

  late final _aiVector2DivideByScalarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector2D>, ffi.Float)>>('aiVector2DivideByScalar');
  late final _aiVector2DivideByScalar = _aiVector2DivideByScalarPtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>, double)>();

  /// Divide each component of a 2D vector by
  /// the components of another vector.
  /// @param dst Vector as the dividend
  /// @param v Vector as the divisor
  void aiVector2DivideByVector(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2DivideByVector(
      dst,
      v,
    );
  }

  late final _aiVector2DivideByVectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2DivideByVector');
  late final _aiVector2DivideByVector = _aiVector2DivideByVectorPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Get the length of a 2D vector.
  /// @return v Vector to evaluate
  double aiVector2Length(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2Length(
      v,
    );
  }

  late final _aiVector2LengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Length');
  late final _aiVector2Length = _aiVector2LengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector2D>)>();

  /// Get the squared length of a 2D vector.
  /// @return v Vector to evaluate
  double aiVector2SquareLength(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2SquareLength(
      v,
    );
  }

  late final _aiVector2SquareLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2SquareLength');
  late final _aiVector2SquareLength = _aiVector2SquareLengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector2D>)>();

  /// Negate a 2D vector.
  /// @param dst Vector to be negated
  void aiVector2Negate(
    ffi.Pointer<aiVector2D> dst,
  ) {
    return _aiVector2Negate(
      dst,
    );
  }

  late final _aiVector2NegatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Negate');
  late final _aiVector2Negate =
      _aiVector2NegatePtr.asFunction<void Function(ffi.Pointer<aiVector2D>)>();

  /// Get the dot product of 2D vectors.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  double aiVector2DotProduct(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
  ) {
    return _aiVector2DotProduct(
      a,
      b,
    );
  }

  late final _aiVector2DotProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2DotProduct');
  late final _aiVector2DotProduct = _aiVector2DotProductPtr.asFunction<
      double Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Normalize a 2D vector.
  /// @param v Vector to normalize
  void aiVector2Normalize(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2Normalize(
      v,
    );
  }

  late final _aiVector2NormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Normalize');
  late final _aiVector2Normalize = _aiVector2NormalizePtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>)>();

  /// Check if 3D vectors are equal.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector3AreEqual(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3AreEqual(
      a,
      b,
    );
  }

  late final _aiVector3AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3AreEqual');
  late final _aiVector3AreEqual = _aiVector3AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Check if 3D vectors are equal using epsilon.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector3AreEqualEpsilon(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
    double epsilon,
  ) {
    return _aiVector3AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiVector3AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiVector3AreEqualEpsilon');
  late final _aiVector3AreEqualEpsilon =
      _aiVector3AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>, double)>();

  /// Check if vector \p a is less than vector \p b.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if \p a is less than \p b
  /// @return 0 if \p a is equal or greater than \p b
  int aiVector3LessThan(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3LessThan(
      a,
      b,
    );
  }

  late final _aiVector3LessThanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3LessThan');
  late final _aiVector3LessThan = _aiVector3LessThanPtr.asFunction<
      int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Add 3D vectors.
  /// @param dst First addend, receives result.
  /// @param src Vector to be added to 'dst'.
  void aiVector3Add(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> src,
  ) {
    return _aiVector3Add(
      dst,
      src,
    );
  }

  late final _aiVector3AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3Add');
  late final _aiVector3Add = _aiVector3AddPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Subtract 3D vectors.
  /// @param dst Minuend, receives result.
  /// @param src Vector to be subtracted from 'dst'.
  void aiVector3Subtract(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> src,
  ) {
    return _aiVector3Subtract(
      dst,
      src,
    );
  }

  late final _aiVector3SubtractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3Subtract');
  late final _aiVector3Subtract = _aiVector3SubtractPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Multiply a 3D vector by a scalar.
  /// @param dst Vector to be scaled by \p s
  /// @param s Scale factor
  void aiVector3Scale(
    ffi.Pointer<aiVector3D> dst,
    double s,
  ) {
    return _aiVector3Scale(
      dst,
      s,
    );
  }

  late final _aiVector3ScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector3D>, ffi.Float)>>('aiVector3Scale');
  late final _aiVector3Scale = _aiVector3ScalePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>, double)>();

  /// Multiply each component of a 3D vector with
  /// the components of another vector.
  /// @param dst First vector, receives result
  /// @param other Second vector
  void aiVector3SymMul(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> other,
  ) {
    return _aiVector3SymMul(
      dst,
      other,
    );
  }

  late final _aiVector3SymMulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3SymMul');
  late final _aiVector3SymMul = _aiVector3SymMulPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Divide a 3D vector by a scalar.
  /// @param dst Vector to be divided by \p s
  /// @param s Scalar divisor
  void aiVector3DivideByScalar(
    ffi.Pointer<aiVector3D> dst,
    double s,
  ) {
    return _aiVector3DivideByScalar(
      dst,
      s,
    );
  }

  late final _aiVector3DivideByScalarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector3D>, ffi.Float)>>('aiVector3DivideByScalar');
  late final _aiVector3DivideByScalar = _aiVector3DivideByScalarPtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>, double)>();

  /// Divide each component of a 3D vector by
  /// the components of another vector.
  /// @param dst Vector as the dividend
  /// @param v Vector as the divisor
  void aiVector3DivideByVector(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3DivideByVector(
      dst,
      v,
    );
  }

  late final _aiVector3DivideByVectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3DivideByVector');
  late final _aiVector3DivideByVector = _aiVector3DivideByVectorPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Get the length of a 3D vector.
  /// @return v Vector to evaluate
  double aiVector3Length(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3Length(
      v,
    );
  }

  late final _aiVector3LengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Length');
  late final _aiVector3Length = _aiVector3LengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector3D>)>();

  /// Get the squared length of a 3D vector.
  /// @return v Vector to evaluate
  double aiVector3SquareLength(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3SquareLength(
      v,
    );
  }

  late final _aiVector3SquareLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3SquareLength');
  late final _aiVector3SquareLength = _aiVector3SquareLengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector3D>)>();

  /// Negate a 3D vector.
  /// @param dst Vector to be negated
  void aiVector3Negate(
    ffi.Pointer<aiVector3D> dst,
  ) {
    return _aiVector3Negate(
      dst,
    );
  }

  late final _aiVector3NegatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Negate');
  late final _aiVector3Negate =
      _aiVector3NegatePtr.asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Get the dot product of 3D vectors.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  double aiVector3DotProduct(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3DotProduct(
      a,
      b,
    );
  }

  late final _aiVector3DotProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3DotProduct');
  late final _aiVector3DotProduct = _aiVector3DotProductPtr.asFunction<
      double Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Get cross product of 3D vectors.
  /// @param dst Vector to receive the result.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  void aiVector3CrossProduct(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3CrossProduct(
      dst,
      a,
      b,
    );
  }

  late final _aiVector3CrossProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3CrossProduct');
  late final _aiVector3CrossProduct = _aiVector3CrossProductPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Normalize a 3D vector.
  /// @param v Vector to normalize
  void aiVector3Normalize(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3Normalize(
      v,
    );
  }

  late final _aiVector3NormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Normalize');
  late final _aiVector3Normalize = _aiVector3NormalizePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Check for division by zero and normalize a 3D vector.
  /// @param v Vector to normalize
  void aiVector3NormalizeSafe(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3NormalizeSafe(
      v,
    );
  }

  late final _aiVector3NormalizeSafePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3NormalizeSafe');
  late final _aiVector3NormalizeSafe = _aiVector3NormalizeSafePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Rotate a 3D vector by a quaternion.
  /// @param v The vector to rotate by \p q
  /// @param q Quaternion to use to rotate \p v
  void aiVector3RotateByQuaternion(
    ffi.Pointer<aiVector3D> v,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiVector3RotateByQuaternion(
      v,
      q,
    );
  }

  late final _aiVector3RotateByQuaternionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>)>>('aiVector3RotateByQuaternion');
  late final _aiVector3RotateByQuaternion =
      _aiVector3RotateByQuaternionPtr.asFunction<
          void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiQuaternion>)>();

  /// Construct a 3x3 matrix from a 4x4 matrix.
  /// @param dst Receives the output matrix
  /// @param mat The 4x4 matrix to use
  void aiMatrix3FromMatrix4(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix3FromMatrix4(
      dst,
      mat,
    );
  }

  late final _aiMatrix3FromMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix3FromMatrix4');
  late final _aiMatrix3FromMatrix4 = _aiMatrix3FromMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix4x4>)>();

  /// Construct a 3x3 matrix from a quaternion.
  /// @param mat Receives the output matrix
  /// @param q The quaternion matrix to use
  void aiMatrix3FromQuaternion(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiMatrix3FromQuaternion(
      mat,
      q,
    );
  }

  late final _aiMatrix3FromQuaternionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiQuaternion>)>>('aiMatrix3FromQuaternion');
  late final _aiMatrix3FromQuaternion = _aiMatrix3FromQuaternionPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiQuaternion>)>();

  /// Check if 3x3 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix3AreEqual(
    ffi.Pointer<aiMatrix3x3> a,
    ffi.Pointer<aiMatrix3x3> b,
  ) {
    return _aiMatrix3AreEqual(
      a,
      b,
    );
  }

  late final _aiMatrix3AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMatrix3AreEqual');
  late final _aiMatrix3AreEqual = _aiMatrix3AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>)>();

  /// Check if 3x3 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @param epsilon Epsilon
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix3AreEqualEpsilon(
    ffi.Pointer<aiMatrix3x3> a,
    ffi.Pointer<aiMatrix3x3> b,
    double epsilon,
  ) {
    return _aiMatrix3AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiMatrix3AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>,
              ffi.Float)>>('aiMatrix3AreEqualEpsilon');
  late final _aiMatrix3AreEqualEpsilon =
      _aiMatrix3AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>, double)>();

  /// Invert a 3x3 matrix.
  /// @param mat Matrix to invert
  void aiMatrix3Inverse(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix3Inverse(
      mat,
    );
  }

  late final _aiMatrix3InversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiMatrix3Inverse');
  late final _aiMatrix3Inverse = _aiMatrix3InversePtr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get the determinant of a 3x3 matrix.
  /// @param mat Matrix to get the determinant from
  double aiMatrix3Determinant(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix3Determinant(
      mat,
    );
  }

  late final _aiMatrix3DeterminantPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiMatrix3Determinant');
  late final _aiMatrix3Determinant = _aiMatrix3DeterminantPtr
      .asFunction<double Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 3x3 rotation matrix around the Z axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix3RotationZ(
    ffi.Pointer<aiMatrix3x3> mat,
    double angle,
  ) {
    return _aiMatrix3RotationZ(
      mat,
      angle,
    );
  }

  late final _aiMatrix3RotationZPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Float)>>('aiMatrix3RotationZ');
  late final _aiMatrix3RotationZ = _aiMatrix3RotationZPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>, double)>();

  /// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
  /// @param mat Receives the output matrix
  /// @param axis Rotation axis, should be a normalized vector
  /// @param angle Rotation angle, in radians
  void aiMatrix3FromRotationAroundAxis(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiMatrix3FromRotationAroundAxis(
      mat,
      axis,
      angle,
    );
  }

  late final _aiMatrix3FromRotationAroundAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiMatrix3FromRotationAroundAxis');
  late final _aiMatrix3FromRotationAroundAxis =
      _aiMatrix3FromRotationAroundAxisPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>, double)>();

  /// Get a 3x3 translation matrix.
  /// @param mat Receives the output matrix
  /// @param translation The translation vector
  void aiMatrix3Translation(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector2D> translation,
  ) {
    return _aiMatrix3Translation(
      mat,
      translation,
    );
  }

  late final _aiMatrix3TranslationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiVector2D>)>>('aiMatrix3Translation');
  late final _aiMatrix3Translation = _aiMatrix3TranslationPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector2D>)>();

  /// Create a 3x3 matrix that rotates one vector to another vector.
  /// @param mat Receives the output matrix
  /// @param from Vector to rotate from
  /// @param to Vector to rotate to
  void aiMatrix3FromTo(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector3D> from,
    ffi.Pointer<aiVector3D> to,
  ) {
    return _aiMatrix3FromTo(
      mat,
      from,
      to,
    );
  }

  late final _aiMatrix3FromToPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix3FromTo');
  late final _aiMatrix3FromTo = _aiMatrix3FromToPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Construct a 4x4 matrix from a 3x3 matrix.
  /// @param dst Receives the output matrix
  /// @param mat The 3x3 matrix to use
  void aiMatrix4FromMatrix3(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix4FromMatrix3(
      dst,
      mat,
    );
  }

  late final _aiMatrix4FromMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMatrix4FromMatrix3');
  late final _aiMatrix4FromMatrix3 = _aiMatrix4FromMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix3x3>)>();

  /// Construct a 4x4 matrix from scaling, rotation and position.
  /// @param mat Receives the output matrix.
  /// @param scaling The scaling for the x,y,z axes
  /// @param rotation The rotation as a hamilton quaternion
  /// @param position The position for the x,y,z axes
  void aiMatrix4FromScalingQuaternionPosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4FromScalingQuaternionPosition(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiMatrix4FromScalingQuaternionPositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiQuaternion>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4FromScalingQuaternionPosition');
  late final _aiMatrix4FromScalingQuaternionPosition =
      _aiMatrix4FromScalingQuaternionPositionPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Add 4x4 matrices.
  /// @param dst First addend, receives result.
  /// @param src Matrix to be added to 'dst'.
  void aiMatrix4Add(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMatrix4Add(
      dst,
      src,
    );
  }

  late final _aiMatrix4AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix4Add');
  late final _aiMatrix4Add = _aiMatrix4AddPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Check if 4x4 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix4AreEqual(
    ffi.Pointer<aiMatrix4x4> a,
    ffi.Pointer<aiMatrix4x4> b,
  ) {
    return _aiMatrix4AreEqual(
      a,
      b,
    );
  }

  late final _aiMatrix4AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix4AreEqual');
  late final _aiMatrix4AreEqual = _aiMatrix4AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Check if 4x4 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @param epsilon Epsilon
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix4AreEqualEpsilon(
    ffi.Pointer<aiMatrix4x4> a,
    ffi.Pointer<aiMatrix4x4> b,
    double epsilon,
  ) {
    return _aiMatrix4AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiMatrix4AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>,
              ffi.Float)>>('aiMatrix4AreEqualEpsilon');
  late final _aiMatrix4AreEqualEpsilon =
      _aiMatrix4AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>, double)>();

  /// Invert a 4x4 matrix.
  /// @param result Matrix to invert
  void aiMatrix4Inverse(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4Inverse(
      mat,
    );
  }

  late final _aiMatrix4InversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4Inverse');
  late final _aiMatrix4Inverse = _aiMatrix4InversePtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Get the determinant of a 4x4 matrix.
  /// @param mat Matrix to get the determinant from
  /// @return The determinant of the matrix
  double aiMatrix4Determinant(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4Determinant(
      mat,
    );
  }

  late final _aiMatrix4DeterminantPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4Determinant');
  late final _aiMatrix4Determinant = _aiMatrix4DeterminantPtr
      .asFunction<double Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Returns true of the matrix is the identity matrix.
  /// @param mat Matrix to get the determinant from
  /// @return 1 if \p mat is an identity matrix.
  /// @return 0 if \p mat is not an identity matrix.
  int aiMatrix4IsIdentity(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4IsIdentity(
      mat,
    );
  }

  late final _aiMatrix4IsIdentityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4IsIdentity');
  late final _aiMatrix4IsIdentity = _aiMatrix4IsIdentityPtr
      .asFunction<int Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Decompose a transformation matrix into its scaling,
  /// rotational as euler angles, and translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the output scaling for the x,y,z axes
  /// @param rotation Receives the output rotation as a Euler angles
  /// @param position Receives the output position for the x,y,z axes
  void aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiVector3D> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiMatrix4DecomposeIntoScalingEulerAnglesPositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4DecomposeIntoScalingEulerAnglesPosition');
  late final _aiMatrix4DecomposeIntoScalingEulerAnglesPosition =
      _aiMatrix4DecomposeIntoScalingEulerAnglesPositionPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Decompose a transformation matrix into its scaling,
  /// rotational split into an axis and rotational angle,
  /// and it's translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param rotation Receives the rotational component
  /// @param axis Receives the output rotation axis
  /// @param angle Receives the output rotation angle
  /// @param position Receives the output position for the x,y,z axes.
  void aiMatrix4DecomposeIntoScalingAxisAnglePosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiVector3D> axis,
    ffi.Pointer<ai_real> angle,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeIntoScalingAxisAnglePosition(
      mat,
      scaling,
      axis,
      angle,
      position,
    );
  }

  late final _aiMatrix4DecomposeIntoScalingAxisAnglePositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<ai_real>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4DecomposeIntoScalingAxisAnglePosition');
  late final _aiMatrix4DecomposeIntoScalingAxisAnglePosition =
      _aiMatrix4DecomposeIntoScalingAxisAnglePositionPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<ai_real>,
              ffi.Pointer<aiVector3D>)>();

  /// Decompose a transformation matrix into its rotational and
  /// translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  void aiMatrix4DecomposeNoScaling(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeNoScaling(
      mat,
      rotation,
      position,
    );
  }

  late final _aiMatrix4DecomposeNoScalingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4DecomposeNoScaling');
  late final _aiMatrix4DecomposeNoScaling =
      _aiMatrix4DecomposeNoScalingPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>();

  /// Creates a 4x4 matrix from a set of euler angles.
  /// @param mat Receives the output matrix
  /// @param x Rotation angle for the x-axis, in radians
  /// @param y Rotation angle for the y-axis, in radians
  /// @param z Rotation angle for the z-axis, in radians
  void aiMatrix4FromEulerAngles(
    ffi.Pointer<aiMatrix4x4> mat,
    double x,
    double y,
    double z,
  ) {
    return _aiMatrix4FromEulerAngles(
      mat,
      x,
      y,
      z,
    );
  }

  late final _aiMatrix4FromEulerAnglesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Float, ffi.Float,
              ffi.Float)>>('aiMatrix4FromEulerAngles');
  late final _aiMatrix4FromEulerAngles =
      _aiMatrix4FromEulerAnglesPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, double, double, double)>();

  /// Get a 4x4 rotation matrix around the X axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationX(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationX(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationXPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationX');
  late final _aiMatrix4RotationX = _aiMatrix4RotationXPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Get a 4x4 rotation matrix around the Y axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationY(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationY(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationYPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationY');
  late final _aiMatrix4RotationY = _aiMatrix4RotationYPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Get a 4x4 rotation matrix around the Z axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationZ(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationZ(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationZPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationZ');
  late final _aiMatrix4RotationZ = _aiMatrix4RotationZPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.
  /// @param mat Receives the output matrix
  /// @param axis Rotation axis, should be a normalized vector
  /// @param angle Rotation angle, in radians
  void aiMatrix4FromRotationAroundAxis(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiMatrix4FromRotationAroundAxis(
      mat,
      axis,
      angle,
    );
  }

  late final _aiMatrix4FromRotationAroundAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiMatrix4FromRotationAroundAxis');
  late final _aiMatrix4FromRotationAroundAxis =
      _aiMatrix4FromRotationAroundAxisPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>, double)>();

  /// Get a 4x4 translation matrix.
  /// @param mat Receives the output matrix
  /// @param translation The translation vector
  void aiMatrix4Translation(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> translation,
  ) {
    return _aiMatrix4Translation(
      mat,
      translation,
    );
  }

  late final _aiMatrix4TranslationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4Translation');
  late final _aiMatrix4Translation = _aiMatrix4TranslationPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>)>();

  /// Get a 4x4 scaling matrix.
  /// @param mat Receives the output matrix
  /// @param scaling The scaling vector
  void aiMatrix4Scaling(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
  ) {
    return _aiMatrix4Scaling(
      mat,
      scaling,
    );
  }

  late final _aiMatrix4ScalingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4Scaling');
  late final _aiMatrix4Scaling = _aiMatrix4ScalingPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>)>();

  /// Create a 4x4 matrix that rotates one vector to another vector.
  /// @param mat Receives the output matrix
  /// @param from Vector to rotate from
  /// @param to Vector to rotate to
  void aiMatrix4FromTo(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> from,
    ffi.Pointer<aiVector3D> to,
  ) {
    return _aiMatrix4FromTo(
      mat,
      from,
      to,
    );
  }

  late final _aiMatrix4FromToPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4FromTo');
  late final _aiMatrix4FromTo = _aiMatrix4FromToPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Create a Quaternion from euler angles.
  /// @param q Receives the output quaternion
  /// @param x Rotation angle for the x-axis, in radians
  /// @param y Rotation angle for the y-axis, in radians
  /// @param z Rotation angle for the z-axis, in radians
  void aiQuaternionFromEulerAngles(
    ffi.Pointer<aiQuaternion> q,
    double x,
    double y,
    double z,
  ) {
    return _aiQuaternionFromEulerAngles(
      q,
      x,
      y,
      z,
    );
  }

  late final _aiQuaternionFromEulerAnglesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>, ffi.Float, ffi.Float,
              ffi.Float)>>('aiQuaternionFromEulerAngles');
  late final _aiQuaternionFromEulerAngles =
      _aiQuaternionFromEulerAnglesPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, double, double, double)>();

  /// Create a Quaternion from an axis angle pair.
  /// @param q Receives the output quaternion
  /// @param axis The orientation axis
  /// @param angle The rotation angle, in radians
  void aiQuaternionFromAxisAngle(
    ffi.Pointer<aiQuaternion> q,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiQuaternionFromAxisAngle(
      q,
      axis,
      angle,
    );
  }

  late final _aiQuaternionFromAxisAnglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiQuaternionFromAxisAngle');
  late final _aiQuaternionFromAxisAngle =
      _aiQuaternionFromAxisAnglePtr.asFunction<
          void Function(
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>, double)>();

  /// Create a Quaternion from a normalized quaternion stored
  /// in a 3D vector.
  /// @param q Receives the output quaternion
  /// @param normalized The vector that stores the quaternion
  void aiQuaternionFromNormalizedQuaternion(
    ffi.Pointer<aiQuaternion> q,
    ffi.Pointer<aiVector3D> normalized,
  ) {
    return _aiQuaternionFromNormalizedQuaternion(
      q,
      normalized,
    );
  }

  late final _aiQuaternionFromNormalizedQuaternionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>>(
      'aiQuaternionFromNormalizedQuaternion');
  late final _aiQuaternionFromNormalizedQuaternion =
      _aiQuaternionFromNormalizedQuaternionPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Check if quaternions are equal.
  /// @param a First quaternion to compare
  /// @param b Second quaternion to compare
  /// @return 1 if the quaternions are equal
  /// @return 0 if the quaternions are not equal
  int aiQuaternionAreEqual(
    ffi.Pointer<aiQuaternion> a,
    ffi.Pointer<aiQuaternion> b,
  ) {
    return _aiQuaternionAreEqual(
      a,
      b,
    );
  }

  late final _aiQuaternionAreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>)>>('aiQuaternionAreEqual');
  late final _aiQuaternionAreEqual = _aiQuaternionAreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>)>();

  /// Check if quaternions are equal using epsilon.
  /// @param a First quaternion to compare
  /// @param b Second quaternion to compare
  /// @param epsilon Epsilon
  /// @return 1 if the quaternions are equal
  /// @return 0 if the quaternions are not equal
  int aiQuaternionAreEqualEpsilon(
    ffi.Pointer<aiQuaternion> a,
    ffi.Pointer<aiQuaternion> b,
    double epsilon,
  ) {
    return _aiQuaternionAreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiQuaternionAreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>,
              ffi.Float)>>('aiQuaternionAreEqualEpsilon');
  late final _aiQuaternionAreEqualEpsilon =
      _aiQuaternionAreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>, double)>();

  /// Normalize a quaternion.
  /// @param q Quaternion to normalize
  void aiQuaternionNormalize(
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionNormalize(
      q,
    );
  }

  late final _aiQuaternionNormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiQuaternion>)>>(
          'aiQuaternionNormalize');
  late final _aiQuaternionNormalize = _aiQuaternionNormalizePtr
      .asFunction<void Function(ffi.Pointer<aiQuaternion>)>();

  /// Compute quaternion conjugate.
  /// @param q Quaternion to compute conjugate,
  /// receives the output quaternion
  void aiQuaternionConjugate(
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionConjugate(
      q,
    );
  }

  late final _aiQuaternionConjugatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiQuaternion>)>>(
          'aiQuaternionConjugate');
  late final _aiQuaternionConjugate = _aiQuaternionConjugatePtr
      .asFunction<void Function(ffi.Pointer<aiQuaternion>)>();

  /// Multiply quaternions.
  /// @param dst First quaternion, receives the output quaternion
  /// @param q Second quaternion
  void aiQuaternionMultiply(
    ffi.Pointer<aiQuaternion> dst,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionMultiply(
      dst,
      q,
    );
  }

  late final _aiQuaternionMultiplyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>)>>('aiQuaternionMultiply');
  late final _aiQuaternionMultiply = _aiQuaternionMultiplyPtr.asFunction<
      void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>)>();

  /// Performs a spherical interpolation between two quaternions.
  /// @param dst Receives the quaternion resulting from the interpolation.
  /// @param start Quaternion when factor == 0
  /// @param end Quaternion when factor == 1
  /// @param factor Interpolation factor between 0 and 1
  void aiQuaternionInterpolate(
    ffi.Pointer<aiQuaternion> dst,
    ffi.Pointer<aiQuaternion> start,
    ffi.Pointer<aiQuaternion> end,
    double factor,
  ) {
    return _aiQuaternionInterpolate(
      dst,
      start,
      end,
      factor,
    );
  }

  late final _aiQuaternionInterpolatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>,
              ffi.Float)>>('aiQuaternionInterpolate');
  late final _aiQuaternionInterpolate = _aiQuaternionInterpolatePtr.asFunction<
      void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>,
          ffi.Pointer<aiQuaternion>, double)>();

  /// @brief Returns a string with legal copyright and licensing information
  /// about Assimp. The string may include multiple lines.
  /// @return Pointer to static string.
  ffi.Pointer<ffi.Char> aiGetLegalString() {
    return _aiGetLegalString();
  }

  late final _aiGetLegalStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetLegalString');
  late final _aiGetLegalString =
      _aiGetLegalStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Returns the current patch version number of Assimp.
  /// @return Patch version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionPatch() {
    return _aiGetVersionPatch();
  }

  late final _aiGetVersionPatchPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionPatch');
  late final _aiGetVersionPatch =
      _aiGetVersionPatchPtr.asFunction<int Function()>();

  /// @brief Returns the current minor version number of Assimp.
  /// @return Minor version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMinor() {
    return _aiGetVersionMinor();
  }

  late final _aiGetVersionMinorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionMinor');
  late final _aiGetVersionMinor =
      _aiGetVersionMinorPtr.asFunction<int Function()>();

  /// @brief Returns the current major version number of Assimp.
  /// @return Major version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMajor() {
    return _aiGetVersionMajor();
  }

  late final _aiGetVersionMajorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionMajor');
  late final _aiGetVersionMajor =
      _aiGetVersionMajorPtr.asFunction<int Function()>();

  /// @brief Returns the repository revision of the Assimp runtime.
  /// @return SVN Repository revision number of the Assimp runtime the
  /// application was linked/built against.
  int aiGetVersionRevision() {
    return _aiGetVersionRevision();
  }

  late final _aiGetVersionRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionRevision');
  late final _aiGetVersionRevision =
      _aiGetVersionRevisionPtr.asFunction<int Function()>();

  /// @brief Returns the branch-name of the Assimp runtime.
  /// @return The current branch name.
  ffi.Pointer<ffi.Char> aiGetBranchName() {
    return _aiGetBranchName();
  }

  late final _aiGetBranchNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetBranchName');
  late final _aiGetBranchName =
      _aiGetBranchNamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Returns assimp's compile flags
  /// @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants.
  int aiGetCompileFlags() {
    return _aiGetCompileFlags();
  }

  late final _aiGetCompileFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetCompileFlags');
  late final _aiGetCompileFlags =
      _aiGetCompileFlagsPtr.asFunction<int Function()>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

typedef errno_t = ffi.Int;
typedef rsize_t = __darwin_size_t;
typedef __darwin_size_t = ffi.UnsignedLong;
typedef ssize_t = __darwin_ssize_t;
typedef __darwin_ssize_t = ffi.Long;

@ffi.Packed(1)
class _OSUnalignedU16 extends ffi.Struct {
  @ffi.Uint16()
  external int __val;
}

@ffi.Packed(1)
class _OSUnalignedU32 extends ffi.Struct {
  @ffi.Uint32()
  external int __val;
}

@ffi.Packed(1)
class _OSUnalignedU64 extends ffi.Struct {
  @ffi.Uint64()
  external int __val;
}

class fd_set extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__int32_t> fds_bits;
}

typedef __int32_t = ffi.Int;

abstract class aiComponent {
  static const int aiComponent_NORMALS = 2;
  static const int aiComponent_TANGENTS_AND_BITANGENTS = 4;
  static const int aiComponent_COLORS = 8;
  static const int aiComponent_TEXCOORDS = 16;
  static const int aiComponent_BONEWEIGHTS = 32;
  static const int aiComponent_ANIMATIONS = 64;
  static const int aiComponent_TEXTURES = 128;
  static const int aiComponent_LIGHTS = 256;
  static const int aiComponent_CAMERAS = 512;
  static const int aiComponent_MESHES = 1024;
  static const int aiComponent_MATERIALS = 2048;
  static const int _aiComponent_Force32Bit = -1610612737;
}

typedef ai_real = ffi.Float;

class __float2 extends ffi.Struct {
  @ffi.Float()
  external double __sinval;

  @ffi.Float()
  external double __cosval;
}

class __double2 extends ffi.Struct {
  @ffi.Double()
  external double __sinval;

  @ffi.Double()
  external double __cosval;
}

class exception extends ffi.Struct {
  @ffi.Int()
  external int type;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

class aiVector2D extends ffi.Struct {
  @ai_real()
  external double x;

  @ai_real()
  external double y;
}

class aiVector3D extends ffi.Struct {
  @ai_real()
  external double x;

  @ai_real()
  external double y;

  @ai_real()
  external double z;
}

class aiColor4D extends ffi.Struct {
  @ai_real()
  external double r;

  @ai_real()
  external double g;

  @ai_real()
  external double b;

  @ai_real()
  external double a;
}

class aiMatrix3x3 extends ffi.Struct {
  @ai_real()
  external double a1;

  @ai_real()
  external double a2;

  @ai_real()
  external double a3;

  @ai_real()
  external double b1;

  @ai_real()
  external double b2;

  @ai_real()
  external double b3;

  @ai_real()
  external double c1;

  @ai_real()
  external double c2;

  @ai_real()
  external double c3;
}

class aiMatrix4x4 extends ffi.Struct {
  @ai_real()
  external double a1;

  @ai_real()
  external double a2;

  @ai_real()
  external double a3;

  @ai_real()
  external double a4;

  @ai_real()
  external double b1;

  @ai_real()
  external double b2;

  @ai_real()
  external double b3;

  @ai_real()
  external double b4;

  @ai_real()
  external double c1;

  @ai_real()
  external double c2;

  @ai_real()
  external double c3;

  @ai_real()
  external double c4;

  @ai_real()
  external double d1;

  @ai_real()
  external double d2;

  @ai_real()
  external double d3;

  @ai_real()
  external double d4;
}

class aiQuaternion extends ffi.Struct {
  @ai_real()
  external double w;

  @ai_real()
  external double x;

  @ai_real()
  external double y;

  @ai_real()
  external double z;
}

class aiPlane extends ffi.Struct {
  @ai_real()
  external double a;

  @ai_real()
  external double b;

  @ai_real()
  external double c;

  @ai_real()
  external double d;
}

class aiRay extends ffi.Struct {
  external aiVector3D pos;

  external aiVector3D dir;
}

class aiColor3D extends ffi.Struct {
  @ai_real()
  external double r;

  @ai_real()
  external double g;

  @ai_real()
  external double b;
}

class aiString extends ffi.Struct {
  @ai_uint32()
  external int length;

  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> data;
}

typedef ai_uint32 = ffi.Uint32;

abstract class aiReturn {
  static const int aiReturn_SUCCESS = 0;
  static const int aiReturn_FAILURE = -1;
  static const int aiReturn_OUTOFMEMORY = -3;
  static const int _AI_ENFORCE_ENUM_SIZE = 2147483647;
}

abstract class aiOrigin {
  static const int aiOrigin_SET = 0;
  static const int aiOrigin_CUR = 1;
  static const int aiOrigin_END = 2;
  static const int _AI_ORIGIN_ENFORCE_ENUM_SIZE = 2147483647;
}

abstract class aiDefaultLogStream {
  static const int aiDefaultLogStream_FILE = 1;
  static const int aiDefaultLogStream_STDOUT = 2;
  static const int aiDefaultLogStream_STDERR = 4;
  static const int aiDefaultLogStream_DEBUGGER = 8;
  static const int _AI_DLS_ENFORCE_ENUM_SIZE = 2147483647;
}

class aiMemoryInfo extends ffi.Struct {
  @ffi.UnsignedInt()
  external int textures;

  @ffi.UnsignedInt()
  external int materials;

  @ffi.UnsignedInt()
  external int meshes;

  @ffi.UnsignedInt()
  external int nodes;

  @ffi.UnsignedInt()
  external int animations;

  @ffi.UnsignedInt()
  external int cameras;

  @ffi.UnsignedInt()
  external int lights;

  @ffi.UnsignedInt()
  external int total;
}

@ffi.Packed(1)
class aiTexel extends ffi.Struct {
  @ffi.UnsignedChar()
  external int b;

  @ffi.UnsignedChar()
  external int g;

  @ffi.UnsignedChar()
  external int r;

  @ffi.UnsignedChar()
  external int a;
}

class aiTexture extends ffi.Struct {
  @ffi.UnsignedInt()
  external int mWidth;

  @ffi.UnsignedInt()
  external int mHeight;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Char> achFormatHint;

  external ffi.Pointer<aiTexel> pcData;

  external aiString mFilename;
}

class aiAABB extends ffi.Struct {
  external aiVector3D mMin;

  external aiVector3D mMax;
}

class aiFace extends ffi.Struct {
  @ffi.UnsignedInt()
  external int mNumIndices;

  external ffi.Pointer<ffi.UnsignedInt> mIndices;
}

class aiVertexWeight extends ffi.Struct {
  @ffi.UnsignedInt()
  external int mVertexId;

  @ai_real()
  external double mWeight;
}

/// A node in the imported hierarchy.
///
/// Each node has name, a parent node (except for the root node),
/// a transformation relative to its parent and possibly several child nodes.
/// Simple file formats don't support hierarchical structures - for these formats
/// the imported scene does consist of only a single root node without children.
class aiNode extends ffi.Struct {
  /// The name of the node.
  ///
  /// The name might be empty (length of zero) but all nodes which
  /// need to be referenced by either bones or animations are named.
  /// Multiple nodes may have the same name, except for nodes which are referenced
  /// by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
  ///
  /// Cameras and lights reference a specific node by name - if there
  /// are multiple nodes with this name, they are assigned to each of them.
  /// <br>
  /// There are no limitations with regard to the characters contained in
  /// the name string as it is usually taken directly from the source file.
  ///
  /// Implementations should be able to handle tokens such as whitespace, tabs,
  /// line feeds, quotation marks, ampersands etc.
  ///
  /// Sometimes assimp introduces new nodes not present in the source file
  /// into the hierarchy (usually out of necessity because sometimes the
  /// source hierarchy format is simply not compatible). Their names are
  /// surrounded by @verbatim <> @endverbatim e.g.
  /// @verbatim<DummyRootNode> @endverbatim.
  external aiString mName;

  /// The transformation relative to the node's parent.
  external aiMatrix4x4 mTransformation;

  /// Parent node. nullptr if this node is the root node.
  external ffi.Pointer<aiNode> mParent;

  /// The number of child nodes of this node.
  @ffi.UnsignedInt()
  external int mNumChildren;

  /// The child nodes of this node. nullptr if mNumChildren is 0.
  external ffi.Pointer<ffi.Pointer<aiNode>> mChildren;

  /// The number of meshes of this node.
  @ffi.UnsignedInt()
  external int mNumMeshes;

  /// The meshes of this node. Each entry is an index into the
  /// mesh list of the #aiScene.
  external ffi.Pointer<ffi.UnsignedInt> mMeshes;

  /// Metadata associated with this node or nullptr if there is no metadata.
  /// Whether any metadata is generated depends on the source file format. See the
  /// @link importer_notes @endlink page for more information on every source file
  /// format. Importers that don't document any metadata don't write any.
  external ffi.Pointer<aiMetadata> mMetaData;
}

class aiMetadata extends ffi.Struct {
  @ffi.UnsignedInt()
  external int mNumProperties;

  external ffi.Pointer<aiString> mKeys;

  external ffi.Pointer<aiMetadataEntry> mValues;
}

class aiMetadataEntry extends ffi.Struct {
  @ffi.Int32()
  external int mType;

  external ffi.Pointer<ffi.Void> mData;
}

abstract class aiMetadataType {
  static const int AI_BOOL = 0;
  static const int AI_INT32 = 1;
  static const int AI_UINT64 = 2;
  static const int AI_FLOAT = 3;
  static const int AI_DOUBLE = 4;
  static const int AI_AISTRING = 5;
  static const int AI_AIVECTOR3D = 6;
  static const int AI_AIMETADATA = 7;
  static const int AI_META_MAX = 8;
  static const int FORCE_32BIT = 2147483647;
}

class aiBone extends ffi.Struct {
  external aiString mName;

  @ffi.UnsignedInt()
  external int mNumWeights;

  external ffi.Pointer<aiNode> mArmature;

  external ffi.Pointer<aiNode> mNode;

  external ffi.Pointer<aiVertexWeight> mWeights;

  external aiMatrix4x4 mOffsetMatrix;
}

abstract class aiPrimitiveType {
  static const int aiPrimitiveType_POINT = 1;
  static const int aiPrimitiveType_LINE = 2;
  static const int aiPrimitiveType_TRIANGLE = 4;
  static const int aiPrimitiveType_POLYGON = 8;
  static const int aiPrimitiveType_NGONEncodingFlag = 16;
  static const int _aiPrimitiveType_Force32Bit = 2147483647;
}

class aiAnimMesh extends ffi.Struct {
  external aiString mName;

  external ffi.Pointer<aiVector3D> mVertices;

  external ffi.Pointer<aiVector3D> mNormals;

  external ffi.Pointer<aiVector3D> mTangents;

  external ffi.Pointer<aiVector3D> mBitangents;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  @ffi.UnsignedInt()
  external int mNumVertices;

  @ffi.Float()
  external double mWeight;
}

abstract class aiMorphingMethod {
  static const int aiMorphingMethod_VERTEX_BLEND = 1;
  static const int aiMorphingMethod_MORPH_NORMALIZED = 2;
  static const int aiMorphingMethod_MORPH_RELATIVE = 3;
  static const int _aiMorphingMethod_Force32Bit = 2147483647;
}

class aiMesh extends ffi.Struct {
  @ffi.UnsignedInt()
  external int mPrimitiveTypes;

  @ffi.UnsignedInt()
  external int mNumVertices;

  @ffi.UnsignedInt()
  external int mNumFaces;

  external ffi.Pointer<aiVector3D> mVertices;

  external ffi.Pointer<aiVector3D> mNormals;

  external ffi.Pointer<aiVector3D> mTangents;

  external ffi.Pointer<aiVector3D> mBitangents;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> mNumUVComponents;

  external ffi.Pointer<aiFace> mFaces;

  @ffi.UnsignedInt()
  external int mNumBones;

  external ffi.Pointer<ffi.Pointer<aiBone>> mBones;

  @ffi.UnsignedInt()
  external int mMaterialIndex;

  external aiString mName;

  @ffi.UnsignedInt()
  external int mNumAnimMeshes;

  external ffi.Pointer<ffi.Pointer<aiAnimMesh>> mAnimMeshes;

  @ffi.UnsignedInt()
  external int mMethod;

  external aiAABB mAABB;

  external ffi.Pointer<ffi.Pointer<aiString>> mTextureCoordsNames;
}

abstract class aiLightSourceType {
  static const int aiLightSource_UNDEFINED = 0;
  static const int aiLightSource_DIRECTIONAL = 1;
  static const int aiLightSource_POINT = 2;
  static const int aiLightSource_SPOT = 3;
  static const int aiLightSource_AMBIENT = 4;
  static const int aiLightSource_AREA = 5;
  static const int _aiLightSource_Force32Bit = 2147483647;
}

class aiLight extends ffi.Struct {
  external aiString mName;

  @ffi.Int32()
  external int mType;

  external aiVector3D mPosition;

  external aiVector3D mDirection;

  external aiVector3D mUp;

  @ffi.Float()
  external double mAttenuationConstant;

  @ffi.Float()
  external double mAttenuationLinear;

  @ffi.Float()
  external double mAttenuationQuadratic;

  external aiColor3D mColorDiffuse;

  external aiColor3D mColorSpecular;

  external aiColor3D mColorAmbient;

  @ffi.Float()
  external double mAngleInnerCone;

  @ffi.Float()
  external double mAngleOuterCone;

  external aiVector2D mSize;
}

class aiCamera extends ffi.Struct {
  external aiString mName;

  external aiVector3D mPosition;

  external aiVector3D mUp;

  external aiVector3D mLookAt;

  @ffi.Float()
  external double mHorizontalFOV;

  @ffi.Float()
  external double mClipPlaneNear;

  @ffi.Float()
  external double mClipPlaneFar;

  @ffi.Float()
  external double mAspect;

  @ffi.Float()
  external double mOrthographicWidth;
}

abstract class aiTextureOp {
  static const int aiTextureOp_Multiply = 0;
  static const int aiTextureOp_Add = 1;
  static const int aiTextureOp_Subtract = 2;
  static const int aiTextureOp_Divide = 3;
  static const int aiTextureOp_SmoothAdd = 4;
  static const int aiTextureOp_SignedAdd = 5;
  static const int _aiTextureOp_Force32Bit = 2147483647;
}

abstract class aiTextureMapMode {
  static const int aiTextureMapMode_Wrap = 0;
  static const int aiTextureMapMode_Clamp = 1;
  static const int aiTextureMapMode_Decal = 3;
  static const int aiTextureMapMode_Mirror = 2;
  static const int _aiTextureMapMode_Force32Bit = 2147483647;
}

abstract class aiTextureMapping {
  static const int aiTextureMapping_UV = 0;
  static const int aiTextureMapping_SPHERE = 1;
  static const int aiTextureMapping_CYLINDER = 2;
  static const int aiTextureMapping_BOX = 3;
  static const int aiTextureMapping_PLANE = 4;
  static const int aiTextureMapping_OTHER = 5;
  static const int _aiTextureMapping_Force32Bit = 2147483647;
}

abstract class aiTextureType {
  static const int aiTextureType_NONE = 0;
  static const int aiTextureType_DIFFUSE = 1;
  static const int aiTextureType_SPECULAR = 2;
  static const int aiTextureType_AMBIENT = 3;
  static const int aiTextureType_EMISSIVE = 4;
  static const int aiTextureType_HEIGHT = 5;
  static const int aiTextureType_NORMALS = 6;
  static const int aiTextureType_SHININESS = 7;
  static const int aiTextureType_OPACITY = 8;
  static const int aiTextureType_DISPLACEMENT = 9;
  static const int aiTextureType_LIGHTMAP = 10;
  static const int aiTextureType_REFLECTION = 11;
  static const int aiTextureType_BASE_COLOR = 12;
  static const int aiTextureType_NORMAL_CAMERA = 13;
  static const int aiTextureType_EMISSION_COLOR = 14;
  static const int aiTextureType_METALNESS = 15;
  static const int aiTextureType_DIFFUSE_ROUGHNESS = 16;
  static const int aiTextureType_AMBIENT_OCCLUSION = 17;
  static const int aiTextureType_SHEEN = 19;
  static const int aiTextureType_CLEARCOAT = 20;
  static const int aiTextureType_TRANSMISSION = 21;
  static const int aiTextureType_UNKNOWN = 18;
  static const int _aiTextureType_Force32Bit = 2147483647;
}

abstract class aiShadingMode {
  static const int aiShadingMode_Flat = 1;
  static const int aiShadingMode_Gouraud = 2;
  static const int aiShadingMode_Phong = 3;
  static const int aiShadingMode_Blinn = 4;
  static const int aiShadingMode_Toon = 5;
  static const int aiShadingMode_OrenNayar = 6;
  static const int aiShadingMode_Minnaert = 7;
  static const int aiShadingMode_CookTorrance = 8;
  static const int aiShadingMode_NoShading = 9;
  static const int aiShadingMode_Unlit = 9;
  static const int aiShadingMode_Fresnel = 10;
  static const int aiShadingMode_PBR_BRDF = 11;
  static const int _aiShadingMode_Force32Bit = 2147483647;
}

abstract class aiTextureFlags {
  static const int aiTextureFlags_Invert = 1;
  static const int aiTextureFlags_UseAlpha = 2;
  static const int aiTextureFlags_IgnoreAlpha = 4;
  static const int _aiTextureFlags_Force32Bit = 2147483647;
}

abstract class aiBlendMode {
  static const int aiBlendMode_Default = 0;
  static const int aiBlendMode_Additive = 1;
  static const int _aiBlendMode_Force32Bit = 2147483647;
}

class aiUVTransform extends ffi.Struct {
  external aiVector2D mTranslation;

  external aiVector2D mScaling;

  @ai_real()
  external double mRotation;
}

abstract class aiPropertyTypeInfo {
  static const int aiPTI_Float = 1;
  static const int aiPTI_Double = 2;
  static const int aiPTI_String = 3;
  static const int aiPTI_Integer = 4;
  static const int aiPTI_Buffer = 5;
  static const int _aiPTI_Force32Bit = 2147483647;
}

class aiMaterialProperty extends ffi.Struct {
  external aiString mKey;

  @ffi.UnsignedInt()
  external int mSemantic;

  @ffi.UnsignedInt()
  external int mIndex;

  @ffi.UnsignedInt()
  external int mDataLength;

  @ffi.Int32()
  external int mType;

  external ffi.Pointer<ffi.Char> mData;
}

class aiMaterial extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<aiMaterialProperty>> mProperties;

  @ffi.UnsignedInt()
  external int mNumProperties;

  @ffi.UnsignedInt()
  external int mNumAllocated;
}

class aiVectorKey extends ffi.Struct {
  @ffi.Double()
  external double mTime;

  external aiVector3D mValue;
}

class aiQuatKey extends ffi.Struct {
  @ffi.Double()
  external double mTime;

  external aiQuaternion mValue;
}

class aiMeshKey extends ffi.Struct {
  @ffi.Double()
  external double mTime;

  @ffi.UnsignedInt()
  external int mValue;
}

class aiMeshMorphKey extends ffi.Struct {
  @ffi.Double()
  external double mTime;

  external ffi.Pointer<ffi.UnsignedInt> mValues;

  external ffi.Pointer<ffi.Double> mWeights;

  @ffi.UnsignedInt()
  external int mNumValuesAndWeights;
}

abstract class aiAnimBehaviour {
  static const int aiAnimBehaviour_DEFAULT = 0;
  static const int aiAnimBehaviour_CONSTANT = 1;
  static const int aiAnimBehaviour_LINEAR = 2;
  static const int aiAnimBehaviour_REPEAT = 3;
  static const int _aiAnimBehaviour_Force32Bit = 2147483647;
}

class aiNodeAnim extends ffi.Struct {
  external aiString mNodeName;

  @ffi.UnsignedInt()
  external int mNumPositionKeys;

  external ffi.Pointer<aiVectorKey> mPositionKeys;

  @ffi.UnsignedInt()
  external int mNumRotationKeys;

  external ffi.Pointer<aiQuatKey> mRotationKeys;

  @ffi.UnsignedInt()
  external int mNumScalingKeys;

  external ffi.Pointer<aiVectorKey> mScalingKeys;

  @ffi.Int32()
  external int mPreState;

  @ffi.Int32()
  external int mPostState;
}

class aiMeshAnim extends ffi.Struct {
  external aiString mName;

  @ffi.UnsignedInt()
  external int mNumKeys;

  external ffi.Pointer<aiMeshKey> mKeys;
}

class aiMeshMorphAnim extends ffi.Struct {
  external aiString mName;

  @ffi.UnsignedInt()
  external int mNumKeys;

  external ffi.Pointer<aiMeshMorphKey> mKeys;
}

class aiAnimation extends ffi.Struct {
  external aiString mName;

  @ffi.Double()
  external double mDuration;

  @ffi.Double()
  external double mTicksPerSecond;

  @ffi.UnsignedInt()
  external int mNumChannels;

  external ffi.Pointer<ffi.Pointer<aiNodeAnim>> mChannels;

  @ffi.UnsignedInt()
  external int mNumMeshChannels;

  external ffi.Pointer<ffi.Pointer<aiMeshAnim>> mMeshChannels;

  @ffi.UnsignedInt()
  external int mNumMorphMeshChannels;

  external ffi.Pointer<ffi.Pointer<aiMeshMorphAnim>> mMorphMeshChannels;
}

/// The root structure of the imported data.
///
/// Everything that was imported from the given file can be accessed from here.
/// Objects of this class are generally maintained and owned by Assimp, not
/// by the caller. You shouldn't want to instance it, nor should you ever try to
/// delete a given scene on your own.
class aiScene extends ffi.Struct {
  /// Any combination of the AI_SCENE_FLAGS_XXX flags. By default
  /// this value is 0, no flags are set. Most applications will
  /// want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE
  /// bit set.
  @ffi.UnsignedInt()
  external int mFlags;

  /// The root node of the hierarchy.
  ///
  /// There will always be at least the root node if the import
  /// was successful (and no special flags have been set).
  /// Presence of further nodes depends on the format and content
  /// of the imported file.
  external ffi.Pointer<aiNode> mRootNode;

  /// The number of meshes in the scene.
  @ffi.UnsignedInt()
  external int mNumMeshes;

  /// The array of meshes.
  ///
  /// Use the indices given in the aiNode structure to access
  /// this array. The array is mNumMeshes in size. If the
  /// AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
  /// be at least ONE material.
  external ffi.Pointer<ffi.Pointer<aiMesh>> mMeshes;

  /// The number of materials in the scene.
  @ffi.UnsignedInt()
  external int mNumMaterials;

  /// The array of materials.
  ///
  /// Use the index given in each aiMesh structure to access this
  /// array. The array is mNumMaterials in size. If the
  /// AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
  /// be at least ONE material.
  external ffi.Pointer<ffi.Pointer<aiMaterial>> mMaterials;

  /// The number of animations in the scene.
  @ffi.UnsignedInt()
  external int mNumAnimations;

  /// The array of animations.
  ///
  /// All animations imported from the given file are listed here.
  /// The array is mNumAnimations in size.
  external ffi.Pointer<ffi.Pointer<aiAnimation>> mAnimations;

  /// The number of textures embedded into the file
  @ffi.UnsignedInt()
  external int mNumTextures;

  /// The array of embedded textures.
  ///
  /// Not many file formats embed their textures into the file.
  /// An example is Quake's MDL format (which is also used by
  /// some GameStudio versions)
  external ffi.Pointer<ffi.Pointer<aiTexture>> mTextures;

  /// The number of light sources in the scene. Light sources
  /// are fully optional, in most cases this attribute will be 0
  @ffi.UnsignedInt()
  external int mNumLights;

  /// The array of light sources.
  ///
  /// All light sources imported from the given file are
  /// listed here. The array is mNumLights in size.
  external ffi.Pointer<ffi.Pointer<aiLight>> mLights;

  /// The number of cameras in the scene. Cameras
  /// are fully optional, in most cases this attribute will be 0
  @ffi.UnsignedInt()
  external int mNumCameras;

  /// The array of cameras.
  ///
  /// All cameras imported from the given file are listed here.
  /// The array is mNumCameras in size. The first camera in the
  /// array (if existing) is the default camera view into
  /// the scene.
  external ffi.Pointer<ffi.Pointer<aiCamera>> mCameras;

  /// @brief  The global metadata assigned to the scene itself.
  ///
  /// This data contains global metadata which belongs to the scene like
  /// unit-conversions, versions, vendors or other model-specific data. This
  /// can be used to store format-specific metadata as well.
  external ffi.Pointer<aiMetadata> mMetaData;

  /// The name of the scene itself.
  external aiString mName;

  external ffi.Pointer<ffi.Char> mPrivate;
}

/// @brief C-API: File system callbacks
///
/// Provided are functions to open and close files. Supply a custom structure to
/// the import function. If you don't, a default implementation is used. Use custom
/// file systems to enable reading from other sources, such as ZIPs
/// or memory locations.
class aiFileIO extends ffi.Struct {
  /// Function used to open a new file
  external aiFileOpenProc OpenProc;

  /// Function used to close an existing file
  external aiFileCloseProc CloseProc;

  /// User-defined, opaque data
  external aiUserData UserData;
}

typedef aiFileOpenProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<aiFile> Function(ffi.Pointer<aiFileIO>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>;

/// @brief C-API: File callbacks
///
/// Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)
/// replacement functions.
///
/// The default implementation of the functions utilizes the fXXX functions from
/// the CRT. However, you can supply a custom implementation to Assimp by
/// delivering a custom aiFileIO. Use this to enable reading from other sources,
/// such as ZIP archives or memory locations.
class aiFile extends ffi.Struct {
  /// Callback to read from a file
  external aiFileReadProc ReadProc;

  /// Callback to write to a file
  external aiFileWriteProc WriteProc;

  /// Callback to retrieve the current position of
  /// the file cursor (ftell())
  external aiFileTellProc TellProc;

  /// Callback to retrieve the size of the file,
  /// in bytes
  external aiFileTellProc FileSizeProc;

  /// Callback to set the current position
  /// of the file cursor (fseek())
  external aiFileSeek SeekProc;

  /// Callback to flush the file contents
  external aiFileFlushProc FlushProc;

  /// User-defined, opaque data
  external aiUserData UserData;
}

typedef aiFileReadProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Size Function(
            ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size)>>;
typedef aiFileWriteProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Size Function(
            ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size)>>;
typedef aiFileTellProc
    = ffi.Pointer<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<aiFile>)>>;
typedef aiFileSeek = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<aiFile>, ffi.Size, ffi.Int32)>>;
typedef aiFileFlushProc
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiFile>)>>;
typedef aiUserData = ffi.Pointer<ffi.Char>;
typedef aiFileCloseProc = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<aiFileIO>, ffi.Pointer<aiFile>)>>;

/// @brief  Describes an file format which Assimp can export to.
///
/// Use #aiGetExportFormatCount() to learn how many export-formats are supported by
/// the current Assimp-build and #aiGetExportFormatDescription() to retrieve the
/// description of the export format option.
class aiExportFormatDesc extends ffi.Struct {
  /// a short string ID to uniquely identify the export format. Use this ID string to
  /// specify which file format you want to export to when calling #aiExportScene().
  /// Example: "dae" or "obj"
  external ffi.Pointer<ffi.Char> id;

  /// A short description of the file format to present to users. Useful if you want
  /// to allow the user to select an export format.
  external ffi.Pointer<ffi.Char> description;

  /// Recommended file extension for the exported file in lower case.
  external ffi.Pointer<ffi.Char> fileExtension;
}

/// Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an
/// exported scene. The memory referred by this structure is owned by Assimp.
/// to free its resources. Don't try to free the memory on your side - it will crash for most build configurations
/// due to conflicting heaps.
///
/// Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.
/// This is used when exporters write more than one output file for a given #aiScene. See the remarks for
/// #aiExportDataBlob::name for more information.
class aiExportDataBlob extends ffi.Struct {
  /// Size of the data in bytes
  @ffi.Size()
  external int size;

  /// The data.
  external ffi.Pointer<ffi.Void> data;

  /// Name of the blob. An empty string always
  /// indicates the first (and primary) blob,
  /// which contains the actual file data.
  /// Any other blobs are auxiliary files produced
  /// by exporters (i.e. material files). Existence
  /// of such files depends on the file format. Most
  /// formats don't split assets across multiple files.
  ///
  /// If used, blob names usually contain the file
  /// extension that should be used when writing
  /// the data to disc.
  ///
  /// The blob names generated can be influenced by
  /// setting the #AI_CONFIG_EXPORT_BLOB_NAME export
  /// property to the name that is used for the master
  /// blob. All other names are typically derived from
  /// the base name, by the file format exporter.
  external aiString name;

  /// Pointer to the next blob in the chain or NULL if there is none.
  external ffi.Pointer<aiExportDataBlob> next;
}

abstract class aiImporterFlags {
  static const int aiImporterFlags_SupportTextFlavour = 1;
  static const int aiImporterFlags_SupportBinaryFlavour = 2;
  static const int aiImporterFlags_SupportCompressedFlavour = 4;
  static const int aiImporterFlags_LimitedSupport = 8;
  static const int aiImporterFlags_Experimental = 16;
}

class aiImporterDesc extends ffi.Struct {
  external ffi.Pointer<ffi.Char> mName;

  external ffi.Pointer<ffi.Char> mAuthor;

  external ffi.Pointer<ffi.Char> mMaintainer;

  external ffi.Pointer<ffi.Char> mComments;

  @ffi.UnsignedInt()
  external int mFlags;

  @ffi.UnsignedInt()
  external int mMinMajor;

  @ffi.UnsignedInt()
  external int mMinMinor;

  @ffi.UnsignedInt()
  external int mMaxMajor;

  @ffi.UnsignedInt()
  external int mMaxMinor;

  external ffi.Pointer<ffi.Char> mFileExtensions;
}

/// C-API: Represents a log stream. A log stream receives all log messages and
/// streams them _somewhere_.
/// @see aiGetPredefinedLogStream
/// @see aiAttachLogStream
/// @see aiDetachLogStream
class aiLogStream extends ffi.Struct {
  /// callback to be called
  external aiLogStreamCallback callback;

  /// user data to be passed to the callback
  external ffi.Pointer<ffi.Char> user;
}

typedef aiLogStreamCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>;

/// C-API: Represents an opaque set of settings to be used during importing.
/// @see aiCreatePropertyStore
/// @see aiReleasePropertyStore
/// @see aiImportFileExWithProperties
/// @see aiSetPropertyInteger
/// @see aiSetPropertyFloat
/// @see aiSetPropertyString
/// @see aiSetPropertyMatrix
class aiPropertyStore extends ffi.Struct {
  @ffi.Char()
  external int sentinel;
}

/// Our own C boolean type
typedef aiBool = ffi.Int;

/// @enum  aiPostProcessSteps
/// @brief Defines the flags for all possible post processing steps.
///
/// @note Some steps are influenced by properties set on the Assimp::Importer itself
///
/// @see Assimp::Importer::ReadFile()
/// @see Assimp::Importer::SetPropertyInteger()
/// @see aiImportFile
/// @see aiImportFileEx
abstract class aiPostProcessSteps {
  /// <hr>Calculates the tangents and bitangents for the imported meshes.
  ///
  /// Does nothing if a mesh does not have normals. You might want this post
  /// processing step to be executed if you plan to use tangent space calculations
  /// such as normal mapping  applied to the meshes. There's an importer property,
  /// <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify
  /// a maximum smoothing angle for the algorithm. However, usually you'll
  /// want to leave it at the default value.
  static const int aiProcess_CalcTangentSpace = 1;

  /// <hr>Identifies and joins identical vertex data sets within all
  /// imported meshes.
  ///
  /// After this step is run, each mesh contains unique vertices,
  /// so a vertex may be used by multiple faces. You usually want
  /// to use this post processing step. If your application deals with
  /// indexed geometry, this step is compulsory or you'll just waste rendering
  /// time. <b>If this flag is not specified</b>, no vertices are referenced by
  /// more than one face and <b>no index buffer is required</b> for rendering.
  static const int aiProcess_JoinIdenticalVertices = 2;

  /// <hr>Converts all the imported data to a left-handed coordinate space.
  ///
  /// By default the data is returned in a right-handed coordinate space (which
  /// OpenGL prefers). In this space, +X points to the right,
  /// +Z points towards the viewer, and +Y points upwards. In the DirectX
  /// coordinate space +X points to the right, +Y points upwards, and +Z points
  /// away from the viewer.
  ///
  /// You'll probably want to consider this flag if you use Direct3D for
  /// rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
  /// setting and bundles all conversions typically required for D3D-based
  /// applications.
  static const int aiProcess_MakeLeftHanded = 4;

  /// <hr>Triangulates all faces of all meshes.
  ///
  /// By default the imported mesh data might contain faces with more than 3
  /// indices. For rendering you'll usually want all faces to be triangles.
  /// This post processing step splits up faces with more than 3 indices into
  /// triangles. Line and point primitives are *not* modified! If you want
  /// 'triangles only' with no other kinds of primitives, try the following
  /// solution:
  /// <ul>
  /// <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>
  /// <li>Ignore all point and line meshes when you process assimp's output</li>
  /// </ul>
  static const int aiProcess_Triangulate = 8;

  /// <hr>Removes some parts of the data structure (animations, materials,
  /// light sources, cameras, textures, vertex components).
  ///
  /// The  components to be removed are specified in a separate
  /// importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful
  /// if you don't need all parts of the output structure. Vertex colors
  /// are rarely used today for example... Calling this step to remove unneeded
  /// data from the pipeline as early as possible results in increased
  /// performance and a more optimized output data structure.
  /// This step is also useful if you want to force Assimp to recompute
  /// normals or tangents. The corresponding steps don't recompute them if
  /// they're already there (loaded from the source asset). By using this
  /// step you can make sure they are NOT there.
  ///
  /// This flag is a poor one, mainly because its purpose is usually
  /// misunderstood. Consider the following case: a 3D model has been exported
  /// from a CAD app, and it has per-face vertex colors. Vertex positions can't be
  /// shared, thus the #aiProcess_JoinIdenticalVertices step fails to
  /// optimize the data because of these nasty little vertex colors.
  /// Most apps don't even process them, so it's all for nothing. By using
  /// this step, unneeded components are excluded as early as possible
  /// thus opening more room for internal optimizations.
  static const int aiProcess_RemoveComponent = 16;

  /// <hr>Generates normals for all faces of all meshes.
  ///
  /// This is ignored if normals are already there at the time this flag
  /// is evaluated. Model importers try to load them from the source file, so
  /// they're usually already there. Face normals are shared between all points
  /// of a single face, so a single point can have multiple normals, which
  /// forces the library to duplicate vertices in some cases.
  /// #aiProcess_JoinIdenticalVertices is *senseless* then.
  ///
  /// This flag may not be specified together with #aiProcess_GenSmoothNormals.
  static const int aiProcess_GenNormals = 32;

  /// <hr>Generates smooth normals for all vertices in the mesh.
  ///
  /// This is ignored if normals are already there at the time this flag
  /// is evaluated. Model importers try to load them from the source file, so
  /// they're usually already there.
  ///
  /// This flag may not be specified together with
  /// #aiProcess_GenNormals. There's a importer property,
  /// <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify
  /// an angle maximum for the normal smoothing algorithm. Normals exceeding
  /// this limit are not smoothed, resulting in a 'hard' seam between two faces.
  /// Using a decent angle here (e.g. 80 degrees) results in very good visual
  /// appearance.
  static const int aiProcess_GenSmoothNormals = 64;

  /// <hr>Splits large meshes into smaller sub-meshes.
  ///
  /// This is quite useful for real-time rendering, where the number of triangles
  /// which can be maximally processed in a single draw-call is limited
  /// by the video driver/hardware. The maximum vertex buffer is usually limited
  /// too. Both requirements can be met with this step: you may specify both a
  /// triangle and vertex limit for a single mesh.
  ///
  /// The split limits can (and should!) be set through the
  /// <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>
  /// importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and
  /// <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>.
  ///
  /// Note that splitting is generally a time-consuming task, but only if there's
  /// something to split. The use of this step is recommended for most users.
  static const int aiProcess_SplitLargeMeshes = 128;

  /// <hr>Removes the node graph and pre-transforms all vertices with
  /// the local transformation matrices of their nodes.
  ///
  /// If the resulting scene can be reduced to a single mesh, with a single
  /// material, no lights, and no cameras, then the output scene will contain
  /// only a root node (with no children) that references the single mesh.
  /// Otherwise, the output scene will be reduced to a root node with a single
  /// level of child nodes, each one referencing one mesh, and each mesh
  /// referencing one material.
  ///
  /// In either case, for rendering, you can
  /// simply render all meshes in order - you don't need to pay
  /// attention to local transformations and the node hierarchy.
  /// Animations are removed during this step.
  /// This step is intended for applications without a scenegraph.
  /// The step CAN cause some problems: if e.g. a mesh of the asset
  /// contains normals and another, using the same material index, does not,
  /// they will be brought together, but the first meshes's part of
  /// the normal list is zeroed. However, these artifacts are rare.
  /// @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property
  /// can be set to normalize the scene's spatial dimension to the -1...1
  /// range.
  static const int aiProcess_PreTransformVertices = 256;

  /// <hr>Limits the number of bones simultaneously affecting a single vertex
  /// to a maximum value.
  ///
  /// If any vertex is affected by more than the maximum number of bones, the least
  /// important vertex weights are removed and the remaining vertex weights are
  /// renormalized so that the weights still sum up to 1.
  /// The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in
  /// config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer
  /// property to supply your own limit to the post processing step.
  ///
  /// If you intend to perform the skinning in hardware, this post processing
  /// step might be of interest to you.
  static const int aiProcess_LimitBoneWeights = 512;

  /// <hr>Validates the imported scene data structure.
  /// This makes sure that all indices are valid, all animations and
  /// bones are linked correctly, all material references are correct .. etc.
  ///
  /// It is recommended that you capture Assimp's log output if you use this flag,
  /// so you can easily find out what's wrong if a file fails the
  /// validation. The validator is quite strict and will find *all*
  /// inconsistencies in the data structure... It is recommended that plugin
  /// developers use it to debug their loaders. There are two types of
  /// validation failures:
  /// <ul>
  /// <li>Error: There's something wrong with the imported data. Further
  /// postprocessing is not possible and the data is not usable at all.
  /// The import fails. #Importer::GetErrorString() or #aiGetErrorString()
  /// carry the error message around.</li>
  /// <li>Warning: There are some minor issues (e.g. 1000000 animation
  /// keyframes with the same time), but further postprocessing and use
  /// of the data structure is still safe. Warning details are written
  /// to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set
  /// in #aiScene::mFlags</li>
  /// </ul>
  ///
  /// This post-processing step is not time-consuming. Its use is not
  /// compulsory, but recommended.
  static const int aiProcess_ValidateDataStructure = 1024;

  /// <hr>Reorders triangles for better vertex cache locality.
  ///
  /// The step tries to improve the ACMR (average post-transform vertex cache
  /// miss ratio) for all meshes. The implementation runs in O(n) and is
  /// roughly based on the 'tipsify' algorithm (see <a href="
  /// http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf">this
  /// paper</a>).
  ///
  /// If you intend to render huge models in hardware, this step might
  /// be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>
  /// importer property can be used to fine-tune the cache optimization.
  static const int aiProcess_ImproveCacheLocality = 2048;

  /// <hr>Searches for redundant/unreferenced materials and removes them.
  ///
  /// This is especially useful in combination with the
  /// #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.
  /// Both join small meshes with equal characteristics, but they can't do
  /// their work if two meshes have different materials. Because several
  /// material settings are lost during Assimp's import filters,
  /// (and because many exporters don't check for redundant materials), huge
  /// models often have materials which are are defined several times with
  /// exactly the same settings.
  ///
  /// Several material settings not contributing to the final appearance of
  /// a surface are ignored in all comparisons (e.g. the material name).
  /// So, if you're passing additional information through the
  /// content pipeline (probably using *magic* material names), don't
  /// specify this flag. Alternatively take a look at the
  /// <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property.
  static const int aiProcess_RemoveRedundantMaterials = 4096;

  /// <hr>This step tries to determine which meshes have normal vectors
  /// that are facing inwards and inverts them.
  ///
  /// The algorithm is simple but effective:
  /// the bounding box of all vertices + their normals is compared against
  /// the volume of the bounding box of all vertices without their normals.
  /// This works well for most objects, problems might occur with planar
  /// surfaces. However, the step tries to filter such cases.
  /// The step inverts all in-facing normals. Generally it is recommended
  /// to enable this step, although the result is not always correct.
  static const int aiProcess_FixInfacingNormals = 8192;

  /// This step generically populates aiBone->mArmature and aiBone->mNode generically
  /// The point of these is it saves you later having to calculate these elements
  /// This is useful when handling rest information or skin information
  /// If you have multiple armatures on your models we strongly recommend enabling this
  /// Instead of writing your own multi-root, multi-armature lookups we have done the
  /// hard work for you :)
  static const int aiProcess_PopulateArmatureData = 16384;

  /// <hr>This step splits meshes with more than one primitive type in
  /// homogeneous sub-meshes.
  ///
  /// The step is executed after the triangulation step. After the step
  /// returns, just one bit is set in aiMesh::mPrimitiveTypes. This is
  /// especially useful for real-time rendering where point and line
  /// primitives are often ignored or rendered separately.
  /// You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
  /// specify which primitive types you need. This can be used to easily
  /// exclude lines and points, which are rarely used, from the import.
  static const int aiProcess_SortByPType = 32768;

  /// <hr>This step searches all meshes for degenerate primitives and
  /// converts them to proper lines or points.
  ///
  /// A face is 'degenerate' if one or more of its points are identical.
  /// To have the degenerate stuff not only detected and collapsed but
  /// removed, try one of the following procedures:
  /// <br><b>1.</b> (if you support lines and points for rendering but don't
  /// want the degenerates)<br>
  /// <ul>
  /// <li>Specify the #aiProcess_FindDegenerates flag.
  /// </li>
  /// <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to
  /// 1. This will cause the step to remove degenerate triangles from the
  /// import as soon as they're detected. They won't pass any further
  /// pipeline steps.
  /// </li>
  /// </ul>
  /// <br><b>2.</b>(if you don't support lines and points at all)<br>
  /// <ul>
  /// <li>Specify the #aiProcess_FindDegenerates flag.
  /// </li>
  /// <li>Specify the #aiProcess_SortByPType flag. This moves line and
  /// point primitives to separate meshes.
  /// </li>
  /// <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
  /// @code aiPrimitiveType_POINTS | aiPrimitiveType_LINES
  /// @endcode to cause SortByPType to reject point
  /// and line meshes from the scene.
  /// </li>
  /// </ul>
  ///
  /// This step also removes very small triangles with a surface area smaller
  /// than 10^-6. If you rely on having these small triangles, or notice holes
  /// in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to
  /// false.
  /// @note Degenerate polygons are not necessarily evil and that's why
  /// they're not removed by default. There are several file formats which
  /// don't support lines or points, and some exporters bypass the
  /// format specification and write them as degenerate triangles instead.
  static const int aiProcess_FindDegenerates = 65536;

  /// <hr>This step searches all meshes for invalid data, such as zeroed
  /// normal vectors or invalid UV coords and removes/fixes them. This is
  /// intended to get rid of some common exporter errors.
  ///
  /// This is especially useful for normals. If they are invalid, and
  /// the step recognizes this, they will be removed and can later
  /// be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>
  /// The step will also remove meshes that are infinitely small and reduce
  /// animation tracks consisting of hundreds if redundant keys to a single
  /// key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides
  /// the accuracy of the check for duplicate animation tracks.
  static const int aiProcess_FindInvalidData = 131072;

  /// <hr>This step converts non-UV mappings (such as spherical or
  /// cylindrical mapping) to proper texture coordinate channels.
  ///
  /// Most applications will support UV mapping only, so you will
  /// probably want to specify this step in every case. Note that Assimp is not
  /// always able to match the original mapping implementation of the
  /// 3D app which produced a model perfectly. It's always better to let the
  /// modelling app compute the UV channels - 3ds max, Maya, Blender,
  /// LightWave, and Modo do this for example.
  ///
  /// @note If this step is not requested, you'll need to process the
  /// <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets
  /// properly.
  static const int aiProcess_GenUVCoords = 262144;

  /// <hr>This step applies per-texture UV transformations and bakes
  /// them into stand-alone vtexture coordinate channels.
  ///
  /// UV transformations are specified per-texture - see the
  /// <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.
  /// This step processes all textures with
  /// transformed input UV coordinates and generates a new (pre-transformed) UV channel
  /// which replaces the old channel. Most applications won't support UV
  /// transformations, so you will probably want to specify this step.
  ///
  /// @note UV transformations are usually implemented in real-time apps by
  /// transforming texture coordinates at vertex shader stage with a 3x3
  /// (homogeneous) transformation matrix.
  static const int aiProcess_TransformUVCoords = 524288;

  /// <hr>This step searches for duplicate meshes and replaces them
  /// with references to the first mesh.
  ///
  /// This step takes a while, so don't use it if speed is a concern.
  /// Its main purpose is to workaround the fact that many export
  /// file formats don't support instanced meshes, so exporters need to
  /// duplicate meshes. This step removes the duplicates again. Please
  /// note that Assimp does not currently support per-node material
  /// assignment to meshes, which means that identical meshes with
  /// different materials are currently *not* joined, although this is
  /// planned for future versions.
  static const int aiProcess_FindInstances = 1048576;

  /// <hr>A post-processing step to reduce the number of meshes.
  ///
  /// This will, in fact, reduce the number of draw calls.
  ///
  /// This is a very effective optimization and is recommended to be used
  /// together with #aiProcess_OptimizeGraph, if possible. The flag is fully
  /// compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType.
  static const int aiProcess_OptimizeMeshes = 2097152;

  /// <hr>A post-processing step to optimize the scene hierarchy.
  ///
  /// Nodes without animations, bones, lights or cameras assigned are
  /// collapsed and joined.
  ///
  /// Node names can be lost during this step. If you use special 'tag nodes'
  /// to pass additional information through your content pipeline, use the
  /// <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a
  /// list of node names you want to be kept. Nodes matching one of the names
  /// in this list won't be touched or modified.
  ///
  /// Use this flag with caution. Most simple files will be collapsed to a
  /// single node, so complex hierarchies are usually completely lost. This is not
  /// useful for editor environments, but probably a very effective
  /// optimization if you just want to get the model data, convert it to your
  /// own format, and render it as fast as possible.
  ///
  /// This flag is designed to be used with #aiProcess_OptimizeMeshes for best
  /// results.
  ///
  /// @note 'Crappy' scenes with thousands of extremely small meshes packed
  /// in deeply nested nodes exist for almost all file formats.
  /// #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph
  /// usually fixes them all and makes them renderable.
  static const int aiProcess_OptimizeGraph = 4194304;

  /// <hr>This step flips all UV coordinates along the y-axis and adjusts
  /// material settings and bitangents accordingly.
  ///
  /// <b>Output UV coordinate system:</b>
  /// @code
  /// 0y|0y ---------- 1x|0y
  /// |                 |
  /// |                 |
  /// |                 |
  /// 0x|1y ---------- 1x|1y
  /// @endcode
  ///
  /// You'll probably want to consider this flag if you use Direct3D for
  /// rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
  /// setting and bundles all conversions typically required for D3D-based
  /// applications.
  static const int aiProcess_FlipUVs = 8388608;

  /// <hr>This step adjusts the output face winding order to be CW.
  ///
  /// The default face winding order is counter clockwise (CCW).
  ///
  /// <b>Output face order:</b>
  /// @code
  /// x2
  ///
  /// x0
  /// x1
  /// @endcode
  static const int aiProcess_FlipWindingOrder = 16777216;

  /// <hr>This step splits meshes with many bones into sub-meshes so that each
  /// sub-mesh has fewer or as many bones as a given limit.
  static const int aiProcess_SplitByBoneCount = 33554432;

  /// <hr>This step removes bones losslessly or according to some threshold.
  ///
  /// In some cases (i.e. formats that require it) exporters are forced to
  /// assign dummy bone weights to otherwise static meshes assigned to
  /// animated meshes. Full, weight-based skinning is expensive while
  /// animating nodes is extremely cheap, so this step is offered to clean up
  /// the data in that regard.
  ///
  /// Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.
  /// Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and
  /// only if all bones within the scene qualify for removal.
  static const int aiProcess_Debone = 67108864;

  /// <hr>This step will perform a global scale of the model.
  ///
  /// Some importers are providing a mechanism to define a scaling unit for the
  /// model. This post processing step can be used to do so. You need to get the
  /// global scaling from your importer settings like in FBX. Use the flag
  /// AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.
  ///
  /// Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor.
  static const int aiProcess_GlobalScale = 134217728;

  /// <hr>A postprocessing step to embed of textures.
  ///
  /// This will remove external data dependencies for textures.
  /// If a texture's file does not exist at the specified path
  /// (due, for instance, to an absolute path generated on another system),
  /// it will check if a file with the same name exists at the root folder
  /// of the imported model. And if so, it uses that.
  static const int aiProcess_EmbedTextures = 268435456;
  static const int aiProcess_ForceGenNormals = 536870912;

  /// <hr>Drops normals for all faces of all meshes.
  ///
  /// This is ignored if no normals are present.
  /// Face normals are shared between all points of a single face,
  /// so a single point can have multiple normals, which
  /// forces the library to duplicate vertices in some cases.
  /// #aiProcess_JoinIdenticalVertices is *senseless* then.
  /// This process gives sense back to aiProcess_JoinIdenticalVertices
  static const int aiProcess_DropNormals = 1073741824;

  ///
  static const int aiProcess_GenBoundingBoxes = -2147483648;
}

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_CLK_TCK = 100;

const int CHAR_BIT = 8;

const int MB_LEN_MAX = 6;

const int CLK_TCK = 100;

const int SCHAR_MAX = 127;

const int SCHAR_MIN = -128;

const int UCHAR_MAX = 255;

const int CHAR_MAX = 127;

const int CHAR_MIN = -128;

const int USHRT_MAX = 65535;

const int SHRT_MAX = 32767;

const int SHRT_MIN = -32768;

const int UINT_MAX = 4294967295;

const int INT_MAX = 2147483647;

const int INT_MIN = -2147483648;

const int ULONG_MAX = -1;

const int LONG_MAX = 9223372036854775807;

const int LONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int LONG_BIT = 64;

const int SSIZE_MAX = 9223372036854775807;

const int WORD_BIT = 32;

const int SIZE_T_MAX = -1;

const int UQUAD_MAX = -1;

const int QUAD_MAX = 9223372036854775807;

const int QUAD_MIN = -9223372036854775808;

const int ARG_MAX = 1048576;

const int CHILD_MAX = 266;

const int GID_MAX = 2147483647;

const int LINK_MAX = 32767;

const int MAX_CANON = 1024;

const int MAX_INPUT = 1024;

const int NAME_MAX = 255;

const int NGROUPS_MAX = 16;

const int UID_MAX = 2147483647;

const int OPEN_MAX = 10240;

const int PATH_MAX = 1024;

const int PIPE_BUF = 512;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int CHARCLASS_NAME_MAX = 14;

const int COLL_WEIGHTS_MAX = 2;

const int EQUIV_CLASS_MAX = 2;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int RE_DUP_MAX = 255;

const int NZERO = 20;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_EQUIV_CLASS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_KEYS_MAX = 512;

const int PTHREAD_STACK_MIN = 16384;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_SS_REPL_MAX = 4;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TRACE_EVENT_NAME_MAX = 30;

const int _POSIX_TRACE_NAME_MAX = 8;

const int _POSIX_TRACE_SYS_MAX = 8;

const int _POSIX_TRACE_USER_EVENT_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX_RE_DUP_MAX = 255;

const int OFF_MIN = -9223372036854775808;

const int OFF_MAX = 9223372036854775807;

const int PASS_MAX = 128;

const int NL_ARGMAX = 9;

const int NL_LANGMAX = 14;

const int NL_MSGMAX = 32767;

const int NL_NMAX = 1;

const int NL_SETMAX = 255;

const int NL_TEXTMAX = 2048;

const int _XOPEN_IOV_MAX = 16;

const int IOV_MAX = 1024;

const int _XOPEN_NAME_MAX = 255;

const int _XOPEN_PATH_MAX = 1024;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_12_0 = 120000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 120000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 120300;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int __DARWIN_FD_SETSIZE = 1024;

const int __DARWIN_NBBY = 8;

const int __DARWIN_NFDBITS = 32;

const int NBBY = 8;

const int NFDBITS = 32;

const int FD_SETSIZE = 1024;

const String AI_CONFIG_GLOB_MEASURE_TIME = 'GLOB_MEASURE_TIME';

const String AI_CONFIG_IMPORT_NO_SKELETON_MESHES = 'IMPORT_NO_SKELETON_MESHES';

const String AI_CONFIG_PP_SBBC_MAX_BONES = 'PP_SBBC_MAX_BONES';

const int AI_SBBC_DEFAULT_MAX_BONES = 60;

const String AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE = 'PP_CT_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX =
    'PP_CT_TEXTURE_CHANNEL_INDEX';

const String AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE =
    'PP_GSN_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_IMPORT_MDL_COLORMAP = 'IMPORT_MDL_COLORMAP';

const String AI_CONFIG_PP_RRM_EXCLUDE_LIST = 'PP_RRM_EXCLUDE_LIST';

const String AI_CONFIG_PP_PTV_KEEP_HIERARCHY = 'PP_PTV_KEEP_HIERARCHY';

const String AI_CONFIG_PP_PTV_NORMALIZE = 'PP_PTV_NORMALIZE';

const String AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION =
    'PP_PTV_ADD_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION =
    'PP_PTV_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_FD_REMOVE = 'PP_FD_REMOVE';

const String AI_CONFIG_PP_FD_CHECKAREA = 'PP_FD_CHECKAREA';

const String AI_CONFIG_PP_OG_EXCLUDE_LIST = 'PP_OG_EXCLUDE_LIST';

const String AI_CONFIG_PP_SLM_TRIANGLE_LIMIT = 'PP_SLM_TRIANGLE_LIMIT';

const int AI_SLM_DEFAULT_MAX_TRIANGLES = 1000000;

const String AI_CONFIG_PP_SLM_VERTEX_LIMIT = 'PP_SLM_VERTEX_LIMIT';

const int AI_SLM_DEFAULT_MAX_VERTICES = 1000000;

const String AI_CONFIG_PP_LBW_MAX_WEIGHTS = 'PP_LBW_MAX_WEIGHTS';

const int AI_LMW_MAX_WEIGHTS = 4;

const String AI_CONFIG_PP_DB_THRESHOLD = 'PP_DB_THRESHOLD';

const double AI_DEBONE_THRESHOLD = 1.0;

const String AI_CONFIG_PP_DB_ALL_OR_NONE = 'PP_DB_ALL_OR_NONE';

const int PP_ICL_PTCACHE_SIZE = 12;

const String AI_CONFIG_PP_ICL_PTCACHE_SIZE = 'PP_ICL_PTCACHE_SIZE';

const String AI_CONFIG_PP_RVC_FLAGS = 'PP_RVC_FLAGS';

const String AI_CONFIG_PP_SBP_REMOVE = 'PP_SBP_REMOVE';

const String AI_CONFIG_PP_FID_ANIM_ACCURACY = 'PP_FID_ANIM_ACCURACY';

const String AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS =
    'PP_FID_IGNORE_TEXTURECOORDS';

const int AI_UVTRAFO_SCALING = 1;

const int AI_UVTRAFO_ROTATION = 2;

const int AI_UVTRAFO_TRANSLATION = 4;

const int AI_UVTRAFO_ALL = 7;

const String AI_CONFIG_PP_TUV_EVALUATE = 'PP_TUV_EVALUATE';

const String AI_CONFIG_FAVOUR_SPEED = 'FAVOUR_SPEED';

const String AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER =
    'IMPORT_SCHEMA_DOCUMENT_PROVIDER';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS =
    'IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS =
    'IMPORT_FBX_READ_ALL_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_MATERIALS = 'IMPORT_FBX_READ_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_TEXTURES = 'IMPORT_FBX_READ_TEXTURES';

const String AI_CONFIG_IMPORT_FBX_READ_CAMERAS = 'IMPORT_FBX_READ_CAMERAS';

const String AI_CONFIG_IMPORT_FBX_READ_LIGHTS = 'IMPORT_FBX_READ_LIGHTS';

const String AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS =
    'IMPORT_FBX_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_FBX_READ_WEIGHTS = 'IMPORT_FBX_READ_WEIGHTS';

const String AI_CONFIG_IMPORT_FBX_STRICT_MODE = 'IMPORT_FBX_STRICT_MODE';

const String AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS =
    'IMPORT_FBX_PRESERVE_PIVOTS';

const String AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES =
    'IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES';

const String AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING =
    'AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING';

const String AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES =
    'AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES';

const String AI_CONFIG_FBX_CONVERT_TO_M = 'AI_CONFIG_FBX_CONVERT_TO_M';

const String AI_CONFIG_IMPORT_GLOBAL_KEYFRAME = 'IMPORT_GLOBAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MD3_KEYFRAME = 'IMPORT_MD3_KEYFRAME';

const String AI_CONFIG_IMPORT_MD2_KEYFRAME = 'IMPORT_MD2_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_KEYFRAME = 'IMPORT_MDL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDC_KEYFRAME = 'IMPORT_MDC_KEYFRAME';

const String AI_CONFIG_IMPORT_SMD_KEYFRAME = 'IMPORT_SMD_KEYFRAME';

const String AI_CONFIG_IMPORT_UNREAL_KEYFRAME = 'IMPORT_UNREAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS =
    'IMPORT_MDL_HL1_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS =
    'IMPORT_MDL_HL1_READ_ANIMATION_EVENTS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS =
    'IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS =
    'IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS =
    'IMPORT_MDL_HL1_READ_ATTACHMENTS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS =
    'IMPORT_MDL_HL1_READ_BONE_CONTROLLERS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES =
    'IMPORT_MDL_HL1_READ_HITBOXES';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO =
    'IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO';

const String AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST =
    'IMPORT_SMD_LOAD_ANIMATION_LIST';

const String AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL = 'IMPORT_AC_SEPARATE_BFCULL';

const String AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION =
    'IMPORT_AC_EVAL_SUBDIVISION';

const String AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS = 'UNREAL_HANDLE_FLAGS';

const String AI_CONFIG_IMPORT_TER_MAKE_UVS = 'IMPORT_TER_MAKE_UVS';

const String AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS =
    'IMPORT_ASE_RECONSTRUCT_NORMALS';

const String AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART =
    'IMPORT_MD3_HANDLE_MULTIPART';

const String AI_CONFIG_IMPORT_MD3_SKIN_NAME = 'IMPORT_MD3_SKIN_NAME';

const String AI_CONFIG_IMPORT_MD3_LOAD_SHADERS = 'IMPORT_MD3_LOAD_SHADERS';

const String AI_CONFIG_IMPORT_MD3_SHADER_SRC = 'IMPORT_MD3_SHADER_SRC';

const String AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY = 'IMPORT_LWO_ONE_LAYER_ONLY';

const String AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD =
    'IMPORT_MD5_NO_ANIM_AUTOLOAD';

const String AI_CONFIG_IMPORT_LWS_ANIM_START = 'IMPORT_LWS_ANIM_START';

const String AI_CONFIG_IMPORT_LWS_ANIM_END = 'IMPORT_LWS_ANIM_END';

const String AI_CONFIG_IMPORT_IRR_ANIM_FPS = 'IMPORT_IRR_ANIM_FPS';

const String AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE = 'IMPORT_OGRE_MATERIAL_FILE';

const String AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME =
    'IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME';

const String AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT =
    'AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT';

const String AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS =
    'IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS';

const String AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION =
    'IMPORT_IFC_CUSTOM_TRIANGULATION';

const String AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE =
    'IMPORT_IFC_SMOOTHING_ANGLE';

const double AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE = 10.0;

const String AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION =
    'IMPORT_IFC_CYLINDRICAL_TESSELLATION';

const int AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION = 32;

const String AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION =
    'IMPORT_COLLADA_IGNORE_UP_DIRECTION';

const String AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES =
    'IMPORT_COLLADA_USE_COLLADA_NAMES';

const String AI_CONFIG_EXPORT_XFILE_64BIT = 'EXPORT_XFILE_64BIT';

const String AI_CONFIG_EXPORT_POINT_CLOUDS = 'EXPORT_POINT_CLOUDS';

const String AI_CONFIG_EXPORT_BLOB_NAME = 'EXPORT_BLOB_NAME';

const String AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY = 'GLOBAL_SCALE_FACTOR';

const double AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT = 1.0;

const String AI_CONFIG_APP_SCALE_KEY = 'APP_SCALE_FACTOR';

const int ASSIMP_AI_REAL_TEXT_PRECISION = 9;

const double AI_MATH_PI = 3.141592653589793;

const double AI_MATH_TWO_PI = 6.283185307179586;

const double AI_MATH_HALF_PI = 1.5707963267948966;

const double AI_MATH_PI_F = 3.1415927410125732;

const double AI_MATH_TWO_PI_F = 6.2831854820251465;

const double AI_MATH_HALF_PI_F = 1.5707963705062866;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double NAN = double.nan;

const double INFINITY = double.infinity;

const int FP_NAN = 1;

const int FP_INFINITE = 2;

const int FP_ZERO = 3;

const int FP_NORMAL = 4;

const int FP_SUBNORMAL = 5;

const int FP_SUPERNORMAL = 6;

const int FP_FAST_FMA = 1;

const int FP_FAST_FMAF = 1;

const int FP_FAST_FMAL = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = -2147483648;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const double M_E = 2.718281828459045;

const double M_LOG2E = 1.4426950408889634;

const double M_LOG10E = 0.4342944819032518;

const double M_LN2 = 0.6931471805599453;

const double M_LN10 = 2.302585092994046;

const double M_PI = 3.141592653589793;

const double M_PI_2 = 1.5707963267948966;

const double M_PI_4 = 0.7853981633974483;

const double M_1_PI = 0.3183098861837907;

const double M_2_PI = 0.6366197723675814;

const double M_2_SQRTPI = 1.1283791670955126;

const double M_SQRT2 = 1.4142135623730951;

const double M_SQRT1_2 = 0.7071067811865476;

const double MAXFLOAT = 3.4028234663852886e+38;

const int FP_SNAN = 1;

const int FP_QNAN = 1;

const double HUGE = 3.4028234663852886e+38;

const double X_TLOSS = 14148475504056880.0;

const int DOMAIN = 1;

const int SING = 2;

const int OVERFLOW = 3;

const int UNDERFLOW = 4;

const int TLOSS = 5;

const int PLOSS = 6;

const int MAXLEN = 1024;

const int AI_SUCCESS = 0;

const int AI_FAILURE = -1;

const int AI_OUTOFMEMORY = -3;

const int DLS_FILE = 1;

const int DLS_STDOUT = 2;

const int DLS_STDERR = 4;

const int DLS_DEBUGGER = 8;

const String AI_EMBEDDED_TEXNAME_PREFIX = '*';

const int HINTMAXTEXTURELEN = 9;

const int AI_MAX_FACE_INDICES = 32767;

const int AI_MAX_BONE_WEIGHTS = 2147483647;

const int AI_MAX_VERTICES = 2147483647;

const int AI_MAX_FACES = 2147483647;

const int AI_MAX_NUMBER_OF_COLOR_SETS = 8;

const int AI_MAX_NUMBER_OF_TEXTURECOORDS = 8;

const String AI_DEFAULT_MATERIAL_NAME = 'DefaultMaterial';

const int AI_TEXTURE_TYPE_MAX = 21;

const String AI_MATKEY_NAME = '?mat.name';

const String AI_MATKEY_TWOSIDED = '\$mat.twosided';

const String AI_MATKEY_SHADING_MODEL = '\$mat.shadingm';

const String AI_MATKEY_ENABLE_WIREFRAME = '\$mat.wireframe';

const String AI_MATKEY_BLEND_FUNC = '\$mat.blend';

const String AI_MATKEY_OPACITY = '\$mat.opacity';

const String AI_MATKEY_TRANSPARENCYFACTOR = '\$mat.transparencyfactor';

const String AI_MATKEY_BUMPSCALING = '\$mat.bumpscaling';

const String AI_MATKEY_SHININESS = '\$mat.shininess';

const String AI_MATKEY_REFLECTIVITY = '\$mat.reflectivity';

const String AI_MATKEY_SHININESS_STRENGTH = '\$mat.shinpercent';

const String AI_MATKEY_REFRACTI = '\$mat.refracti';

const String AI_MATKEY_COLOR_DIFFUSE = '\$clr.diffuse';

const String AI_MATKEY_COLOR_AMBIENT = '\$clr.ambient';

const String AI_MATKEY_COLOR_SPECULAR = '\$clr.specular';

const String AI_MATKEY_COLOR_EMISSIVE = '\$clr.emissive';

const String AI_MATKEY_COLOR_TRANSPARENT = '\$clr.transparent';

const String AI_MATKEY_COLOR_REFLECTIVE = '\$clr.reflective';

const String AI_MATKEY_GLOBAL_BACKGROUND_IMAGE = '?bg.global';

const String AI_MATKEY_GLOBAL_SHADERLANG = '?sh.lang';

const String AI_MATKEY_SHADER_VERTEX = '?sh.vs';

const String AI_MATKEY_SHADER_FRAGMENT = '?sh.fs';

const String AI_MATKEY_SHADER_GEO = '?sh.gs';

const String AI_MATKEY_SHADER_TESSELATION = '?sh.ts';

const String AI_MATKEY_SHADER_PRIMITIVE = '?sh.ps';

const String AI_MATKEY_SHADER_COMPUTE = '?sh.cs';

const String AI_MATKEY_USE_COLOR_MAP = '\$mat.useColorMap';

const String AI_MATKEY_BASE_COLOR = '\$clr.base';

const int AI_MATKEY_BASE_COLOR_TEXTURE = 12;

const String AI_MATKEY_USE_METALLIC_MAP = '\$mat.useMetallicMap';

const String AI_MATKEY_METALLIC_FACTOR = '\$mat.metallicFactor';

const int AI_MATKEY_METALLIC_TEXTURE = 15;

const String AI_MATKEY_USE_ROUGHNESS_MAP = '\$mat.useRoughnessMap';

const String AI_MATKEY_ROUGHNESS_FACTOR = '\$mat.roughnessFactor';

const int AI_MATKEY_ROUGHNESS_TEXTURE = 16;

const String AI_MATKEY_ANISOTROPY_FACTOR = '\$mat.anisotropyFactor';

const String AI_MATKEY_SPECULAR_FACTOR = '\$mat.specularFactor';

const String AI_MATKEY_GLOSSINESS_FACTOR = '\$mat.glossinessFactor';

const String AI_MATKEY_SHEEN_COLOR_FACTOR = '\$clr.sheen.factor';

const String AI_MATKEY_SHEEN_ROUGHNESS_FACTOR = '\$mat.sheen.roughnessFactor';

const int AI_MATKEY_SHEEN_COLOR_TEXTURE = 19;

const int AI_MATKEY_SHEEN_ROUGHNESS_TEXTURE = 19;

const String AI_MATKEY_CLEARCOAT_FACTOR = '\$mat.clearcoat.factor';

const String AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR =
    '\$mat.clearcoat.roughnessFactor';

const int AI_MATKEY_CLEARCOAT_TEXTURE = 20;

const int AI_MATKEY_CLEARCOAT_ROUGHNESS_TEXTURE = 20;

const int AI_MATKEY_CLEARCOAT_NORMAL_TEXTURE = 20;

const String AI_MATKEY_TRANSMISSION_FACTOR = '\$mat.transmission.factor';

const int AI_MATKEY_TRANSMISSION_TEXTURE = 21;

const String AI_MATKEY_VOLUME_THICKNESS_FACTOR = '\$mat.volume.thicknessFactor';

const int AI_MATKEY_VOLUME_THICKNESS_TEXTURE = 21;

const String AI_MATKEY_VOLUME_ATTENUATION_DISTANCE =
    '\$mat.volume.attenuationDistance';

const String AI_MATKEY_VOLUME_ATTENUATION_COLOR =
    '\$mat.volume.attenuationColor';

const String AI_MATKEY_USE_EMISSIVE_MAP = '\$mat.useEmissiveMap';

const String AI_MATKEY_EMISSIVE_INTENSITY = '\$mat.emissiveIntensity';

const String AI_MATKEY_USE_AO_MAP = '\$mat.useAOMap';

const String _AI_MATKEY_TEXTURE_BASE = '\$tex.file';

const String _AI_MATKEY_UVWSRC_BASE = '\$tex.uvwsrc';

const String _AI_MATKEY_TEXOP_BASE = '\$tex.op';

const String _AI_MATKEY_MAPPING_BASE = '\$tex.mapping';

const String _AI_MATKEY_TEXBLEND_BASE = '\$tex.blend';

const String _AI_MATKEY_MAPPINGMODE_U_BASE = '\$tex.mapmodeu';

const String _AI_MATKEY_MAPPINGMODE_V_BASE = '\$tex.mapmodev';

const String _AI_MATKEY_TEXMAP_AXIS_BASE = '\$tex.mapaxis';

const String _AI_MATKEY_UVTRANSFORM_BASE = '\$tex.uvtrafo';

const String _AI_MATKEY_TEXFLAGS_BASE = '\$tex.flags';

const int AI_SCENE_FLAGS_INCOMPLETE = 1;

const int AI_SCENE_FLAGS_VALIDATED = 2;

const int AI_SCENE_FLAGS_VALIDATION_WARNING = 4;

const int AI_SCENE_FLAGS_NON_VERBOSE_FORMAT = 8;

const int AI_SCENE_FLAGS_TERRAIN = 16;

const int AI_SCENE_FLAGS_ALLOW_SHARED = 32;

const int AI_FALSE = 0;

const int AI_TRUE = 1;

const int ASSIMP_CFLAGS_SHARED = 1;

const int ASSIMP_CFLAGS_STLPORT = 2;

const int ASSIMP_CFLAGS_DEBUG = 4;

const int ASSIMP_CFLAGS_NOBOOST = 8;

const int ASSIMP_CFLAGS_SINGLETHREADED = 16;

const int ASSIMP_CFLAGS_DOUBLE_SUPPORT = 32;

const int aiProcess_ConvertToLeftHanded = 25165828;

const int aiProcessPreset_TargetRealtime_Fast = 294955;

const int aiProcessPreset_TargetRealtime_Quality = 498379;

const int aiProcessPreset_TargetRealtime_MaxQuality = 3645131;
